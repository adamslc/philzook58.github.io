---
author: philzook58
comments: true
date: 2020-08-10 20:35:44+00:00
layout: post
link: https://www.philipzucker.com/?p=2892
published: false
slug: Knuth Bendix
title: Knuth Bendix
wordpress_id: 2892
---




Knuth Bendix completion is interesintg. It solves the word problem







String rewriting can be use to normalize finitely presented categories sometimes. If we list the generating morphisms and the base equalities of composition, knuth bendix may be able to generate the closure, which we can use to figure out if two morphisms are the same with a guarantee.







String matching algorithms are relevant.







The Boyer Moore algorithm makes some jumps based on comparisons you've already made. These jumps can be calculated based on properties of the pattern







[https://www.sciencedirect.com/science/article/pii/S1567832610001025](https://www.sciencedirect.com/science/article/pii/S1567832610001025) - efficiency issues in the kbmag procedure. Describes using suffix trees to find critical pairs







[https://gap-packages.github.io/kbmag/doc/chap1.html#X7DFB63A97E67C0A1](https://gap-packages.github.io/kbmag/doc/chap1.html#X7DFB63A97E67C0A1) KBMAG gap package. Accessible through GAP.jl







Are the SKI combinators expressible in string rewriting? They have a tree structure and are expressed as such ordinarily. Maybe parenthesis can be used as inhibitors? Or we could have a moving evaluation marker?






    
    <code>(S) -> S
    (K) -> K
    (I) -> I
    IK -> K
    IS -> S
    II -> I
    ... all concrete
    Sxyz = xz(yz)
    
    </code>







Building a turing machien out of a string rewrite system. Have special characters represent the state. and have the patterns include the surrounding context. Enumerate all the characters in state and tape characters.






    
    <code>aSb -> acS
    aSb -> Scb</code>













Computational group theory is a thing.













Finite categories which have both finite morphisms and finite objects are approachable. It is clear that most questions one might ask about a finite category is approachable by brute force or maybe by encoding to some graph problems or SAT problem.







Finitely presented categories are the next up the chain in complexity. In this case we take a free category generated by some morphisms and some equations identifying certain composition patterns. It is less clear whether natural questions are decidable or not.







What questions do we care about:







  * Are two morphisms expressions equal?
  * Produce a morphism from object A to B
  * Confirm some mapping is a Functor
  * Confirm some functor mapping is a natural transformation.






It is my belief that some questions about these can 







The next level of category one might want to talk about is one for which you have guaranteed constructions, such as cartesian, closed, dagger, monoidal, etc. I'm not sure which of these qualifiers are compatible with being finite. [https://arxiv.org/abs/0908.3347](https://arxiv.org/abs/0908.3347)  To me, this feels analogous to being able to work with terms rather than just strings.







jk [https://www.youtube.com/watch?v=WdawrT-6Qzk](https://www.youtube.com/watch?v=WdawrT-6Qzk) gershom Bazerman Homological computation for term rewriting systems



