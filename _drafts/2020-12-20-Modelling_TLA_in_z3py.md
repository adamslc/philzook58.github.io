---
author: Philip Zucker
date: 2020-12-20
layout: post
title: Modelling TLA+ in Z3Py
---

It's that time of year again where I'm fiddling around with Z3py. I'm booting it back up because I'm schedule to do a [tutorial on Z3](https://fmie2021.github.io/agenda.html) on Feb 3. It's kind of silly because I probably already have too much content, and the tutorial is aimed at newbies, but there are some fun new things that I've learned in the last year I can do in Z3.

[TLA+](https://lamport.azurewebsites.net/tla/tla.html) is a (relatively) popular modelling/specification language for computational processes, in particular concurrent ones. It's the mind child of Leslie Lamport, the same guy behind [LaTex](https://en.wikipedia.org/wiki/LaTeX) and [Paxos](https://en.wikipedia.org/wiki/Paxos_(computer_science)). The language doesn't aim for deep verification of your actual code like as is sometimes the goal with tools like Coq, but because of that it is significantly more lightweight and easy to use. 
The TLA+ Toolbox is a freely available IDE and checker to TLA+, but I think it is kind of a neat idea to replicate something strongly in the flavor of TLA+ in all too familiar python. By using Z3, we get a lot mileage for free.

[Z3](https://rise4fun.com/z3/tutorial) is an SMT solver. Its input language [smtlib2](http://smtlib.cs.uiowa.edu/examples.shtml) is a kind of typed first order logic with special support for things like booleans, integers, reals, bitvectors, and algebraic datatypes. You can ask Z3 if propositions are valid, or if not it can provide a counterexample. It works pretty crazy good, especially if you work around its weaknesses (mostly quantifiers and nasty nonlinear stuff). The Z3 python bindings are widely regarded as very good.


Using Z3 I feel has a decent shot of being more scalable than the checking used by TLC, which as I understand it is brute force search for countermodels.


Downsides:

* Very ad hoc. The use of special autogenerated names is a great way to inadvertently smash things together
* TLA syntax is designed to be readable. The python adds a lot of noise
* TLA toolbox can format specs nicely using latex.
* TLA has a lot of thought gone into it. Making changes to it after an afternoon of thought is probably not to be trusted

Upsides:
* Better fits Z3, so we get good automation from the get go
* python is lingua franca of computing


At least one breakage with TLA+ is it's insistence on a lack of intrinsic types. Types are instead propositions that are proved in the system. This just is really not convenient for using with Z3.

The main unusual things TLA brings into play compared to bog standard logics is the notion of primed variables $$x'$$, representing the values of variables at the next time step, and some temporal propositional operators like always and eventually.

We could mark primes by creating variables in pairs
```python
x, xnxt = Ints("x x'")
```

But I've chosen to mark the prime variables using a special uninterpreted function

```python
def nxt(x): # next is a special function for generators in python
    assert is_const(x)
    assert f.decl().kind() == Z3_OP_UNINTERPRETED:
    s = x.sort()
    return Function("nxt", s, s)(x)
```

Then we can implement an `always` operator via a fairly simple procedure, we just roll out the execution of any formula for `n` time steps. This is the trick of bounded model checking. This can be achieved automatically by using the Z3 `substitute` function, a surprisingly useful little fellow.


```python
# collects up all the variable from a formula
# https://stackoverflow.com/questions/14080398/z3py-how-to-get-the-list-of-variables-from-a-formula
def get_vars(f):
    r = set()
    def collect(f):
      if is_const(f): 
          if f.decl().kind() == Z3_OP_UNINTERPRETED:
              r.add(f)
      else:
          for c in f.children():
              collect(c)
    collect(f)
    return r


#https://theory.stanford.edu/~nikolaj/programmingz3.html#sec-bounded-model-checking
def always(p,n=20):
    orig_vs = get_vars(p)
    nextvs = orig_vs
    t = True
    for i in range(1,n):
        vs = nextvs
        nextvs =  [ Const( f"{str(v)}_{i}", v.sort()) for v in orig_vs  ]
        p1 = substitute(p, [ (nxt(v), nextv) for v, nextv in zip(orig_vs,nextvs)  ]) 
        p2 = substitute(p1, [ (orig_v, v) for orig_v, v in zip(orig_vs,vs)  ])
        t = And(t,p2)
    return t
```

Here for example is the specification of a clock from the Specifying Systems book.

```python
hr = Int("hr")
HCini = And(0 <= hr, hr <= 12)
HCnxt = nxt(hr) == If(hr != 12, hr + 1, 1)
HC = And(HCini, always(HCnxt)) 
prove(Implies(HC,  always(HCini))) # prove clock always stays between 0 and 12 (for 20 times steps anyway)
```

### Links

Apalache is a Z3 backed model checker for TLA+
https://github.com/informalsystems/apalache


  * https://www.microsoft.com/en-us/research/uploads/prod/2018/05/book-02-08-08.pdf Specifying Systems
  * https://pron.github.io/tlaplus
  * https://github.com/cobusve/TLAPLUS_DeadlockEmpire
  * https://www.learntla.com/introduction/
  * https://github.com/tlaplus/Examples