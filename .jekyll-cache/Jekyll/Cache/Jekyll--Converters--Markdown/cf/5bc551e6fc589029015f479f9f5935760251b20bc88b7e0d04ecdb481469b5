I"<p>Our approach to the Cartpole is not black box. A Cartpole is a pretty simple system all things considered.</p>

<p>The first thing to do is derive the equations of motion. Originally I was using the Lagrangian for the system and deriving the equations of motion that way, which includes the back reaction of the pole back on the acceleration of the cart for example.</p>

<p>But the motor complicates things. I have a tough time in general modeling motors. What physical thing does a command to our motor driver correspond to? Velocity? Power? Torque? I have guesses. The easiest thing to do is just build and measure. It turns out for us that the commands are basically velocity control.</p>

<p>So in our case the back reaction is basically irrelevant. We have direct control over the cart velocity. In that case, one can use some easy enough hand waving to get the equations of motion.</p>

<p>Let’s set the angle $latex \theta = 0$ at pole down with positive angle going counter clockwise. We can assume that gravity acts at the center of mass of the pole, which is at the midpoint. This gives a torque $latex \tau = -mg \frac{L}{2} \sin(\theta)$. One way to see the negative sign is that a slight positive angle should give a negative torque returning it back to the down position. The moment of inertia of the pole is $latex mL^2/3$. You can look this up as a pole around one of it’s ends or derive it from $latex I =\int dm r^2$. The $latex \frac{1}{3}$ comes from the integration of the $latex r^2$. Putting these together we get $latex mL^2/3 \ddot{\theta} = -mg  \frac{L}{2} \sin(\theta) $ .</p>

<p>Now we need to actually put in the cart stuff. The cart puts the pole in an accelerating frame, where basically you have a new component of gravity that points horizontally. This adds a torque $latex -ma  \frac{L}{2} \cos(\theta) $. As far as all of the signs go, honestly we just fiddled with them until it worked.</p>

<p>Now that we have all that in hand, we can talk about the Linear Quadratic Regulator (LQR) control.</p>

<p><a href="https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic_regulator">https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic_regulator</a></p>

<p>The model that LQR uses is that the equations of motion are linear and the cost function that you want to minimize are quadratic in the controls $latex u$ and state $latex x$. This is plausibly tractable because Quadratic and linear stuff is usually ok. I’m serious.</p>

<p>These letter choices for the various bits are pretty standard.</p>

<p>$latex cost = \int x^TQx + u^TRu dt $</p>

<p>$latex \dot{x}=Ax+Bu$</p>

<p>If you just look at the wikipedia page, you can already just plug and chug to the solution.</p>

<p>$latex u = -Kx$</p>

<p>$latex K= R^{-1} B^T P$</p>

<p>$latex A^TP + PA - PBR^{-1}B^TP + Q = 0  $</p>

<p>Jesus that equation looks like shit.</p>

<p>which is QUITE CONVENIENTLY solved by the following scipy function <a href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.solve_continuous_are.html">https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.solve_continuous_are.html</a></p>

<p>HOW SUSPICIOUS.</p>

<p>Now given this shit, we need to approximate our nonlinear equations of motion with linear equations in order to use the LQR framework.</p>

<p>$latex mL^2/3 \ddot{\theta} = -m \frac{L}{2}( g\sin(\theta) + a \cos(\theta)) $</p>

<p>Near the top where we are linearizing</p>

<p>$latex \delta\theta = \theta - \pi$</p>

<p>$latex \sin(\theta)\approx-\delta\theta$</p>

<p>and</p>

<p>$latex \cos(\theta)\approx-1$</p>

<p>$latex mL^2/3 \ddot{\delta\theta} \approx m \frac{L}{2}(g\delta\theta+a)$</p>

<p>We can move some of those constants to the other side to get $latex \ddot{\delta\theta}$ by itself.</p>

<p>$latex \ddot{\delta\theta} \approx \frac{3}{2L}( g\delta\theta + a) $</p>

<p>Another thing you have to do is massage these second order equations into first order form. You do this by introducing a new state variable $latex \omega $</p>

<p>$latex \dot{\delta\theta} = \omega$</p>

<p>$latex \dot{\omega} \approx \frac{3}{2L}( g\delta\theta + a) $</p>

<p>In matrix form this is</p>

<p>$latex \begin{bmatrix}\dot{\delta\theta} \ \dot{\omega}  \end{bmatrix} =</p>

<p>\begin{bmatrix} 0 &amp; 1 \</p>

<p>\frac{3}{2L} g &amp; 0</p>

<p>\end{bmatrix}</p>

<p>\begin{bmatrix}\delta\theta \ \omega \end{bmatrix}</p>

<p>+</p>

<p>\begin{bmatrix} 0 \ \frac{3}{2L} \end{bmatrix} \begin{bmatrix} a \end{bmatrix}  $</p>

<p>In addition to this, it is nice to add the cart dynamics, even though they are pretty trivial. This is because we can then add some weighting terms to discourage the cart from trying to go off the track or go faster than the motors support. There are ways to make it so that the cartpole never tries to go out of bounds, but they are a bit more complicated. I’ve got some blog posts about them.</p>

<p>$latex \begin{bmatrix}\dot{\delta\theta} \ \dot{\omega} \ \dot{x} \ \dot{v}  \end{bmatrix} =</p>

<p>\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \</p>

<p>\frac{3}{2L} g &amp; 0 &amp; 0 &amp; 0 \</p>

<p>0 &amp; 0 &amp; 0 &amp; 1\</p>

<p>0 &amp; 0 &amp; 0 &amp; 0 \</p>

<p>\end{bmatrix}</p>

<p>\begin{bmatrix}\delta\theta \ \omega \ x \ v \end{bmatrix}</p>

<p>+</p>

<p>\begin{bmatrix} 0 \ \frac{3}{2L} \ 0 \ 1 \end{bmatrix} \begin{bmatrix} a \end{bmatrix}  $</p>

<p>So we can read off our needed matrices A and B from here.</p>

<p>$latex A =</p>

<p>\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \</p>

<p>\frac{3}{2L} g &amp; 0 &amp; 0 &amp; 0 \</p>

<p>0 &amp; 0 &amp; 0 &amp; 1\</p>

<p>0 &amp; 0 &amp; 0 &amp; 0 \</p>

<p>\end{bmatrix}</p>

<p>$</p>

<p>$latex B = \begin{bmatrix} 0 \ \frac{3}{2L} \ 0 \ 1 \end{bmatrix}$</p>

<p>Now in regards to the weighting matrices Q and R, this is a bit tougher to say what we want. We sort of want all the state variables to be small but the relative important isn’t a priori clear to me. So we picked diagonal matrices and tried out some different values. One thing to note though is that the states variables could possibly have very different scales, since their units are different. The characteristic time of the system is $latex T=\sqrt{\frac{L}{g}}$. The characteristic length is the size of our track $latex 1000mm$ and the rough angle scale is $latex \pi/8 $-ish.</p>

<p>Now that we have our matrices we can plug it all into scipy and use it!</p>

<p>One thing to be careful about is that the pole can have swung around multiple times leading to the angle being some multiple of $latex 2\pi$. Our hack around this is to just take the $latex \sin$ of the angle.</p>

:ET