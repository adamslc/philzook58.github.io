I"îQ<p><a href="http://www.philipzucker.com/a-short-skinny-on-relations-towards-the-algebra-of-programming/">Last time</a>,  I tried to give a primer of relations and relational algebra using the Haskell type <code class="language-plaintext highlighter-rouge">type Rel a b = [(a,b)]</code>. In this post we‚Äôre going to look at these ideas from a slightly different angle. Instead of encoding relations using value level sets, we‚Äôll encode relations in the type system.  The <a href="https://github.com/scmu/aopa">Algebra of Programming Agda repo</a> and the papers quoted therein are very relevant, so if you‚Äôre comfortable wading into those waters, give them a look. You can find my repo for <a href="https://github.com/philzook58/rel/blob/master/src/ProRel.hs">fiddling here</a></p>

<p>At this point, depending on what you‚Äôve seen before, you‚Äôre either thinking ‚ÄúYeah, sure. That‚Äôs a thing.‚Äù or you‚Äôre thinking ‚ÄúHow and why the hell would you do such a ridiculous thing.‚Äù</p>

<p>Most of this post will be about how, so let‚Äôs address why first:</p>

<ol>
  <li>Examining relations in this style illuminates some constructions that appear around the Haskell ecosystem, particularly some peculiar fellows in the <a href="http://hackage.haskell.org/package/profunctors-5.4">profunctor package</a>.</li>
  <li>More syntactic approach to relations allows discussion of larger/infinite domains. The finite enumerations of the previous post is nice for simplicity, but it seems you can‚Äôt get far that way.</li>
  <li>Mostly because we can - It‚Äôs a fun game. Maybe a useful one? TBD.</li>
</ol>

<p>With that out of the way, let‚Äôs go on to how.</p>

<h3 id="translating-functions-to-relation-gadts">Translating Functions to Relation GADTs</h3>

<p>We will be using some Haskell extensions in this post, at the very least GADTs and DataKinds. For an introduction to GADTs and DataKinds, check out this <a href="https://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html">blog post</a>. DataKinds is an extension that reflects every data constructor of data types to a type constructor.  Because there are values <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code> there are corresponding types created<code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code>. GADTs is an extension of the type definition mechanism of standard Haskell. They allow you to declare refined types for the constructors of your data and they infer those refined type when you pattern match out of the data as well, such that the whole process is kind of information preserving.</p>

<p>We will use the GADT extension to define relational datatypes with the kind</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;a -&gt; b -&gt; *&lt;/code&gt;
</code></pre></div></div>

<p>. That way it has a slot <code class="language-plaintext highlighter-rouge">a</code> for the ‚Äúinput‚Äù and <code class="language-plaintext highlighter-rouge">b</code> for the ‚Äúoutput‚Äù of the relation.  What will goes in these type slots will be DataKind lifted types like <code class="language-plaintext highlighter-rouge">'True</code>, not ordinary Haskell types like <code class="language-plaintext highlighter-rouge">Int</code>. This is a divergence from from the uses of similar kinds you see in Category, Profunctor, or Arrow. We‚Äôre doing a more typelevel flavored thing than you‚Äôll see in those libraries. What we‚Äôre doing is clearly a close brother of the <a href="http://hackage.haskell.org/package/singletons">singleton</a> approach to dependently typed programming in Haskell.</p>

<p>Some examples are in order for what I mean. Here are two simple boolean functions, <code class="language-plaintext highlighter-rouge">not</code> and <code class="language-plaintext highlighter-rouge">and</code> defined in ordinary Haskell functions, and their equivalent GADT relation data type.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;not True = False
not False = True

data Not a b where
    NotTF :: Not 'True 'False
    NotFT :: Not 'False 'True

and True True = True
and False _ = False
and _ False = False

data And a b where
    AndTT :: And '( 'True, 'True) 'True
    AndFU :: And '( 'False, a) 'False
    AndUF :: And '( a, 'False) 'False&lt;/code&gt;
</code></pre></div></div>

<p>You can already start to see how mechanical the correspondence between the ordinary function definition and our new fancy relation type. A function is often defined via cases. Each case corresponds to a new constructor of the relation and each pattern that occurs in that case is the pattern that appears in the GADT. Multiple arguments to the relations are encoded by uncurrying everything by default.</p>

<p>Any function calls that occur on the right hand side of a function definition becomes fields in the constructor of our relation. This includes recursive calls and external function calls. Here are some examples with a Peano style natural number data type.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;data Nat = S Nat | Z

plus Z x = x
plus (S x) y = S (plus x y)

data Plus a b where
    PZ :: Plus '( 'Z, a) a
    PS :: Plus '( a,b) c -&gt; Plus '( 'S a, b) c 
&lt;/code&gt;
</code></pre></div></div>

<p>We can also define things that aren‚Äôt functions. Relations are a larger class of things than functions are, which is part of their utility. Here is a ‚Äúless than equal‚Äù  relation <code class="language-plaintext highlighter-rouge">LTE</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;data LTE a b where
    LTERefl :: LTE n n
    LTESucc :: LTE n m -&gt; LTE n ('S m)&lt;/code&gt;
</code></pre></div></div>

<p>You can show that elements are in a particular relation by finding a value of that relational type. Is <code class="language-plaintext highlighter-rouge">([4,7], 11)</code> in the relation <code class="language-plaintext highlighter-rouge">Plus</code>? Yes, and I can show it with with the value <code class="language-plaintext highlighter-rouge">PS (PS (PS (PS PZ))) :: Plus (4,7) 11</code> .  This is very much the Curry-Howard correspondence. The type <code class="language-plaintext highlighter-rouge">R a b</code> corresponds to the proposition/question is $latex (a,b) \in R$ .</p>

<h3 id="the-fun-stuff--relational-combinators">The Fun Stuff : Relational Combinators</h3>

<p>While you need to build some primitive relations using new data type definitions, others can be built using relational combinators.   If you avoid defining too many primitive relations like the above and build them out of combinators, you expose a rich high level manipulation algebra. Otherwise you are stuck in the pattern matching dreck. We are traveling down the same road we did in the <a href="http://www.philipzucker.com/a-short-skinny-on-relations-towards-the-algebra-of-programming/">previous post</a>, so look there for less confusing explanations of the relational underpinnings of these constructions, or better yet some of the references below.</p>

<p>Higher order relational operators take in a type parameters of kind</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;a -&gt; b -&gt; *&lt;/code&gt;
</code></pre></div></div>

<p>and produce new types of a similar kind. The types appearing in these combinators is the AST of our relational algebra language.</p>

<p>The first two combinators of interest is the composition operator and the identity relation.  An element $latex (a,c) $ is in $latex R \cdot Q $ if there exists a $latex b$ such that $latex (a,b) \in R$ and $latex (b,c) \in Q$. The fairly direct translation of this into a type is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;{- rcompose :: Rel b c -&gt; Rel a b -&gt; Rel a c  -}

data RCompose k1 k2 a c where
   RCompose :: k1 b c -&gt; k2 a b -&gt; RCompose k1 k2 a c

type k &lt;&lt;&lt; k' = RCompose k k' 
type k &gt;&gt;&gt; k' = RCompose k' k&lt;/code&gt;
</code></pre></div></div>

<p>The type of the composition is the same as that of <a href="https://hackage.haskell.org/package/profunctors-5.2.1/docs/Data-Profunctor-Composition.html">Profunctor composition</a> found in the profunctors package.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;type RCompose = Procompose&lt;/code&gt;
</code></pre></div></div>

<p>Alongside a composition operator, it is a knee jerk to look for an identity relation and we do have one</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;data Id a b where
   Refl :: Id a a


-- monomorphic identity. Leave this out?
data IdBool a b where
  ReflTrue :: IdBool 'True 'True
  ReflFalse :: IdBool 'False 'False&lt;/code&gt;
</code></pre></div></div>

<p>This is also a familiar friend. The identity relation in this language is the <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html">Equality type.</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;-- identity function is the same as Equality
type Id a b = Id (a :~: b)&lt;/code&gt;
</code></pre></div></div>

<p>We can build an algebra for handling product and sum types by defining the appropriate relational combinators. These are very similar to the combinators in the Control.Arrow package.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;-- Product types

data Fan k k' a b where
    Fan :: k a b -&gt; k' a c -&gt; Fan k k' a '(b,c)

type k &amp;&amp;&amp; k' = Fan k k'

data Fst a b where
    Prj1 :: Fst '(a, b) a

data Snd a b where
    Prj2 :: Snd '(a, b) b

-- Sum type

data Split k k' a b where
    CaseLeft :: k a c -&gt; Split k k' ('Left a) c
    CaseRight :: k' b c -&gt; Split k k' ('Right b) c

type k ||| k' = Split k k'

data Inj1 a b where
    Inj1 :: Inj1 a ('Left a)
data Inj2 a b where
    Inj2 :: Inj2 a ('Right a)

-- some derived combinators
type Par f g = Fan (f &lt;&lt;&lt; Fst) (g &lt;&lt;&lt; Snd)
type Dup  = Fan Id Id
type Swap = Fan Snd Fst
&lt;/code&gt;
</code></pre></div></div>

<p>The converse of relations is very interesting operation and is the point where relations really differ from functions. Inverting a function is tough. Conversing a relation always works. This data type has no analog in profunctor to my knowledge and probably shouldn‚Äôt.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;data RConverse k a b where
    RConverse :: k a b -&gt; RConverse k b a
-- Shorter synonym
type RCon = RConverse&lt;/code&gt;
</code></pre></div></div>

<p>Relations do not have a notion of currying. The closest thing they have is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;data Trans k a b where
    Trans :: k '(a,b) c -&gt; Trans k a '(b,c)&lt;/code&gt;
</code></pre></div></div>

<h3 id="lattice-operators">Lattice Operators</h3>

<p>For my purposes, lattices are descriptions of sets that trade away descriptive power for efficiency. So most operations you‚Äôd perform on sets have an analog in the lattice structure, but it isn‚Äôt a perfect matching and you‚Äôre forced into approximation. It is nice to have the way you perform these approximation be principled, so that you can know at the end of your analysis whether you‚Äôve actually really shown anything or not about the actual sets in question.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/09/lattice-1024x769.jpg" alt="" />? No. No‚Ä¶ Yes? Oh. OH! IT IS!</p>

<p>The top relation holds all values. This is represented by making no conditions on the type parameters. They are completely phantom.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;newtype Top a b = Top ()&lt;/code&gt;
</code></pre></div></div>

<p>Bottom is a relation with no inhabitants.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;newtype Bottom a b = Bottom Void&lt;/code&gt;
</code></pre></div></div>

<p>The meet is basically the intersection of the relations, the join is basically the union.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;newtype RMeet k k' a b = RMeet (k a b, k' a b)
type k /\ k' = RMeet k k'  

newtype RJoin k k' a b = RJoin (Either (k a b) (k' a b))
type k \/ k' = RJoin k k' &lt;/code&gt;
</code></pre></div></div>

<p>A Lattice has an order on it. This order is given by relational inclusion. This is the same as the  :-&gt; combinator can be found in the <a href="http://hackage.haskell.org/package/profunctors-5.4/docs/Data-Profunctor.html#t::-45--62-">profunctors package</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;type (:-&gt;) p q = forall a b. p a b -&gt; q a b
type RSub p q = p :-&gt; q&lt;/code&gt;
</code></pre></div></div>

<p>Relational equality can be written as back and forth inclusion, a natural isomorphism between the relations. There is also an interesting indirect form.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;data REq k k' = REq {to' :: k :-&gt; k', from' :: k' :-&gt; k }&lt;/code&gt;
</code></pre></div></div>

<h4 id="relational-division">Relational Division</h4>

<p>If we consider the equation <code class="language-plaintext highlighter-rouge">(r &lt;&lt;&lt; p) :-&gt; q</code> with <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">q</code> given, in what sense is there a solution for <code class="language-plaintext highlighter-rouge">r</code>? By analogy, this looks rather like <code class="language-plaintext highlighter-rouge">r*p = q</code>, so we‚Äôre asking a kind of division question.  Well, unfortunately, this equation may not necessarily have a solution (neither do linear algebraic equations for that matter), but we can ask for the best under approximation instead. This is the operation of relational division. It also appears in the profunctor package as the <a href="http://hackage.haskell.org/package/profunctors-5.4/docs/Data-Profunctor-Ran.html">right Kan Extension</a>. You‚Äôll also find the universal property of the right division under the name <code class="language-plaintext highlighter-rouge">curryRan</code> and <code class="language-plaintext highlighter-rouge">uncurryRan</code> in that module.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;newtype Ran p q a b = Ran { runRan :: forall x. p x a -&gt; q x b }
type RDiv = Ran&lt;/code&gt;
</code></pre></div></div>

<p>One formulation of Galois connections can be found in the <a href="http://hackage.haskell.org/package/profunctors-5.4/docs/Data-Profunctor-Adjunction.html">adjunctions </a> file. <a href="https://www.sciencedirect.com/science/article/pii/S1567832612000525">Galois Connections are very slick</a>, but I‚Äôm running out of steam, so let‚Äôs leave that one for another day.</p>

<h3 id="properties-and-proofs">Properties and Proofs</h3>

<p>We can prove many properties about these relational operations. Here a a random smattering that we showed using quickcheck last time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;prop_ridleft ::  (k &lt;&lt;&lt; Id) :-&gt; k
prop_ridleft (RCompose k IdRefl) = k

prop_ridright ::  (Id &lt;&lt;&lt; k) :-&gt; k
prop_ridright (RCompose IdRefl k) = k

prop_meet :: p /\ q :-&gt; p
prop_meet (RMeet (p, q)) = p

prop_join :: p :-&gt; p \/ q
prop_join p = RJoin (Left p)

meet_assoc :: RMeet k (RMeet k' k'') a b -&gt; RMeet (RMeet k k') k'' a b
meet_assoc (RMeet (k, (RMeet (k',k'')))) = RMeet (RMeet (k,k'), k'')

prop_top :: k :-&gt; Top
prop_top _ = top

prop_bottom :: Bottom :-&gt; k
prop_bottom (Bottom x) = absurd x

bottom_compose :: REq (k &lt;&lt;&lt; Bottom) Bottom
bottom_compose = REq (\(RCompose k (Bottom b)) -&gt; absurd b) prop_bottom

data Iso a b = Iso {to :: a -&gt; b, from :: b -&gt; a}
type a &lt;-&gt; b = Iso a b

meet_universal :: (p ::-&gt; RMeet k k') &lt;-&gt; (p ::-&gt; k, p ::-&gt; k')
meet_universal = Iso to from where
    to (RSub f) = (RSub $ \p -&gt; case f p of RMeet (k,k') -&gt; k  , RSub $ \p -&gt; case f p of RMeet (k,k') -&gt; k')
    from (RSub f,RSub g) = RSub $ \p -&gt; RMeet (f p, g p) 

prop_con :: RCon (RCon k) :-&gt; k
prop_con (RConverse (RConverse k)) = k&lt;/code&gt;
</code></pre></div></div>

<h3 id="odds-and-ends">Odds and Ends</h3>

<ul>
  <li>
    <p>Recursion Schemes - Recursion schemes are a methodology to talk about recursion in a point free style and where the rubber meets the road in the algebra of programming. <a href="https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/">Here</a> is an excellent series of articles about them. Here is a sample of how I think they go:</p>

    <p><code>data MapMaybe k a b where
    MapJust :: k a b -&gt; MapMaybe k ('Just a) ('Just b)
    MapNothing :: MapMaybe k 'Nothing 'Nothing</code></p>

    <p>data Cata map k a b where
    Cata :: k fa a -&gt; map (Cata map k) x fa  -&gt; Cata map k (‚ÄòFix x) &lt;/code&gt;</p>
  </li>
  <li>Higher Order Relations?</li>
  <li>Examples of use. Check out the<a href="https://github.com/scmu/aopa/tree/master/Examples"> examples folder in the AoP Agda repo</a>. These are probably translatable into Haskell.</li>
  <li>
    <p>Interfacing with Singletons. Singletonized functions are a specialized case or relations. Something like?</p>

    <p><code>newtype SFun a b = SFun (Sing a -&gt; Sing b)</code></p>
  </li>
  <li>A comment to help avoid confusion. What we‚Äôve done here feels confusingly similar to profunctor, but it is in fact distinct I think. <a href="https://bartoszmilewski.com/2016/07/25/profunctors-as-relations/">Profunctors are described as a categorical generalization of relations</a> <a href="https://bartoszmilewski.com/2016/07/25/profunctors-as-relations/">,</a> but to be honest, I kind of don‚Äôt get it. Despite many of our constructions appearing in the profunctor package, the profunctor typeclass itself appears to not play a role in our formulation. There just isn‚Äôt a good way to dimap under our relations as written, unless you construct free profunctors. Converse at the least is a wrench in the works.</li>
  <li>
    <p>Star and graphs. Transition relations are a powerful methodology. A transition relation is in some respects the analog of a square matrix. We can iteratively compose it with itself.</p>

    <p><code>-- Check out "term rewriting and all that"
-- This is also the reflection without remorse data type
-- TSequence http://okmij.org/ftp/Haskell/zseq.pdf
-- this is also a free instance of Category
data Star k a b where
    Done :: Star k a a
    Roll :: k b c -&gt; Star k a b -&gt; Star k a c</code></p>

    <p>data KPlus k a b where
    PDone :: k a b -&gt; KPlus k a b
    PRoll :: k b c -&gt; KPlus k a b -&gt; KPlus k a c</p>

    <p>type SymClos k a b = RJoin k (RCon k) a b
type RefClos k a b = RJoin k Id a b
{- n-fold composition -}
‚Äì similar to Fin.
‚Äì This is also the Vec n is to list and this is to reflection without remorse. Kind of interesting
data NFold n k a b where
    One :: k a b -&gt; NFold (‚ÄòS n) k a b
    More :: k b c -&gt; NFold n k a b -&gt; NFold (‚ÄòS n) k a b&lt;/code&gt;</p>
  </li>
</ul>

<h3 id="references">References</h3>

<ul>
  <li>Program Design by Calculation - JN Oliveira</li>
  <li>Bird and de Moor</li>
  <li>Term Rewriting and all that</li>
  <li>Software Abstractions</li>
  <li><a href="https://softwarefoundations.cis.upenn.edu/lf-current/Rel.html">https://softwarefoundations.cis.upenn.edu/lf-current/Rel.html</a></li>
  <li><a href="https://softwarefoundations.cis.upenn.edu/lf-current/Imp.html#lab335">https://softwarefoundations.cis.upenn.edu/lf-current/Imp.html#lab335</a></li>
  <li><a href="https://github.com/scmu/aopa">https://github.com/scmu/aopa</a></li>
</ul>

:ET