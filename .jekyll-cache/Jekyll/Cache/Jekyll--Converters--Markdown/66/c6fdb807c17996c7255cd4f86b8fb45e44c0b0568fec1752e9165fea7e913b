I"ªN<p>As I have gotten more into the concerns of formal methods, I‚Äôve become unsure that ODEs actually exist. These are concerns that did not bother me much when I defined myself as being more in the physics game. How times change. Here‚Äôs a rough cut.</p>

<p>A difficulty with ODE error analysis is that it is very confusing how to get the error on something you are having difficulty approximating in the first place.</p>

<p>If I wanted to know the error of using a finite step size dt vs a size dt/10, great. Just compute both and compare. However, no amount of this seems to bootstrap you down to the continuum. And so I thought, you‚Äôre screwed in regards to using numerics in order to get true hard facts about the true solution. You have to go to paper and pencil considerations of equations and variables and epsilons and deltas and things. It is now clearer to me that this is not true. There is a field of verified/validated numerics.</p>

<p>A key piece of this seems to be interval arithmetic. <a href="https://en.wikipedia.org/wiki/Interval_arithmetic">https://en.wikipedia.org/wiki/Interval_arithmetic</a> An interval can be concretely represented by its left and right point. If you use rational numbers, you can represent the interval precisely. Interval arithmetic over approximates operations on intervals in such a way as to keep things easily computable. One way it does this is by ignoring dependencies between different terms. Check out Moore et al‚Äôs book for more.</p>

<p>What switching over to intervals does is you think about sets as the things you‚Äôre operating on rather than points. For ODEs (and other things), this shift of perspective is to no longer consider individual functions, but instead sets of functions. And not arbitrary extremely complicated sets, only those which are concretely manipulable and storable on a computer like intervals. Taylor models are a particular choice of function sets. You are manipulating an interval tube around a finite polynomial. If during integration / multiplication you get higher powers, truncate the polynomials by dumping the excess into the interval term. This keeps the complexity under wraps and closes the loop of the descriptive system.</p>

<p>If we have an iterative, contractive process for getting better and better solutions of a problem (like a newton method or some iterative linear algebra method), we can get definite bounds on the solution if we can demonstrate that a set maps into itself under this operation. If this is the case and we know there is a unique solution, then it must be in this set.</p>

<p>It is wise if at all possible to convert an ODE into integral form. $latex \dot{x}= f(x,t)$ is the same as $latex x(t) = x_0 + \int f(x,t)dt$.</p>

<p>For ODEs, the common example of such an operation is known as Picard iteration. In physical terms, this is something like the impulse approximation / born approximation. One assumes that the ODE evolves according to a known trajectory $latex x_0(t)$ as a first approximation. Then one plugs in the trajectory to the equations of motion $latex f(x_0,t)$ to determine the ‚Äúforce‚Äù it would feel and integrate up all this force. This creates a better approximation $latex x_1(t)$ (probably) which you can plug back in to create an even better approximation.</p>

<p>If we instead do this iteration on an intervally function set / taylor model thing, and can show that the set maps into itself, we know the true solution lies in this interval. The term to search for is Taylor Models (also some links below).</p>

<p>I was tinkering with whether sum of squares optimization might tie in to this. I have not seen SOS used in this context, but it probably has or is worthless.</p>

<p>An aspect of sum of squares optimization that I thought was very cool is that it gives you a simple numerical certificate that confirms that at the infinitude of points for which you could evaluate a polynomial, it comes out positive. This is pretty cool. <a href="http://www.philipzucker.com/deriving-the-chebyshev-polynomials-using-sum-of-squares-optimization-with-sympy-and-cvxpy/">http://www.philipzucker.com/deriving-the-chebyshev-polynomials-using-sum-of-squares-optimization-with-sympy-and-cvxpy/</a></p>

<p>But that isn‚Äôt really what makes Sum of squares special. There are other methods by which to do this.</p>

<p>There are very related methods called DSOS and SDSOS <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a> which are approximations of the SOS method. They replace the SDP constraint at the core with a more restrictive constraint that can be expressed with LP and socp respectively. These methods lose some of the universality of the SOS method and became basis dependent on your choice of polynomials. DSOS in fact is based around the concept of a diagonally dominant matrix, which means that you should know roughly what basis your certificate should be in.</p>

<p>This made me realize there is an even more elementary version of DSOS that perhaps should have been obvious to me from the outset. Suppose we have a set of functions we already know are positive everywhere on a domain of interest.  A useful example is the raised chebyshev polynomials. <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">https://en.wikipedia.org/wiki/Chebyshev_polynomials</a> The appropriate chebyshev polynomials oscillate between [-1,1] on the interval [-1,1], so if you add 1 to them they are positive over the whole interval [-1,1]. Then nonnegative linear sums of them are also positive. Bing bang boom. And that compiles down into a simple linear program (inequality constraints on the coefficients) with significantly less variables than DSOS. What we are doing is restricting ourselves to completely positive diagonal matrices again, which are of course positive semidefinite. It is less flexible, but it also has more obvious knobs to throw in domain specific knowledge. You can use a significantly over complete basis and finding this basis is where you can insert your prior knowledge.</p>

<p>It is not at all clear there is any benefit over interval based methods.</p>

<p>Here is a sketch I wrote for $latex x‚Äô=x$ which has solution $latex e^t$. I used raised chebyshev polynomials to enforce positive polynomial constraints and tossed in a little taylor model / interval arithmetic to truncate off the highest terms.</p>

<p>I‚Äôm using my helper functions for translating between sympy and cvxpy expressions.  <a href="https://github.com/philzook58/cvxpy-helpers">https://github.com/philzook58/cvxpy-helpers</a> Sympy is great for collecting up the coefficients on terms and polynomial multiplication integration differentiation etc. I do it by basically creating sympy matrix variables corresponding to cvxpy variables which I compile to cvxpy expressions using lambdify with an explicit variable dictionary.</p>

<p>[gist https://gist.github.com/philzook58/f0068c4084cb307f9cdfd267b1e7411e]</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2020/01/euler-1024x768.png" alt="" /></p>

<p>Seems to work, but I‚Äôve been burned before.</p>

<p>man, LP solvers are so much better than SDP solvers</p>

<hr />

<p>Random junk and links: Should I be more ashamed of dumps like this? I don‚Äôt expect you to read this.</p>

<p><a href="https://github.com/JuliaIntervals/TaylorModels.jl">https://github.com/JuliaIntervals/TaylorModels.jl</a></p>

<p><a href="https://github.com/JuliaIntervals">https://github.com/JuliaIntervals</a></p>

<p>Functional analysis by and large analyzes functions by analogy with more familiar properties of finite dimensional vector spaces. In ordinary 2d space, it is convenient to work with rectangular regions or polytopic regions.</p>

<p>Suppose I had a damped oscillator converging to some unknown point. If we can show that every point in a set maps within the set, we can show that the function</p>

<p>One model of a program is that it is some kind of kooky complicated hyper nonlinear discrete time dynamical  system. And vice versa, dynamical systems are continuous time programs. The techniques for analyzing either have analogs in the  other domain. Invariants of programs are essential for determining correctness properties of loops. Invariants like energy and momentum are essential for determining what physical systems can and cannot do. Lyapunov functions demonstrate that control systems are converging to the set point. Terminating metrics are showing that loops and recursion must eventually end.</p>

<p>If instead you use interval arithmetic for a bound on your solution rather than your best current solution, and if you can show the interval maps inside itself, then you know that the iterative process must converge inside of the interval, hence that is where the true solution lies.</p>

<p>A very simple bound for an integral $latex \int_a^b f(x)dx$ is $latex \int max_{x \in [a,b]}f(x)  dx= max_{x \in [a,b]}f(x) \int dx = max_{x \in [a,b]}f(x) (b - a)$</p>

<p>The integral is a very nice operator. The result of the integral is a positive linear sum of the values of a function. This means it plays nice with inequalities.</p>

<p>Rigorously Bounding ODE solutions with Sum of Squares optimization  - Intervals</p>

<p>Intervals - Moore book. Computational functional analaysis. Tucker book. Coqintervals. fixed point theorem. Hardware acceleration? Interval valued functions. Interval extensions.</p>

<ul>
  <li>Banach fixed point - contraction mapping</li>
  <li>Brouwer fixed point</li>
  <li>Schauder</li>
  <li>Knaster Tarski</li>
  <li></li>
</ul>

<p>Picard iteration vs? Allowing flex on boundary conditions via an interval?</p>

<p>Interval book had an interesting integral form for the 2-D</p>

<p>sympy has cool stuff</p>

<p>google scholar search z3, sympy brings up interesting things</p>

<p><a href="https://moorepants.github.io/eme171/resources.html">https://moorepants.github.io/eme171/resources.html</a></p>

<p>The pydy guy Moore has a lot of good shit. resonance <a href="https://www.moorepants.info/blog/introducing-resonance.html">https://www.moorepants.info/blog/introducing-resonance.html</a></p>

<p>Lyapunov functions. Piecewise affine lyapunov funcions. Are lyapunov functions kind of like a PDE? Value functions are pdes. If the system is piecewise affine we can define a grid on the same piecewise affine thingo. Compositional convexity. Could we use compositional convexity + Relu style piecewise affinity to get complicated lyapunov functions. Lyapunov functions don‚Äôt have to be continiuous, they just have to be decreasing. The Lie derivative wrt the flow is always negative, i.e gradeint of function points roughly in direction of flow. trangulate around equilibrium if you want to avoid quadratic lyapunov. For guarded system, can relax lyapunov constrain outside of guard if you tighten inside guard. Ax&gt;= 0 is guard. Its S-procedure.</p>

<p>Best piecewise approximation with point choice?</p>

<p><a href="http://theory.stanford.edu/~arbrad/papers/lr.ps">http://theory.stanford.edu/~arbrad/papers/lr.ps</a> linear ranking functions</p>

<p>Connection to petri nets?</p>

<p><a href="https://ths.rwth-aachen.de/wp-content/uploads/sites/4/hs_lecture_notes.pdf">https://ths.rwth-aachen.de/wp-content/uploads/sites/4/hs_lecture_notes.pdf</a></p>

<p><a href="https://www.cs.colorado.edu/~xich8622/papers/rtss12.pdf">https://www.cs.colorado.edu/~xich8622/papers/rtss12.pdf</a></p>

<p>KoAt, LoAT. AProve. Integer transition systems. Termination analysis. Loops?</p>

<p><a href="https://lfcps.org/pub/Pegasus.pdf">https://lfcps.org/pub/Pegasus.pdf</a> darboux polynomials. barreir certificates. prelle-singer method. first integrals.</p>

<table>
  <tbody>
    <tr>
      <td>method 1. arbitrary polynomial p(t). calculate p‚Äô(t). find coefficents that make p‚Äô(t) = 0 by linear algebra. Idea: near invaraints? min max</td>
      <td>p‚Äô(t)</td>
    </tr>
  </tbody>
</table>

<p>Lie Algebra method</p>

<p><a href="https://www.researchgate.net/publication/233653257_Solving_Differential_Equations_by_Symmetry_Groups">https://www.researchgate.net/publication/233653257_Solving_Differential_Equations_by_Symmetry_Groups</a> sympy links this paper. Sympy has some lie algebra stuff in there</p>

<p><a href="https://www-users.math.umn.edu/~olver/sm.html">https://www-users.math.umn.edu/~olver/sm.html</a> Peter Olver tutorial</p>

<p><a href="http://www-users.math.umn.edu/~olver/talk.html">http://www-users.math.umn.edu/~olver/talk.html</a> olver talks</p>

<p><a href="https://www-sop.inria.fr/members/Evelyne.Hubert/publications/PDF/Hubert_HDR.pdf">https://www-sop.inria.fr/members/Evelyne.Hubert/publications/PDF/Hubert_HDR.pdf</a></p>

<p><a href="https://www.cs.cmu.edu/~aplatzer/logic/diffinv.html">https://www.cs.cmu.edu/~aplatzer/logic/diffinv.html</a> andre platzer. Zach says Darboux polynomials?</p>

<p><a href="https://sylph.io/blog/math.html">https://sylph.io/blog/math.html</a></p>

<p>Books: Birhoff and Rota, Guggenheimer, different Olver books, prwctical guide to invaraints <a href="https://www.amazon.com/Practical-Invariant-Monographs-Computational-Mathematics/dp/0521857015">https://www.amazon.com/Practical-Invariant-Monographs-Computational-Mathematics/dp/0521857015</a></p>

<p>Idea: Approximate invariants? At least this ought to make a good coordinate system to work in where the dynamics are slow. Like action-angle and adiabatic transformations. Could also perhaps bound the</p>

<p>Picard Iteration</p>

<p>I have a method that I‚Äôm not sure is ultimately sound. The idea is to start with</p>

<p>Error analysis most often uses an appeal to Taylor‚Äôs theorem and Taylor‚Äôs theorem is usually derived from them mean value theorem or intermediate value theorem. Maybe that‚Äôs fine. But the mean value theorem is some heavy stuff. There are computational doo dads that use these bounds + interval analysis to rigorously integrate ODEs. See <a href="https://github.com/JuliaIntervals/TaylorModels.jl">https://github.com/JuliaIntervals/TaylorModels.jl</a></p>

<p>The beauty of sum of squares certificates is that they are very primitive proofs of positivity for a function on a domain of infinitely many values. If I give you a way to write an expression as a sum of square terms, it is then quite obvious that it has to be always positive. This is algebra rather than analysis.</p>

<p>$latex y(t) = \lambda(t) \and \lambda(t) is SOS \Rightarrow \forall t. y(t) &gt;= 0$. Sum of squares is a kind of a quantifier elimination method. The reverse direction of the above implication is the subject of the positivstullensatz, a theorem of real algebraic geometry. At the very least, we can use the SOS constraint as a relaxation of the quantified constraint.</p>

<p>So, I think by using sum of squares, we can turn a differential equation into a differential inequation. If we force the highest derivative to be larger than the required differential equation, we will get an overestimate of the required function.</p>

<p>A function that is dominated by another in derivative, will be dominated in value also.  You can integrate over inequalities (I think. You have to be careful about such things. ) $latex \forall t. \frac{dx}{dt} &gt;= \frac{dx}{dt} \Rightarrow $ x(t) - x(0) &gt;=  y(t) - y(0) $</p>

<p>The derivative of a polynomial can be thought of as a completely formal operation, with no necessarily implied calculus meaning. It seems we can play a funny kind of shell game to avoid the bulk of calculus.</p>

<p>As an example, let‚Äôs take $latex \frac{dx}{dt}=y$  $latex y(0) = 1$ with the solution $latex y = e^t$. $latex e$ is a transcendental</p>

<p>The S-procedure is trick by which you can relax a sum of squares inequality to only need to be enforced in a domain. If you build a polynomials function that describes the domain, it that it is positive inside the domain and negative outside the domain, you can add a positive multiple of that to your SOS inequalities. Inside the domain you care about, you‚Äôve only made them harder to satisfy, not easier. But outside the domain you have made it easier because you can have negative slack.</p>

<p>For the domain $latex t \in [0,1]$  the polynomial $latex (1 - t)t$ works as our domain polynomial.</p>

<p>We parametrize our solution as an explicit polynomial $latex x(t) = a_0 + a_1 t + a_2 t^2 + ‚Ä¶$. It is important to note that what follows is always linear in the $latex a_i$.</p>

<p>$latex \frac{dx}{dt} - x &gt;= 0$ can be relaxed to $latex \frac{dx}{dt} - x(t) + \lambda(t)(1-t)t &gt;= 0$ with $latex \lambda(t) is SOS$.</p>

<p>So with that we get a reasonable formulation of finding a polynomial upper bound solution of the differential equation</p>

<p>$latex \min x(1) $</p>

<p>$latex \frac{dx}{dt} - x(t) + \lambda_1(t)(1-t)t =  \lambda_2(t)$</p>

<p>$latex \lambda_{1,2}(t) is SOS$.</p>

<p>And here it is written out in python using my cvxpy-helpers which bridge the gap between sympy polynomials and cvxpy.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;&lt;/code&gt;
</code></pre></div></div>

<p>We can go backwards to figure out sufficient conditions for a bound. We want $latex x_u(t_f) \gte x(t_f)$. It is sufficient that $latex \forall t. x_u(t) \gte x(t)$. For this it is sufficient that  $latex \forall t. x_u‚Äô(t)  &gt;= x‚Äô(t) \and x_u(t_i) &gt;= x(t_i) $. We follow this down in derivative until we get the lowest derivative in the differential equation. Then we can use the linear differential equation itself $latex x^{(n)}(t) = \sum_i a_i(t) x^{(i)}(t)$. $latex x_u^{(n)}(t) &gt;= \sum max(a_i x^{(i)}_u, x^{(i)}_l)$.</p>

<p>$latex a(t) * x(t) &gt;= \max a(t) x_u(t), a(t) x_l(t)$. This accounts for the possibility of terms changing signs. Or you could separate the terms into regions of constant sign.</p>

<p>The minimization characterization of the bound is useful. For any class of functions that contains our degree-d polynomial, we can show that the minimum of the same optimization problem is less than or equal to our value.</p>

<p>Is the dual value useful? The lower bound on the least upper bound</p>

<p>Doesn‚Äôt seem like the method will work for nonlinear odes. Maybe it will if you relax the nonlinearity. Or you could use perhaps a MIDSP to make piecewise linear approximations of the nonlinearity?</p>

<p>It is interesting to investigtae linear programming models. It is simpler and more concrete to examine how well different step sizes approximate each other rather than worry about the differential case.</p>

<p>We can explicit compute a finite difference solution in the LP, which is a power that is difficult to achieve in general for differential equations.</p>

<p>We can instead remove the exact solution by a convservative bound.</p>

<p>While we can differentiate through an equality, we can‚Äôt differentiate through an inequality. Differentiation involves negation, which plays havoc with inequalities. We can however integrate through inequalities.</p>

<p>$latex \frac{dx}{dt} &gt;= f \and x(0) &gt;= a \Rightarrow $ x(t) &gt;=  \int^t_0 f(x) + a$</p>

<p>As a generalization we can integrate $latex \int p(x) $ over inequalities as long as $latex p(x) \gte 0$</p>

<p>In particular $latex \forall t. \frac{dx}{dt} &gt;= \frac{dx}{dt} \Rightarrow $ x(t) - x(0) &gt;=  y(t) - y(0) $</p>

<p>We can convert a differential equation into a differential inequation. It is not entirely clear to me that there is a canonical way to do this. But it works to take the biggest.</p>

<p>$latex \frac{dx}{dt} = A(t)x + f(t)$</p>

<p>Is there a tightest</p>

<p>We can integrate</p>

<p>Here let‚Äôs calculate e</p>

<p><a href="https://tel.archives-ouvertes.fr/tel-00657843v2/document">https://tel.archives-ouvertes.fr/tel-00657843v2/document</a> Thesis on ODE bounds in Isabelle</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code class="language-"&gt;myfunc x y = 3&lt;/code&gt;
</code></pre></div></div>

<p>not so good. very small</p>

:ET