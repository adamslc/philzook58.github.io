I"ó1<p>I got referred to an interesting paper by a <a href="https://www.reddit.com/r/haskell/comments/adgdyj/pointful_from_pointfree_has_this_been_done_before/edhupmi/">comment of /u/syrak</a>.</p>

<p><a href="http://www2.sf.ecei.tohoku.ac.jp/~kztk/papers/kztk_jfp_am_2018.pdf">http://www2.sf.ecei.tohoku.ac.jp/~kztk/papers/kztk_jfp_am_2018.pdf</a></p>

<p><em>Applicative bidirectional programming</em> (<a href="http://www2.sf.ecei.tohoku.ac.jp/~kztk/papers/kztk_jfp_am_2018.pdf">PDF</a>), by Kazutaka Matsuda and Meng Wang</p>

<p>In it, they use a couple interesting tricks to make Lens programming more palatable. Lens often need to be be programmed in a point free style, which is rough, but by using some combinators, they are able to program lenses in a pointful style (with some pain points still left over). It is a really interesting, well-written paper. Lots â€˜oâ€™ Yoneda and laws. Iâ€™m not doing it justice. Check it out!</p>

<p>A while back I noted that <a href="http://www.philipzucker.com/reverse-mode-differentiation-is-kind-of-like-a-lens-ii/">reverse mode auto-differentiation has a type very similar to a lens</a> and in fact you can build a working reverse mode automatic differentiation DSL out of lenses and lens-combinators. Many things about lenses, but not all, transfer over to automatic differentiation. The techniques of Matsuda and Wang do appear to transfer fairly well.</p>

<p>This is interesting to me for another reason. Their <code class="language-plaintext highlighter-rouge">lift2</code> and <code class="language-plaintext highlighter-rouge">unlift2</code> functions remind me very much of<a href="http://www.philipzucker.com/compiling-to-categories-3-a-bit-cuter/"> my recent approach to compiling to categories</a>. The <code class="language-plaintext highlighter-rouge">lift2</code> function is fanning a lens pair. This is basically what my FanOutput typeclass automated. <code class="language-plaintext highlighter-rouge">unlift2</code> is building the input for a function function by supplying a tuple of projection lenses. This is what my BuildInput typeclass did. I think their style may extend many monoidal cartesian categories, not just lenses.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;lift2 :: Lens (a,b) c -&gt; (forall s. Num s =&gt; (Lens s a, Lens s b) -&gt; Lens s c)
lift2 l (x,y) = lift l (fan x y)

unlift2 :: (Num a, Num b) =&gt; (forall s. Num s =&gt; (Lens s a, Lens s b) -&gt; Lens s c) -&gt; Lens (a,b) c
unlift2 f = f (fst', snd')&lt;/code&gt;
</code></pre></div></div>

<p>One can use the function <code class="language-plaintext highlighter-rouge">b -&gt; a</code> in many of the situations one can use <code class="language-plaintext highlighter-rouge">a</code> in. You can do elegant things by making a Num typeclass of <code class="language-plaintext highlighter-rouge">b -&gt; a</code> for example. This little fact seems to extend to other categories as well. By making a Num typeclass for <code class="language-plaintext highlighter-rouge">Lens s a</code> when <code class="language-plaintext highlighter-rouge">a</code> is a Num, we can use reasonable looking notation for arithmetic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;t1 :: Num a =&gt; Lens (a,a) a
t1 = unlift2 $ \(x,y) -&gt; x + y*y + y * 7&lt;/code&gt;
</code></pre></div></div>

<p>They spend some time discussing the necessity of a Poset typeclass. For actual lawful lenses, the <code class="language-plaintext highlighter-rouge">dup</code> implementation needs a way to recombine multiple adjustments to the same object. In the AD-lens case, dup takes care of this by adding together the differentials. This means that everywhere they needed an Eq typeclass, we can use a Num typeclass. There may be usefulness to building a wrapped type <code class="language-plaintext highlighter-rouge">data NZ a = Zero | NonZero a</code>  like their Tag type to accelerate the many 0 values that may be propagating through the system.</p>

<p>Unfortunately, as is, the performance of this is abysmal. Maybe there is a way to fix it? Unlifting and lifting destroys a lot of sharing and often necessitates adding many redundant zeros. Why are you doing reverse mode differentiation unless you care about performance? Forward mode is simpler to implement. In the intended use case of Matsuda and Wang, they are working with actual lawful lenses, which have far less computational content than AD-lenses. Good lawful lenses should just be shuffling stuff around a little. Maybe one can hope GHC is insanely intelligent and can optimize these zeros away. One point in favor of that is that our differentiation is completely pure (no mutation). Nevertheless, I suspect it will not without help. Being careful and unlifting and lifting manually may also help. In principle, I think the Lensy approach could be pretty fast (since all it is is just packing together exactly what you need to differentiate into a data type), but how to make it fast while still being easily programmable? It is also nice that it is pretty simple to implement. It is the simplest method that I know of if you needed to port operable reverse mode differentiation to a new library (Massiv?) or another functional language (Futhark?). And a smart compiler really does have a shot at finding optimizations/fusions.</p>

<p>While I was at it, unrelated to the paper above, I think I made a working generic auto differentiable fold lens combinator. Pretty cool. <code class="language-plaintext highlighter-rouge">mapAccumL</code> is a hot tip.</p>

<p>For practical Haskell purposes, all of this is a little silly with the good Haskell AD packages around, the most prominent being</p>

<p><a href="http://hackage.haskell.org/package/ad">http://hackage.haskell.org/package/ad</a></p>

<p>It is somewhat interesting to note the similarity of type <code class="language-plaintext highlighter-rouge">forall s. Lens s</code> appearing in the Matsuda and Wang approach to those those of the <code class="language-plaintext highlighter-rouge">forall s. BVar s</code> monad appearing in the backprop package. In this case I believe that the <code class="language-plaintext highlighter-rouge">s</code> type variable plays the same role it does in the ST monad, protecting a mutating Wengert tape state held in the monad, but I havenâ€™t dug much into it. I donâ€™t know enough about backprop to know what to make of this similarity.</p>

<p><a href="http://hackage.haskell.org/package/backprop">http://hackage.haskell.org/package/backprop</a></p>

<p>The github repo with my playing around and stream of consciousness commentary is <a href="https://github.com/philzook58/ad-lens/blob/master/src/Numeric/ADLens/AppBi.hs">here</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code class="language-haskell"&gt;{-# LANGUAGE NoImplicitPrelude, TypeSynonymInstances, RankNTypes #-}
module Numeric.ADLens.AppBi where
-- import Numeric.ADLens.Lens
import Control.Category
import Prelude hiding (id, (.))
import Control.Arrow ((***))
import Data.Functor.Const
import Data.Traversable
newtype Lens x y = Lens (x -&gt; (y, y -&gt; x)) 
type L s a = Num s =&gt; Lens s a

instance Category Lens where
  id = Lens (\x -&gt; (x, id))
  (Lens f) . (Lens g) = Lens $ \x -&gt; let (y, g') = g x in
                                           let (z, f') = f y in
                                           (z, g' . f') 



grad'' (Lens f) x = let (y,j) = (f x) in j 1

lift :: Lens a b -&gt; (forall s. Lens s a -&gt; Lens s b)
lift l l' = l . l'

unlift :: Num a =&gt; (forall s. Num s =&gt; Lens s a -&gt; Lens s b) -&gt; Lens a b
unlift f = f id


dup :: Num a =&gt; Lens a (a,a)
dup = Lens $ \x -&gt; ((x,x), \(dx,dy) -&gt; dx + dy)

par :: Lens a b -&gt; Lens c d -&gt; Lens (a,c) (b,d)
par (Lens f) (Lens g) = Lens l'' where
    l'' (a,c) = ((b,d), f' *** g') where
        (b,f') = f a
        (d,g') = g c

fan :: Num s =&gt; Lens s a -&gt; Lens s b -&gt; Lens s (a,b)
fan x y = (par x y) . dup 

-- impredicative polymorphism errror when we use L in type sig. I'm just going to avoid that.
lift2 :: Lens (a,b) c -&gt; (forall s. Num s =&gt; (Lens s a, Lens s b) -&gt; Lens s c)
lift2 l (x,y) = lift l (fan x y)

unlift2 :: (Num a, Num b) =&gt; (forall s. Num s =&gt; (Lens s a, Lens s b) -&gt; Lens s c) -&gt; Lens (a,b) c
unlift2 f = f (fst', snd')

instance (Num a, Num b) =&gt; Num (a,b) where
	(x,y) + (a,b) = (x + a, y + b)
	(x,y) * (a,b) = (x * a, y * b)
	abs (x,y) = abs (x,y)
	fromInteger x = (fromInteger x, fromInteger x)
	-- and so on

fst' :: Num b =&gt; Lens (a,b) a
fst' = Lens (\(a,b) -&gt; (a, \ds -&gt; (ds, 0)))

snd' :: Num a =&gt; Lens (a,b) b
snd' = Lens (\(a,b) -&gt; (b, \ds -&gt; (0, ds)))

unit :: Num s =&gt; Lens s () -- ? This isn't right.
unit = Lens (\s -&gt; ((), const 0))

add :: Num a =&gt; Lens (a,a) a 
add = Lens $ \(x,y) -&gt; (x + y, \ds -&gt; (ds, ds))

sub :: Num a =&gt; Lens (a,a) a 
sub = Lens $ \(x,y) -&gt; (x - y, \ds -&gt; (ds, -ds))

mul :: Num a =&gt; Lens (a,a) a 
mul = Lens $ \(x,y) -&gt; (x * y, \dz -&gt; (dz * y, x * dz))

recip' :: Fractional a =&gt; Lens a a 
recip' = Lens $ \x-&gt; (recip x, \ds -&gt; - ds / (x * x))

div :: Fractional a =&gt; Lens (a,a) a 
div = Lens $ (\(x,y) -&gt; (x / y, \d -&gt; (d/y,-x*d/(y * y))))

-- They called this "new" Section 3.2
constLens :: Num s =&gt; a -&gt; Lens s a
constLens x = Lens (const (x, const 0))

-- or rather we might define add = unlift2 (+)
instance (Num s, Num a) =&gt; Num (Lens s a) where
	x + y = (lift2 add) (x,y)
	x - y = (lift2 sub) (x,y)
	x * y = (lift2 mul) (x,y)
	abs = error "TODO"
	fromInteger x = constLens (fromInteger x)

t1 :: Num a =&gt; Lens (a,a) a
t1 = unlift2 $ \(x,y) -&gt; x + y*y + y * 7

-- See section on lifting list functions form biapplicative paper
-- These are could be Iso.
lcons :: Lens (a,[a]) [a]
lcons =  Lens $ \(a,as) -&gt; (a : as, \xs -&gt; (head xs, tail xs))
lnil :: Lens () [b]
lnil = Lens $ const ([], const ())

lsequence :: Num s =&gt; [Lens s a] -&gt; Lens s [a]
lsequence [] = lift lnil unit
lsequence (x : xs) = lift2 lcons (x, lsequence xs)

llift :: Num s =&gt; Lens [a] b -&gt; [Lens s a] -&gt; Lens s b
llift l xs = lift l (lsequence xs)


instance (Num a) =&gt; Num [a] where
	(+) = zipWith (+)
	(*) = zipWith (*)
	(-) = zipWith (-)
	abs = map abs
	fromInteger x = repeat (fromInteger x)

-- We need to hand f a list of the accessor lenses
-- [Lens [a] a]
-- This feels quite wrong. Indexing into a list is naughty.
-- But that is what they do. Shrug.
lunlift :: Num a =&gt; (forall s. Num s =&gt; [Lens s a] -&gt; Lens s b) -&gt; Lens [a] b
lunlift f = Lens $ \xs -&gt; 
					let n = length xs in
					let inds = [0 .. n-1] in
					let ls = map (lproj n) inds in
					let (Lens f') = f ls in
					f' xs

t2 :: Num a =&gt; Lens [a] a					
t2 = lunlift sum
t3 :: Num a =&gt; Lens [a] a					
t3 = lunlift product

lproj :: Num a =&gt; Int -&gt; Int -&gt; Lens [a] a
lproj n' ind = Lens $ \xs -&gt; ((xs !! ind), \x' -&gt; replace ind x' zeros) where
	replace 0 x (y:ys) = x : ys
	replace n x (y:ys) = y : (replace (n-1) x ys)
	zeros = replicate n' 0

	
lensmap :: Applicative f =&gt; Lens a b -&gt; Lens (f a) (f b)
lensmap (Lens f) = Lens $ \fa -&gt;
								let fbb = fmap f fa in
								let fb = fmap fst fbb in
								let fb2s = fmap snd fbb in
								(fb, \fb' -&gt; fb2s &lt;*&gt; fb')

-- Types work, but does this actually make sense?
lsequenceA :: (Applicative f, Applicative t, Traversable f, Traversable t) =&gt; Lens (t (f a)) (f (t a))
lsequenceA = Lens $ \tfa -&gt; (sequenceA tfa, sequenceA)

ltraverse :: (Applicative f, Applicative t, Traversable f, Traversable t) =&gt;
             Lens a (f b) -&gt; Lens (t a) (f (t b))
ltraverse f = lsequenceA . (lensmap f)

lensfoldl :: Traversable t =&gt; Lens (a, b) a -&gt; Lens (a, t b) a
lensfoldl (Lens f) = Lens $ \(s, t) -&gt; let (y, tape) = mapAccumL (curry f) s t  in
						  (y,  \db -&gt;  mapAccumR (\db' f -&gt; (f db')) db tape)
lensfoldr :: Traversable t =&gt; Lens (a, b) a -&gt; Lens (a, t b) a
lensfoldr (Lens f) = Lens $ \(s, t) -&gt; let (y, tape) = mapAccumR (curry f) s t  in
						(y,  \db -&gt;  mapAccumL (\db' f -&gt; (f db')) db tape)						  

t5 = grad'' (lensfoldl mul) (1, [1,1,2,3])


liftC :: Num a =&gt; (Lens a b -&gt; Lens c d) -&gt; (forall s. Num s =&gt; Lens s a -&gt; Lens s b) -&gt; (forall t. Num t =&gt; Lens t c -&gt; Lens t d)
liftC c f = lift (c (unlift f))

ungrad :: Lens (a,b) c -&gt; (a -&gt; Lens b c)
ungrad (Lens f) a = Lens (\b -&gt; let (c,j) = f (a,b) in (c, snd . j))&lt;/code&gt;
</code></pre></div></div>

:ET