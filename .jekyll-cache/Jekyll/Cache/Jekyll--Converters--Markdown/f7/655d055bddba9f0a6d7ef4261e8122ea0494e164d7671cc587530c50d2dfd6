I"1<p>As a simple extension of <a href="http://www.philipzucker.com/stupid-z3py-tricks-verifying-sorting-networks-off-of-wikipedia/">verifying the sorting networks from before</a>, we can synthesize optimally small sorting networks. The “program” of the sorting network is specified by a list of tuples of the elements we wish to compare and swap in order. We just generate all possible sequences of comparison operations and ask z3 to try verifying. If z3 says it verifies, we’re done.</p>

<p>Here are some definitions for running the thing</p>

<p>[gist https://gist.github.com/philzook58/1755ce5bbacd197e549a1e7ae407813f#file-prelude-py]</p>

<p>and here is a simple generating thing for all possible pairs.</p>

<p>[gist https://gist.github.com/philzook58/1755ce5bbacd197e549a1e7ae407813f#file-synthesize-py]</p>

<p>As is, this is astoundingly slow. Truly truly abysmally slow. The combinatorics of really naively search through this space is abysmal. I doubt you’re going to get more than a network of size 6 out of this as is.</p>

<p>Some possible optimizations: early pruning of bad networks with testing, avoiding ever looking at obviously bad networks. Maybe a randomized search might be faster if one doesn’t care about optimality. We could also ask z3 to produce networks.</p>

<p>For more on program synthesis, check out<a href="https://github.com/nadia-polikarpova"> </a>Nadia Polikarpova’s sick course here.</p>

<p><a href="https://github.com/nadia-polikarpova/cse291-program-synthesis">https://github.com/nadia-polikarpova/cse291-program-synthesis</a></p>

:ET