I"¥<p>Welp, you win some, you lose some.</p>

<p>As I had left <a href="https://www.philipzucker.com/notes-on-synthesis-and-equation-proving-for-catlab-jl/">off last time</a>, I had realized that my encoding of the equations of Catlab was unsound.</p>

<p>As an example, look at the following suggested axioms.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fof( axiom2, axiom, ![Varf, VarA, VarB]: constcompose(Varf, constid(VarB)) = Varf).
fof( axiom3, axiom, ![Varf, VarA, VarB]: constcompose(constid(VarA), Varf) = Varf).
</code></pre></div></div>

<p>It is a theorem from these axioms that <code class="language-plaintext highlighter-rouge">compose(id(A),id(B)) = id(A) = id(B)</code>, which should not be a theorem. Evan made the interesting point that this is the standard proof that shows the identity of a group is unique, so we‚Äôre reducing our magnificent category into a pitiful monoid. How sad. And inspecting the trace for some ‚Äúproofs‚Äù returned by eprover shows that the solver was actually using this fact. Oh well.</p>

<p>An approach that I feel more confident in being correct is using ‚Äútype guards‚Äù as preconditions for the equations. In the very useful paper <a href="https://people.mpi-inf.mpg.de/~jblanche/mono-trans.pdf">https://people.mpi-inf.mpg.de/~jblanche/mono-trans.pdf</a> this technique is described as well known folklore, albeit in a slightly different context. The type guard is an implication clause that holds the necessary typing predicates from the typing context required for the equation to even make sense. For example composition associativity look like <code class="language-plaintext highlighter-rouge">forall A B C D f g h, (type(f) = Hom A B /\ type(g) = Hom B C /\ type(h) = Hom C D /\ type(A) = Ob /\ type(B) = Ob /\ type(C) = Ob /\ type(C) = Ob) =&gt; compose(f (g, h)) = compose( compose(f,g),h)</code>.</p>

<p>Adding the guards seems to work, but slows the provers to a crawl for fairly trivial queries. My running example is <code class="language-plaintext highlighter-rouge">pair(proj1(A,B), proj2(A,B)) = otimes(id(A),id(B))</code>. In Catlab <code class="language-plaintext highlighter-rouge">proj1</code>, <code class="language-plaintext highlighter-rouge">proj2</code>, and <code class="language-plaintext highlighter-rouge">pair</code>, are defined in terms of <code class="language-plaintext highlighter-rouge">mcopy</code> and <code class="language-plaintext highlighter-rouge">delete</code>, which makes this theorem not as trivial as it would appear. Basically it involves unfolding the definitions, and then applying out of nowhere some identities involving braiding.</p>

<p>I decided to give Z3, an SMT solver, a go since I‚Äôm already familiar with it and its python bindings. There are native Julia bindings <a href="https://github.com/ahumenberger/Z3.jl">https://github.com/ahumenberger/Z3.jl</a> which may be useful for a more high performance situation, but they don‚Äôt appear to have quantifier support yet.</p>

<p>Julia has the library PyCall <a href="https://github.com/JuliaPy/PyCall.jl">https://github.com/JuliaPy/PyCall.jl</a> which was a shear joy to use. I actually could copy and paste some python3 z3 code and run it with very few modifications and I couldn‚Äôt imagine going into and out of Julia data types being more seemless.</p>

<p>Z3 does a better job than I expected. I thought thus problem was more appropriate to eprover or vampire, but z3 seemed to consistently out perform them.</p>

<p>At first I tried using a single z3 sort <code class="language-plaintext highlighter-rouge">z3.DeclareSort("Gat")</code> , but eventually I switched to a multisorted representation  <code class="language-plaintext highlighter-rouge">z3.DeclareSort("Ob")</code> and <code class="language-plaintext highlighter-rouge">z3.DeclareSort("Hom")</code> as this gets a step closer to accurately representation the types of the GATs in the simply sorted smtlib language. Which of these sorts to use can be determined by looking at the head symbol of the inferred Catlab types. I wrote a custom type inference just so I could try stuff out, but after asking in the zulip, apparently catlab has this built in also.</p>

<p>Some Z3 debugging tips:</p>

<p>I tend to make my z3 programs in python, dump the <code class="language-plaintext highlighter-rouge">s.sexpr()</code> in a file and then run that via the z3 command line. It‚Äôs easier to fiddle with the smtlib2 file to try out ideas fast. Take stuff out, put stuff in, make simpler questions, etc. Be aware most ideas do not work.</p>

<p>Z3 appears to be inferring pretty bad triggers. The main way z3 handles quantifiers is that it looks for patterns from the quantified expression in the currently known assertion set and instantiates the quantified expression accordingly. Hence I kind of think of quantified expressions as a kind of macro for formulas. This is called E-matching <a href="https://rise4fun.com/z3/tutorialcontent/guide#h28">https://rise4fun.com/z3/tutorialcontent/guide#h28</a>. Running z3 with a <code class="language-plaintext highlighter-rouge">-v:10</code>  flag let‚Äôs you see the triggers. Z3 tries to find very small pieces of expressions that contain the quantified variables. I think we don‚Äôt really want any equations instantiated unless it finds either the  full right or left hand side + context types. In addition, the triggers inferred for the type inference predicates were not good. We mostly want z3 to run the typing predicate forward, basically as a type inference function. So I tried adding all this and I <em>think</em> it helped, but not enough to actually get my equation to prove. Only simpler problems.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;
(assert (forall ((A Ob)) (! (= (typo (id A)) (Hom A A)) :pattern ((id A)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom B C)))
         (= (typo (compose f g)) (Hom A C)))
     :pattern ((compose f g) (Hom A B) (Hom B C)))))
(assert (forall ((A Ob) (B Ob)) (! (= (typo (otimes A B)) Ob) :pattern ((otimes A B)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom C D)))
         (= (typo (otimes f g)) (Hom (otimes A C) (otimes B D))))
     :pattern ((otimes f g) (Hom A B) (Hom C D)))))
;(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (f Hom) (g Hom))
;  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom C D)))
;         (= (typo (otimes f g)) (Hom (otimes A C) (otimes B D))))
;     :pattern ((= (typo f) (Hom A B)) (= (typo g) (Hom C D))))))
(assert (= (typo munit) Ob))
(assert (forall ((A Ob) (B Ob))
  (! (= (typo (braid A B)) (Hom (otimes A B) (otimes B A)))
     :pattern ((braid A B)))))
(assert (forall ((A Ob))
  (! (= (typo (mcopy A)) (Hom A (otimes A A))) :pattern ((mcopy A)))))
(assert (forall ((A Ob)) (! (= (typo (delete A)) (Hom A munit)) :pattern ((delete A)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom A C)))
         (= (typo (pair f g)) (Hom A (otimes B C))))
     :pattern ((pair f g) (Hom A B) (Hom A C)))))
(assert (forall ((A Ob) (B Ob))
  (! (= (typo (proj1 A B)) (Hom (otimes A B) A)) :pattern ((proj1 A B)))))
(assert (forall ((A Ob) (B Ob))
  (! (= (typo (proj2 A B)) (Hom (otimes A B) B)) :pattern ((proj2 A B)))))&lt;/code&gt;
</code></pre></div></div>

<p>I tried the axiom profiler to give me any insight.  <a href="http://people.inf.ethz.ch/summersa/wiki/lib/exe/fetch.php?media=papers:axiomprofiler.pdf">http://people.inf.ethz.ch/summersa/wiki/lib/exe/fetch.php?media=papers:axiomprofiler.pdf</a> <a href="https://github.com/viperproject/axiom-profiler">https://github.com/viperproject/axiom-profiler</a>  I do see some quantifiers that have an insane number of instantiations. This may be because of my multipattern approach of using the Hom type and separately the term as patterns. It will just randomly fire the trigger on Homs unrelated to the one their connected to. That‚Äôs awful. The associativity axioms also seem to be triggering too much and that is somewhat expected.</p>

<p>Z3 debugging is similar to prolog debugging since it‚Äôs declarative. <a href="https://www.metalevel.at/prolog/debugging">https://www.metalevel.at/prolog/debugging</a> Take out asserts. Eventually, if you take out enough, an <code class="language-plaintext highlighter-rouge">unsat</code> problem should turn <code class="language-plaintext highlighter-rouge">sat</code>.  That may help you isolate problematic axiom</p>

<p>Another thing I tried was to manually expand out each step of the proof to see where z3 was getting hung up. Most simple step were very fast, but some hung, apparently due to bad triggers? Surprisingly, some things I consider 1 step trivial aren‚Äôt quite. Often this is because single equations steps involves associating and absorbing <code class="language-plaintext highlighter-rouge">munit</code> in the type predicates. The interchange law was difficult to get to fire for this reason I think.</p>

<p>Trimming the axioms available to only the ones needed really helps, but doesn‚Äôt seem practical as an automated thing.</p>

<h2 id="code">Code</h2>

<p>Here‚Äôs the Julia code I ended up using to generate the z3 query from the catlab axioms. It‚Äôs very hacky. My apologies. I was thrashing.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># here we're trying to use Z3 sorts to take care of some of the typign</span>
<span class="k">using</span> <span class="n">Catlab</span>
<span class="k">using</span> <span class="n">Catlab</span><span class="o">.</span><span class="n">Theories</span>
<span class="k">using</span> <span class="n">PyCall</span>
<span class="n">z3</span> <span class="o">=</span> <span class="n">pyimport</span><span class="x">(</span><span class="s">"z3"</span><span class="x">)</span>

<span class="c"># my ersatz unnecessary type inference code for Cartesian category terms</span>

<span class="k">function</span><span class="nf"> type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Symbol</span><span class="x">;</span> <span class="n">ctx</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">())</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">:</span><span class="n">Ob</span>
        <span class="k">return</span> <span class="o">:</span><span class="n">TYPE</span>
    <span class="k">elseif</span> <span class="n">x</span> <span class="o">==</span> <span class="o">:</span><span class="n">munit</span>
        <span class="k">return</span> <span class="o">:</span><span class="n">Ob</span>
    <span class="k">else</span> 
        <span class="k">return</span> <span class="n">ctx</span><span class="x">[</span><span class="n">x</span><span class="x">]</span>
    <span class="k">end</span> 
    
<span class="k">end</span>
    
<span class="k">function</span><span class="nf"> type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Expr</span><span class="x">;</span> <span class="n">ctx</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">())</span>
        <span class="nd">@assert</span> <span class="n">x</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">call</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span>
        <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">compose</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">)</span>
            <span class="nd">@assert</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">==</span> <span class="o">:</span><span class="n">Hom</span>
            <span class="n">obA</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span> 
            <span class="n">t2</span> <span class="o">=</span> <span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">)</span>
            <span class="nd">@assert</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">==</span> <span class="o">:</span><span class="n">Hom</span>
            <span class="n">obC</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> 

            <span class="k">if</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> <span class="o">!=</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
                <span class="c">#println("HEY CHECK THIS OUT ITS WEIRD")</span>
            <span class="c">#println(t1)</span>
            <span class="c">#println(t2)</span>
        <span class="k">end</span>

            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="o">$</span><span class="n">obA</span><span class="x">,</span> <span class="o">$</span><span class="n">obC</span><span class="x">))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">otimes</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">)</span>
            <span class="c">#@assert t1.args[1] == :Hom</span>
            <span class="k">if</span> <span class="n">t1</span> <span class="k">isa</span> <span class="kt">Symbol</span> <span class="o">&amp;&amp;</span> <span class="n">t1</span> <span class="o">==</span> <span class="o">:</span><span class="n">Ob</span>
                <span class="k">return</span> <span class="o">:</span><span class="n">Ob</span>
            <span class="k">end</span>
            <span class="nd">@assert</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">==</span> <span class="o">:</span><span class="n">Hom</span>
            <span class="n">obA</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span> 
            <span class="n">obC</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> 
            <span class="n">t2</span> <span class="o">=</span> <span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">)</span>
            <span class="nd">@assert</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">==</span> <span class="o">:</span><span class="n">Hom</span>
            <span class="n">obB</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span> 
            <span class="n">obD</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> 
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">obA</span><span class="x">,</span><span class="o">$</span><span class="n">obB</span><span class="x">),</span><span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">obC</span><span class="x">,</span> <span class="o">$</span><span class="n">obD</span><span class="x">)))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">pair</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">)</span>
            <span class="nd">@assert</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">==</span> <span class="o">:</span><span class="n">Hom</span>
            <span class="n">obA</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span> 
            <span class="n">obB</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> 
            <span class="n">t2</span> <span class="o">=</span> <span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">],</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">)</span>
            <span class="nd">@assert</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">==</span> <span class="o">:</span><span class="n">Hom</span>
            <span class="n">obC</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span> 
            <span class="nd">@assert</span> <span class="n">t1</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span> <span class="o">==</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="o">$</span><span class="n">obA</span><span class="x">,</span> <span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">obB</span><span class="x">,</span><span class="o">$</span><span class="n">obC</span><span class="x">)))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">mcopy</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="o">$</span><span class="n">ob</span><span class="x">,</span> <span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">ob</span><span class="x">,</span><span class="o">$</span><span class="n">ob</span><span class="x">)))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">id</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="o">$</span><span class="n">ob</span><span class="x">,</span> <span class="o">$</span><span class="n">ob</span><span class="x">))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">delete</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="o">$</span><span class="n">ob</span><span class="x">,</span> <span class="n">munit</span><span class="x">))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">proj1</span>
            <span class="n">obA</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
            <span class="n">obB</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span>
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">obA</span><span class="x">,</span> <span class="o">$</span><span class="n">obB</span><span class="x">),</span> <span class="o">$</span><span class="n">obA</span><span class="x">))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">proj2</span>
            <span class="n">obA</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
            <span class="n">obB</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span>
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">obA</span><span class="x">,</span> <span class="o">$</span><span class="n">obB</span><span class="x">),</span> <span class="o">$</span><span class="n">obB</span><span class="x">))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">braid</span>
            <span class="n">obA</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span>
            <span class="n">obB</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">3</span><span class="x">]</span>
            <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">obA</span><span class="x">,</span> <span class="o">$</span><span class="n">obB</span><span class="x">),</span> <span class="n">otimes</span><span class="x">(</span><span class="o">$</span><span class="n">obB</span><span class="x">,</span> <span class="o">$</span><span class="n">obA</span><span class="x">)))</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">Hom</span>
            <span class="k">return</span> <span class="o">:</span><span class="n">TYPE</span>
        <span class="k">elseif</span> <span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">munit</span>
            <span class="k">return</span> <span class="o">:</span><span class="n">Ob</span>
        <span class="k">else</span>
            <span class="n">println</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">ctx</span><span class="x">)</span>
            <span class="nd">@assert</span> <span class="nb">false</span>
        <span class="k">end</span>
<span class="k">end</span>

<span class="n">TYPE</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">DeclareSort</span><span class="x">(</span><span class="s">"TYPE"</span><span class="x">)</span>

<span class="c"># sortify takes a type expression, grabs the head, and returns the corresponding Z3 sort.</span>
<span class="k">function</span><span class="nf"> sortify</span><span class="x">(</span><span class="n">ty</span><span class="x">)</span> 
    <span class="k">if</span> <span class="n">ty</span> <span class="k">isa</span> <span class="kt">Symbol</span>
        <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">DeclareSort</span><span class="x">(</span><span class="kt">String</span><span class="x">(</span><span class="n">ty</span><span class="x">))</span>
    <span class="k">elseif</span> <span class="n">ty</span> <span class="k">isa</span> <span class="kt">Expr</span>
        <span class="nd">@assert</span> <span class="n">ty</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">call</span>
        <span class="k">return</span> <span class="n">z3</span><span class="o">.</span><span class="n">DeclareSort</span><span class="x">(</span><span class="kt">String</span><span class="x">(</span><span class="n">ty</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]))</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c"># z3ify take an Expr or Symbol in a dictionary typing context and returns the z3 equivalent</span>
<span class="n">z3ify</span><span class="x">(</span> <span class="n">e</span><span class="o">::</span><span class="kt">Symbol</span> <span class="x">,</span> <span class="n">ctx</span><span class="x">)</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Const</span><span class="x">(</span><span class="kt">String</span><span class="x">(</span><span class="n">e</span><span class="x">),</span> <span class="n">sortify</span><span class="x">(</span><span class="n">type_infer</span><span class="x">(</span><span class="n">e</span><span class="x">,</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">)))</span>

<span class="k">function</span><span class="nf"> z3ify</span><span class="x">(</span> <span class="n">e</span><span class="o">::</span><span class="kt">Expr</span> <span class="x">,</span> <span class="n">ctx</span><span class="x">)</span>
    <span class="nd">@assert</span> <span class="n">e</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">call</span>
    <span class="n">out_sort</span> <span class="o">=</span> <span class="n">sortify</span><span class="x">(</span><span class="n">type_infer</span><span class="x">(</span><span class="n">e</span><span class="x">,</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">))</span>
    <span class="n">z3</span><span class="o">.</span><span class="kt">Function</span><span class="x">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span> <span class="x">[</span><span class="n">sortify</span><span class="x">(</span><span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">))</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="x">]]</span><span class="o">...</span><span class="x">,</span> <span class="n">out_sort</span><span class="x">)(</span><span class="n">map</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="x">])</span><span class="o">...</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># typo is a helper routine that takes an Expr or Symbol term and returns the Z3 function typo applied to the z3ified term</span>
<span class="k">function</span><span class="nf"> typo</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">ctx</span><span class="x">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="kt">Function</span><span class="x">(</span><span class="s">"typo"</span> <span class="x">,</span> <span class="n">sortify</span><span class="x">(</span><span class="n">type_infer</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">))</span>  <span class="x">,</span> <span class="n">TYPE</span> <span class="x">)</span> 
    <span class="n">f</span><span class="x">(</span><span class="n">z3ify</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="x">))</span>
<span class="k">end</span>

<span class="c"># a helper function to z3ify an entire context for the implication</span>
<span class="k">function</span><span class="nf"> build_ctx_predicate</span><span class="x">(</span><span class="n">ctx</span><span class="x">)</span>
    <span class="n">map</span><span class="x">(</span> <span class="n">kv</span><span class="o">-&gt;</span> <span class="k">begin</span>
        <span class="c">#typo = z3.Function("typo" , sortify(typ)  , TYPE ) </span>
        <span class="n">typo</span><span class="x">(</span><span class="n">kv</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span> <span class="n">ctx</span><span class="x">)</span> <span class="o">==</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">kv</span><span class="x">[</span><span class="mi">2</span><span class="x">],</span> <span class="n">ctx</span><span class="x">)</span>
        <span class="k">end</span>
        
        <span class="x">,</span> <span class="n">filter</span><span class="x">(</span> <span class="n">kv</span> <span class="o">-&gt;</span> <span class="n">kv</span><span class="x">[</span><span class="mi">2</span><span class="x">]</span> <span class="k">isa</span> <span class="kt">Expr</span> <span class="x">,</span> <span class="c"># we don't need to put typo predicates about simple types like Ob </span>
              <span class="n">collect</span><span class="x">(</span><span class="n">ctx</span><span class="x">)))</span>

<span class="k">end</span>

<span class="c"># converts the typing axioms of a GAT into the equivalent z3 axioms</span>
<span class="c"># This is quite close to unreadable I think</span>
<span class="k">function</span><span class="nf"> build_typo_z3</span><span class="x">(</span><span class="n">terms</span><span class="x">)</span>
    <span class="n">map</span><span class="x">(</span><span class="n">myterm</span> <span class="o">-&gt;</span>  <span class="k">begin</span>
                <span class="n">ctx</span> <span class="o">=</span> <span class="n">myterm</span><span class="o">.</span><span class="n">context</span>
                <span class="n">conc</span> <span class="o">=</span>  <span class="n">length</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">params</span><span class="x">)</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">?</span>  <span class="kt">Expr</span><span class="x">(</span><span class="o">:</span><span class="n">call</span><span class="x">,</span> <span class="n">myterm</span><span class="o">.</span><span class="n">name</span><span class="x">,</span> <span class="n">myterm</span><span class="o">.</span><span class="n">params</span><span class="o">...</span><span class="x">)</span> <span class="o">:</span> <span class="n">myterm</span><span class="o">.</span><span class="n">name</span>
                  <span class="n">preconds</span> <span class="o">=</span> <span class="n">build_ctx_predicate</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> 
                    <span class="k">if</span> <span class="n">length</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">length</span><span class="x">(</span><span class="n">preconds</span><span class="x">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="x">(</span> <span class="n">map</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span> <span class="n">collect</span><span class="x">(</span><span class="n">keys</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)))</span> <span class="x">,</span>
                            <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="x">(</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="x">(</span><span class="n">preconds</span><span class="x">)</span>  <span class="x">,</span> 
                                      <span class="n">typo</span><span class="x">(</span><span class="n">conc</span><span class="x">,</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> <span class="o">==</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">typ</span><span class="x">,</span> <span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)),</span>
                  <span class="n">patterns</span> <span class="o">=</span> <span class="x">[</span> <span class="n">z3</span><span class="o">.</span><span class="n">MultiPattern</span><span class="x">(</span><span class="n">z3ify</span><span class="x">(</span><span class="n">conc</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span>  
                                <span class="x">[</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span> <span class="x">,</span><span class="n">ctx</span> <span class="x">)</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">collect</span><span class="x">(</span><span class="n">values</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">))</span> <span class="k">if</span> <span class="n">x</span> <span class="k">isa</span> <span class="kt">Expr</span><span class="x">]</span><span class="o">...</span><span class="x">)</span> <span class="c"># not super sure this is a valid way of filtering generally</span>
                              <span class="x">],</span>
                  <span class="x">)</span>
                <span class="k">elseif</span> <span class="n">length</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="x">(</span> <span class="n">map</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span> <span class="n">collect</span><span class="x">(</span><span class="n">keys</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)))</span> <span class="x">,</span>
                                      <span class="n">typo</span><span class="x">(</span><span class="n">conc</span><span class="x">,</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> <span class="o">==</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">typ</span><span class="x">,</span> <span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">),</span>
                          <span class="n">patterns</span> <span class="o">=</span> <span class="x">[</span><span class="n">z3ify</span><span class="x">(</span><span class="n">conc</span><span class="x">,</span><span class="n">ctx</span><span class="x">)])</span>
                    <span class="k">else</span>
                        <span class="n">typo</span><span class="x">(</span><span class="n">conc</span><span class="x">,</span><span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> <span class="o">==</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">myterm</span><span class="o">.</span><span class="n">typ</span><span class="x">,</span> <span class="n">myterm</span><span class="o">.</span><span class="n">context</span><span class="x">)</span>
                    <span class="k">end</span>
            <span class="k">end</span>
              
    <span class="x">,</span> <span class="n">terms</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># convert the equations axioms of a GAT into the equivalent z3 terms</span>
<span class="k">function</span><span class="nf"> build_eqs_z3</span><span class="x">(</span><span class="n">axioms</span><span class="x">)</span>
        <span class="n">map</span><span class="x">(</span><span class="n">axiom</span> <span class="o">-&gt;</span> <span class="k">begin</span>
            <span class="nd">@assert</span> <span class="n">axiom</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="o">:</span><span class="x">(</span><span class="o">==</span><span class="x">)</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">axiom</span><span class="o">.</span><span class="n">context</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">left</span><span class="x">,</span> <span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">right</span><span class="x">,</span> <span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)</span>
            <span class="n">preconds</span><span class="o">=</span> <span class="n">build_ctx_predicate</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> 
            <span class="n">ctx_patterns</span> <span class="o">=</span> <span class="x">[</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span> <span class="x">,</span><span class="n">ctx</span> <span class="x">)</span> <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">collect</span><span class="x">(</span><span class="n">values</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">))</span> <span class="k">if</span> <span class="n">x</span> <span class="k">isa</span> <span class="kt">Expr</span><span class="x">]</span>
            <span class="n">println</span><span class="x">([</span><span class="n">z3</span><span class="o">.</span><span class="n">MultiPattern</span><span class="x">(</span> <span class="n">l</span> <span class="x">,</span> <span class="n">ctx_patterns</span><span class="o">...</span>  <span class="x">)</span> <span class="x">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">MultiPattern</span><span class="x">(</span> <span class="n">r</span> <span class="x">,</span> <span class="n">ctx_patterns</span><span class="o">...</span>  <span class="x">)</span> <span class="x">])</span>
            <span class="k">if</span> <span class="n">length</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">length</span><span class="x">(</span><span class="n">preconds</span><span class="x">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="k">try</span>
                    <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="x">(</span> <span class="n">map</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span> <span class="n">collect</span><span class="x">(</span><span class="n">keys</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)))</span> <span class="x">,</span> 
                    <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="x">(</span>  <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="x">(</span> <span class="n">preconds</span><span class="x">)</span> <span class="x">,</span>   <span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="x">),</span>
                <span class="n">patterns</span> <span class="o">=</span> <span class="x">[</span><span class="n">z3</span><span class="o">.</span><span class="n">MultiPattern</span><span class="x">(</span> <span class="n">l</span> <span class="x">,</span> <span class="n">ctx_patterns</span><span class="o">...</span>  <span class="x">)</span> <span class="x">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">MultiPattern</span><span class="x">(</span> <span class="n">r</span> <span class="x">,</span> <span class="n">ctx_patterns</span><span class="o">...</span>  <span class="x">)</span> <span class="x">])</span>
                    <span class="k">catch</span> <span class="n">e</span>
                      <span class="n">println</span><span class="x">(</span><span class="n">e</span><span class="x">)</span>
                        <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="x">(</span> <span class="n">map</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span> <span class="n">collect</span><span class="x">(</span><span class="n">keys</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)))</span> <span class="x">,</span> 
                        <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="x">(</span>  <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="x">(</span> <span class="n">preconds</span><span class="x">)</span> <span class="x">,</span>   <span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="x">))</span>
                <span class="k">end</span>
                <span class="k">elseif</span> <span class="n">length</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span> <span class="n">length</span><span class="x">(</span><span class="n">preconds</span><span class="x">)</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">z3</span><span class="o">.</span><span class="n">ForAll</span><span class="x">(</span> <span class="n">map</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span> <span class="n">collect</span><span class="x">(</span><span class="n">keys</span><span class="x">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">context</span><span class="x">)))</span> <span class="x">,</span> <span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="x">,</span> <span class="n">patterns</span> <span class="o">=</span> <span class="x">[</span><span class="n">l</span><span class="x">,</span><span class="n">r</span><span class="x">])</span>
                
                <span class="k">else</span>
                    <span class="n">l</span> <span class="o">==</span> <span class="n">r</span>
                <span class="k">end</span>
            <span class="k">end</span><span class="x">,</span>
        <span class="n">axioms</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># jut trying some stuff out</span>
<span class="n">sortify</span><span class="x">(</span> <span class="o">:</span><span class="n">Ob</span> <span class="x">)</span>
<span class="n">sortify</span><span class="x">(</span> <span class="o">:</span><span class="x">(</span><span class="n">Hom</span><span class="x">(</span><span class="n">a</span><span class="x">,</span><span class="n">b</span><span class="x">)))</span>
<span class="n">ctx</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">(</span><span class="o">:</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="n">Ob</span><span class="x">,</span> <span class="o">:</span><span class="n">B</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="n">Ob</span><span class="x">)</span>
<span class="n">z3ify</span><span class="x">(</span><span class="o">:</span><span class="x">(</span><span class="n">id</span><span class="x">(</span><span class="n">A</span><span class="x">))</span> <span class="x">,</span> <span class="n">ctx</span><span class="x">)</span>
<span class="cm">#=typing_axioms = build_typo_z3(theory(CartesianCategory).terms)
eq_axioms = build_eqs_z3(theory(CartesianCategory).axioms)

s = z3.Solver()
s.add(typing_axioms)
s.add(eq_axioms)
#print(s.sexpr())
=#</span>

<span class="n">inferall</span><span class="x">(</span><span class="n">e</span><span class="o">::</span><span class="kt">Symbol</span><span class="x">,</span> <span class="n">ctx</span><span class="x">)</span> <span class="o">=</span> <span class="x">[</span><span class="n">typo</span><span class="x">(</span><span class="n">e</span><span class="x">,</span><span class="n">ctx</span><span class="x">)</span> <span class="o">==</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">type_infer</span><span class="x">(</span><span class="n">e</span><span class="x">,</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">),</span><span class="n">ctx</span><span class="x">)]</span>
<span class="n">inferall</span><span class="x">(</span><span class="n">e</span><span class="o">::</span><span class="kt">Expr</span><span class="x">,</span> <span class="n">ctx</span><span class="x">)</span> <span class="o">=</span> <span class="n">Iterators</span><span class="o">.</span><span class="n">flatten</span><span class="x">([[</span><span class="n">typo</span><span class="x">(</span><span class="n">e</span><span class="x">,</span><span class="n">ctx</span><span class="x">)</span> <span class="o">==</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">type_infer</span><span class="x">(</span><span class="n">e</span><span class="x">,</span><span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="x">),</span><span class="n">ctx</span><span class="x">)],</span> <span class="n">Iterators</span><span class="o">.</span><span class="n">flatten</span><span class="x">(</span><span class="n">map</span><span class="x">(</span><span class="n">z</span> <span class="o">-&gt;</span> <span class="n">inferall</span><span class="x">(</span><span class="n">z</span><span class="x">,</span><span class="n">ctx</span><span class="x">),</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="x">]))])</span>


<span class="k">function</span><span class="nf"> prove</span><span class="x">(</span><span class="n">ctx</span><span class="x">,</span> <span class="n">l</span><span class="x">,</span><span class="n">r</span><span class="x">;</span> <span class="n">pr</span> <span class="o">=</span> <span class="nb">false</span><span class="x">)</span>
    <span class="n">typing_axioms</span> <span class="o">=</span> <span class="n">build_typo_z3</span><span class="x">(</span><span class="n">theory</span><span class="x">(</span><span class="n">CartesianCategory</span><span class="x">)</span><span class="o">.</span><span class="n">terms</span><span class="x">)</span>
    <span class="n">eq_axioms</span> <span class="o">=</span> <span class="n">build_eqs_z3</span><span class="x">(</span><span class="n">theory</span><span class="x">(</span><span class="n">CartesianCategory</span><span class="x">)</span><span class="o">.</span><span class="n">axioms</span><span class="x">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="x">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="x">(</span><span class="n">typing_axioms</span><span class="x">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="x">(</span><span class="n">eq_axioms</span><span class="x">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="x">(</span><span class="n">collect</span><span class="x">(</span><span class="n">inferall</span><span class="x">(</span><span class="n">l</span><span class="x">,</span><span class="n">ctx</span><span class="x">)))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="x">(</span><span class="n">collect</span><span class="x">(</span><span class="n">inferall</span><span class="x">(</span><span class="n">r</span><span class="x">,</span><span class="n">ctx</span><span class="x">)))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="x">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="x">(</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">l</span><span class="x">,</span><span class="n">ctx</span><span class="x">)</span> <span class="o">==</span> <span class="n">z3ify</span><span class="x">(</span><span class="n">r</span><span class="x">,</span><span class="n">ctx</span><span class="x">)))</span>
    <span class="c">#println("checking $x")</span>
    <span class="c">#if pr</span>
    <span class="n">println</span><span class="x">(</span><span class="n">s</span><span class="o">.</span><span class="n">sexpr</span><span class="x">())</span>
      <span class="c">#else</span>
    <span class="c">#println(s.check())</span>
    <span class="c">#end</span>
<span class="k">end</span>
<span class="n">ctx</span> <span class="o">=</span>  <span class="kt">Dict</span><span class="x">(</span><span class="o">:</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="n">Ob</span><span class="x">,</span> <span class="o">:</span><span class="n">B</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="n">Ob</span><span class="x">)</span>
<span class="n">prove</span><span class="x">(</span> <span class="n">ctx</span><span class="x">,</span> <span class="o">:</span><span class="x">(</span><span class="n">pair</span><span class="x">(</span><span class="n">proj1</span><span class="x">(</span><span class="n">A</span><span class="x">,</span><span class="n">B</span><span class="x">),</span> <span class="n">proj2</span><span class="x">(</span><span class="n">A</span><span class="x">,</span><span class="n">B</span><span class="x">))),</span> <span class="o">:</span><span class="x">(</span><span class="n">otimes</span><span class="x">(</span><span class="n">id</span><span class="x">(</span><span class="n">A</span><span class="x">),</span><span class="n">id</span><span class="x">(</span><span class="n">B</span><span class="x">))))</span>
</code></pre></div></div>

<p>The returned smtlib2 predicate with a <code class="language-plaintext highlighter-rouge">(check-sat)</code> manually added at the end</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;(declare-sort Ob 0)
(declare-sort TYPE 0)
(declare-sort Hom 0)
(declare-fun id (Ob) Hom)
(declare-fun Hom (Ob Ob) TYPE)
(declare-fun typo (Hom) TYPE)
(declare-fun compose (Hom Hom) Hom)
(declare-fun otimes (Ob Ob) Ob)
(declare-fun Ob () TYPE)
(declare-fun typo (Ob) TYPE)
(declare-fun otimes (Hom Hom) Hom)
(declare-fun munit () Ob)
(declare-fun braid (Ob Ob) Hom)
(declare-fun mcopy (Ob) Hom)
(declare-fun delete (Ob) Hom)
(declare-fun pair (Hom Hom) Hom)
(declare-fun proj1 (Ob Ob) Hom)
(declare-fun proj2 (Ob Ob) Hom)
(declare-fun B () Ob)
(declare-fun A () Ob)
(assert (forall ((A Ob)) (! (= (typo (id A)) (Hom A A)) :pattern ((id A)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom B C)))
         (= (typo (compose f g)) (Hom A C)))
     :pattern ((compose f g) (Hom A B) (Hom B C)))))
(assert (forall ((A Ob) (B Ob)) (! (= (typo (otimes A B)) Ob) :pattern ((otimes A B)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom C D)))
         (= (typo (otimes f g)) (Hom (otimes A C) (otimes B D))))
     :pattern ((otimes f g) (Hom A B) (Hom C D)))))
(assert (= (typo munit) Ob))
(assert (forall ((A Ob) (B Ob))
  (! (= (typo (braid A B)) (Hom (otimes A B) (otimes B A)))
     :pattern ((braid A B)))))
(assert (forall ((A Ob))
  (! (= (typo (mcopy A)) (Hom A (otimes A A))) :pattern ((mcopy A)))))
(assert (forall ((A Ob)) (! (= (typo (delete A)) (Hom A munit)) :pattern ((delete A)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom A C)))
         (= (typo (pair f g)) (Hom A (otimes B C))))
     :pattern ((pair f g) (Hom A B) (Hom A C)))))
(assert (forall ((A Ob) (B Ob))
  (! (= (typo (proj1 A B)) (Hom (otimes A B) A)) :pattern ((proj1 A B)))))
(assert (forall ((A Ob) (B Ob))
  (! (= (typo (proj2 A B)) (Hom (otimes A B) B)) :pattern ((proj2 A B)))))
(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (f Hom) (g Hom) (h Hom))
  (! (=&gt; (and (= (typo f) (Hom A B))
              (= (typo g) (Hom B C))
              (= (typo h) (Hom C D)))
         (= (compose (compose f g) h) (compose f (compose g h))))
     :pattern ((compose (compose f g) h) (Hom A B) (Hom B C) (Hom C D))
     :pattern ((compose f (compose g h)) (Hom A B) (Hom B C) (Hom C D)))))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (! (=&gt; (and (= (typo f) (Hom A B))) (= (compose f (id B)) f))
     :pattern ((compose f (id B)) (Hom A B))
     :pattern (pattern f (Hom A B)))))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (! (=&gt; (and (= (typo f) (Hom A B))) (= (compose (id A) f) f))
     :pattern ((compose (id A) f) (Hom A B))
     :pattern (pattern f (Hom A B)))))
(assert (forall ((A Ob) (B Ob) (C Ob))
  (! (= (otimes (otimes A B) C) (otimes A (otimes B C)))
     :pattern ((otimes (otimes A B) C))
     :pattern ((otimes A (otimes B C))))))
(assert (forall ((A Ob))
  (! (= (otimes A munit) A) :pattern ((otimes A munit)) :pattern (pattern A))))
(assert (forall ((A Ob))
  (! (= (otimes munit A) A) :pattern ((otimes munit A)) :pattern (pattern A))))
(assert (forall ((A Ob) (B Ob) (C Ob) (X Ob) (Y Ob) (Z Ob) (f Hom) (g Hom) (h Hom))
  (! (=&gt; (and (= (typo f) (Hom A X))
              (= (typo g) (Hom B Y))
              (= (typo h) (Hom C Z)))
         (= (otimes (otimes f g) h) (otimes f (otimes g h))))
     :pattern ((otimes (otimes f g) h) (Hom A X) (Hom B Y) (Hom C Z))
     :pattern ((otimes f (otimes g h)) (Hom A X) (Hom B Y) (Hom C Z)))))
(assert (forall ((A Ob)
         (B Ob)
         (C Ob)
         (X Ob)
         (Y Ob)
         (Z Ob)
         (f Hom)
         (h Hom)
         (g Hom)
         (k Hom))
  (! (=&gt; (and (= (typo f) (Hom A B))
              (= (typo h) (Hom B C))
              (= (typo g) (Hom X Y))
              (= (typo k) (Hom Y Z)))
         (= (compose (otimes f g) (otimes h k))
            (otimes (compose f h) (compose g k))))
     :pattern ((compose (otimes f g) (otimes h k))
               (Hom A B)
               (Hom B C)
               (Hom X Y)
               (Hom Y Z))
     :pattern ((otimes (compose f h) (compose g k))
               (Hom A B)
               (Hom B C)
               (Hom X Y)
               (Hom Y Z)))))
(assert (forall ((A Ob) (B Ob))
  (! (= (id (otimes A B)) (otimes (id A) (id B)))
     :pattern ((id (otimes A B)))
     :pattern ((otimes (id A) (id B))))))
(assert (forall ((A Ob) (B Ob))
  (! (= (compose (braid A B) (braid B A)) (id (otimes A B)))
     :pattern ((compose (braid A B) (braid B A)))
     :pattern ((id (otimes A B))))))
(assert (forall ((A Ob) (B Ob) (C Ob))
  (! (= (braid A (otimes B C))
        (compose (otimes (braid A B) (id C)) (otimes (id B) (braid A C))))
     :pattern ((braid A (otimes B C)))
     :pattern ((compose (otimes (braid A B) (id C)) (otimes (id B) (braid A C)))))))
(assert (forall ((A Ob) (B Ob) (C Ob))
  (! (= (braid (otimes A B) C)
        (compose (otimes (id A) (braid B C)) (otimes (braid A C) (id B))))
     :pattern ((braid (otimes A B) C))
     :pattern ((compose (otimes (id A) (braid B C)) (otimes (braid A C) (id B)))))))
(assert (forall ((A Ob) (B Ob) (C Ob) (D Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)) (= (typo g) (Hom C D)))
         (= (compose (otimes f g) (braid B D))
            (compose (braid A C) (otimes g f))))
     :pattern ((compose (otimes f g) (braid B D)) (Hom A B) (Hom C D))
     :pattern ((compose (braid A C) (otimes g f)) (Hom A B) (Hom C D)))))
(assert (forall ((A Ob))
  (! (= (compose (mcopy A) (otimes (mcopy A) (id A)))
        (compose (mcopy A) (otimes (id A) (mcopy A))))
     :pattern ((compose (mcopy A) (otimes (mcopy A) (id A))))
     :pattern ((compose (mcopy A) (otimes (id A) (mcopy A)))))))
(assert (forall ((A Ob))
  (! (= (compose (mcopy A) (otimes (delete A) (id A))) (id A))
     :pattern ((compose (mcopy A) (otimes (delete A) (id A))))
     :pattern ((id A)))))
(assert (forall ((A Ob))
  (! (= (compose (mcopy A) (otimes (id A) (delete A))) (id A))
     :pattern ((compose (mcopy A) (otimes (id A) (delete A))))
     :pattern ((id A)))))
(assert (forall ((A Ob))
  (! (= (compose (mcopy A) (braid A A)) (mcopy A))
     :pattern ((compose (mcopy A) (braid A A)))
     :pattern ((mcopy A)))))
(assert (forall ((A Ob) (B Ob))
  (! (let ((a!1 (compose (otimes (mcopy A) (mcopy B))
                         (otimes (otimes (id A) (braid A B)) (id B)))))
       (= (mcopy (otimes A B)) a!1))
     :pattern ((mcopy (otimes A B)))
     :pattern ((compose (otimes (mcopy A) (mcopy B))
                        (otimes (otimes (id A) (braid A B)) (id B)))))))
(assert (forall ((A Ob) (B Ob))
  (! (= (delete (otimes A B)) (otimes (delete A) (delete B)))
     :pattern ((delete (otimes A B)))
     :pattern ((otimes (delete A) (delete B))))))
(assert (= (mcopy munit) (id munit)))
(assert (= (delete munit) (id munit)))
(assert (forall ((A Ob) (B Ob) (C Ob) (f Hom) (g Hom))
  (! (=&gt; (and (= (typo f) (Hom C A)) (= (typo g) (Hom C B)))
         (= (pair f g) (compose (mcopy C) (otimes f g))))
     :pattern ((pair f g) (Hom C A) (Hom C B))
     :pattern ((compose (mcopy C) (otimes f g)) (Hom C A) (Hom C B)))))
(assert (forall ((A Ob) (B Ob))
  (! (= (proj1 A B) (otimes (id A) (delete B)))
     :pattern ((proj1 A B))
     :pattern ((otimes (id A) (delete B))))))
(assert (forall ((A Ob) (B Ob))
  (! (= (proj2 A B) (otimes (delete A) (id B)))
     :pattern ((proj2 A B))
     :pattern ((otimes (delete A) (id B))))))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (! (=&gt; (and (= (typo f) (Hom A B)))
         (= (compose f (mcopy B)) (compose (mcopy A) (otimes f f))))
     :pattern ((compose f (mcopy B)) (Hom A B))
     :pattern ((compose (mcopy A) (otimes f f)) (Hom A B)))))
(assert (forall ((A Ob) (B Ob) (f Hom))
  (=&gt; (and (= (typo f) (Hom A B))) (= (compose f (delete B)) (delete A)))))
(assert (= (typo (pair (proj1 A B) (proj2 A B))) (Hom (otimes A B) (otimes A B))))
(assert (= (typo (proj1 A B)) (Hom (otimes A B) A)))
(assert (= (typo A) Ob))
(assert (= (typo B) Ob))
(assert (= (typo (proj2 A B)) (Hom (otimes A B) B)))
(assert (= (typo A) Ob))
(assert (= (typo B) Ob))
(assert (= (typo (otimes (id A) (id B))) (Hom (otimes A B) (otimes A B))))
(assert (= (typo (id A)) (Hom A A)))
(assert (= (typo A) Ob))
(assert (= (typo (id B)) (Hom B B)))
(assert (= (typo B) Ob))
(assert (not (= (pair (proj1 A B) (proj2 A B)) (otimes (id A) (id B)))))
(check-sat)&lt;/code&gt;
</code></pre></div></div>

<h3 id="other-junk">Other junk</h3>

<p>One could use z3 as glue for simple steps of proofs as is, but it doesn‚Äôt appear to scale well to even intermediately complex proofs. Maybe this could be used for a semi-automated (aka interactive) proof system for catlab? This seems misguided though. You‚Äôre better off using one of the many interactive proof assistants if that‚Äôs the way you wanna go. Maybe one could generate the queries to those system?</p>

<p>I tried the type tagging version, where every term <code class="language-plaintext highlighter-rouge">t</code> is recursively replaced with <code class="language-plaintext highlighter-rouge">tag(t, typo_t)</code>. This allows us to avoid the guards and the axioms of the GAT take the form of pure equations again, albeit ones of complex tagged terms. This did not work well. I was surprised. It‚Äôs kind of interesting that type tagging is in some sense internalizing another piece of Catlab syntax into a logic, just like how type guards internalized the turnstile as an implication and the context as the guard. In this case we are internalizing the inline type annotations (f::Hom(A,B)) into the logic, where I write the infix notation :: as the function tag().</p>

<p>Notebook here <a href="https://github.com/philzook58/thoughtbooks/blob/master/catlab_gat.ipynb">https://github.com/philzook58/thoughtbooks/blob/master/catlab_gat.ipynb</a></p>

<p><a href="file:///home/philip/Downloads/A_Polymorphic_Intermediate_Verification_Language_D.pdf">file:///home/philip/Downloads/A_Polymorphic_Intermediate_Verification_Language_D.pdf </a>The 3.1 method. If we have an extra argument to every function for the type of that argument inserted, then quantifier instantiation can only work when the</p>

<p>We could make it semi interactive (I guess semi interactive is just interactive though</p>

<p><a href="https://hal.inria.fr/hal-01322328/document">https://hal.inria.fr/hal-01322328/document</a> TLA+ encoding. Encoding to SMT solvers is a grand tradition</p>

<p>Wait, could it be that id really is the only problem? It‚Äôs the only equation with a raw variable in an equality. And that poisons all of Hom. Fascinating. I thought the problem was compose, but it‚Äôs id?</p>

<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7324017/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7324017/</a> vampire now supports polymorphism.</p>

<p>I realized that things that felt like a single step, were in fact not. This is because</p>

<p>Asserting the types of all subexpressions helped the solver sometimes and sometime hurt.</p>

<p>Solvers often use a heuristic where they want to look at the oldest generated inferences first. This means that the deeper you make your proof, the hard it is to for the solver to find it (well that‚Äôs true anyway). Making the proof depth harder for trivial type inference purposes is foolish.</p>

<p>Of course, taken to some extreme, at a certain point we‚Äôre asserting so many derived facts to the solver we have written a fraction of a solver ourselves.</p>

<p>I wonder what the recent burst of higher order capabilities of zipperposition, eprover, and vampire might do for me? The thing is we‚Äôre already compiling to combinators. That‚Äôs what categories are. https://matryoshka-project.github.io/</p>

<p>Functor example <a href="http://page.mi.fu-berlin.de/cbenzmueller/papers/J22.pdf">http://page.mi.fu-berlin.de/cbenzmueller/papers/J22.pdf </a>THF is higher order format of tptp.</p>

<p>Exporting to Isabelle in particular is a viable approach, as it is well known to have good automation. I mean, I‚Äôm reading the sledgehammer guy‚Äôs papers for tips. Also, exporting to an interactive theorem prover of any kind seems kind of useful.</p>

:ET