I"áê<p>This is the first article in a series about at least one way to encode many-body quantum mechanics in python (and eventually Haskell too maybe). Why even do this? I think that understanding in principle how to encode the problem concretely into a computer let‚Äôs you have a deeper understanding of what the hell is going on.</p>

<p>We‚Äôre not winning any awards for speed or efficiency here. Intentionally. A low level formulation of all this in C using GPU acceleration or something would be significantly less understandble. Let us unshackle ourselves from too many considerations of efficiency.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</code></pre></div></div>

<p>So to start, let‚Äôs take a few moments to talk a very tiny bit about single body quantum mechanics.</p>

<p>It is customary in solid state physics for the purposes of clarification to build simplified models of materials. One simplification is to say that electrons can exist on a lattice of sites with onsite energy $\epsilon$ and tunneling energy $t$. This lattice ultimately corresponds back to the crystal lattice of actual atoms and these mystery parameters can be related back closer (but not entirely. There really are huge gaps of deduction in our understanding of the chain of physics from the most fundamental to the large) to first principles by considering the Hamiltonian matrix elements $&lt;\psi_mH\psi_n&gt;$ of orbital wavefunctions of the atoms. Parametrizing the simplified model this way lets us cut a Gordian knot of complexity. For more info check out https://en.wikipedia.org/wiki/Tight_binding.</p>

<p>For simplicity, let‚Äôs consider a periodic 1-d ring of sites. This is convenient programmatically and mathematically. We can then extend this to greater and greater realism by the inclusion of more realtstic boundaries or try to physically realize such 1-d models in reality using nanowires or other somewhat exotic things.</p>

<p>A wavefunction $\psi$ with the particle sitting on the 0th site can be written like so</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSites</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NSites</span><span class="p">)</span>
<span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1.  0.  0.  0.  0.  0.]





[&lt;matplotlib.lines.Line2D at 0x7f8ccc0e86a0&gt;]
</code></pre></div></div>

<p><img src="/pynb/fermions_part_1_files/fermions_part_1_4_2.png" alt="png" /></p>

<p>Now let‚Äôs build the simple Hamiltonian as an explicit matrix acting on these wavefunctions. The Hamiltonian has the interpetation of giving the possible energies of the particle, but it is also useful as a way of thinking about where states go under time evolution. Any nonzero element $h_{ij}$ is a connection between site i and j. The tunneling element $t$ connects nearest neighbor sites.</p>

<p>The periodic nature of the Hamiltonian makes it useful to use the circulant matrix construction function from scipy.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">circulant</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">firstcol</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NSites</span><span class="p">)</span>
<span class="n">firstcol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span>
<span class="n">firstcol</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
<span class="n">firstcol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

<span class="n">oneH</span> <span class="o">=</span> <span class="n">circulant</span><span class="p">(</span><span class="n">firstcol</span><span class="p">)</span> <span class="c1">#Takes first column and repeats it shifted
</span><span class="k">print</span><span class="p">(</span><span class="n">oneH</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ 1.   0.5  0.   0.   0.   0.5]
 [ 0.5  1.   0.5  0.   0.   0. ]
 [ 0.   0.5  1.   0.5  0.   0. ]
 [ 0.   0.   0.5  1.   0.5  0. ]
 [ 0.   0.   0.   0.5  1.   0.5]
 [ 0.5  0.   0.   0.   0.5  1. ]]
</code></pre></div></div>

<p>It is then simple to ask for the energy (eigenvalues) levels of the matrix, or apply it to a wavefunction (which may be part of a single time step for example).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># a discretized time step dt.
</span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="n">NSites</span><span class="p">)</span> <span class="c1">#identity matrix
</span><span class="n">psi1</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="mf">1.j</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">oneH</span><span class="p">)</span> <span class="o">@</span> <span class="n">psi</span> <span class="c1">#@ is python3 notation for matrix product. I like it.
</span><span class="k">print</span><span class="p">(</span><span class="n">psi1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">real</span><span class="p">(</span><span class="n">psi1</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">imag</span><span class="p">(</span><span class="n">psi1</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1.-0.1j   0.-0.05j  0.+0.j    0.+0.j    0.+0.j    0.-0.05j]





[&lt;matplotlib.lines.Line2D at 0x7f8cc17e3588&gt;]
</code></pre></div></div>

<p><img src="/pynb/fermions_part_1_files/fermions_part_1_8_2.png" alt="png" /></p>

<p>After that, let‚Äôs switch gears a bit.</p>

<p>A first approach to many-body quantum mechanics is the occupation number representation. The states are labelled by a binary string, with 1s corresponding to filled states and 0s to empty states. For example the binary string 0b010001 would have a particle sitting on the 0th and the 4th site and empty everywhere else. Since you will need 1 bit per site, the total size of the vector space is $2^{# Sites}$. To label the states we‚Äôll need a couple of bit twiddling tricks.</p>

<p>A common idiom for getting a bit string with the nth bit set is to bit shift a 1 over by n.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bin</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'0b1000'
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>You mix strings with the or operator</td>
    </tr>
  </tbody>
</table>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0b11000
</code></pre></div></div>

<p>One way to count the number of bits set to one (the total occupation number of the lattice) is to use the following pythony code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">).</span><span class="n">count</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
</code></pre></div></div>

<p>However it will be nice to use another method. The Wikipedia article for <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> (a name for the operation of counting 1s in a binary string) has this code for a 64-bit unsigned integers. This is slightly inflexible and worrisome, however 64 sites using the methodology we‚Äôre using is totally impossible, so we might be okay. We‚Äôll need to be careful in the future to cast as uint64 or we‚Äôll get awful bugs unfortunately. This code vectorizes into numpy arrays.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#from wikipedia article on hamming weight
# works for 64 bits numbers
</span>
<span class="n">m1</span>  <span class="o">=</span> <span class="mh">0x5555555555555555</span><span class="p">;</span> <span class="c1">#binary: 0101...
</span><span class="n">m2</span>  <span class="o">=</span> <span class="mh">0x3333333333333333</span><span class="p">;</span> <span class="c1">#binary: 00110011..
</span><span class="n">m4</span>  <span class="o">=</span> <span class="mh">0x0f0f0f0f0f0f0f0f</span><span class="p">;</span> <span class="c1">#binary:  4 zeros,  4 ones ...
</span><span class="n">m8</span>  <span class="o">=</span> <span class="mh">0x00ff00ff00ff00ff</span><span class="p">;</span> <span class="c1">#binary:  8 zeros,  8 ones ...
</span><span class="n">m16</span> <span class="o">=</span> <span class="mh">0x0000ffff0000ffff</span><span class="p">;</span> <span class="c1">#binary: 16 zeros, 16 ones ...
</span><span class="n">m32</span> <span class="o">=</span> <span class="mh">0x00000000ffffffff</span><span class="p">;</span> <span class="c1">#binary: 32 zeros, 32 one
</span><span class="n">hff</span> <span class="o">=</span> <span class="mh">0xffffffffffffffff</span><span class="p">;</span> <span class="c1">#binary: all ones
</span><span class="n">h01</span> <span class="o">=</span> <span class="mh">0x0101010101010101</span><span class="p">;</span>
<span class="k">def</span> <span class="nf">popcount64c</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>             <span class="c1">#put count of each 2 bits into those 2 bits
</span>    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">);</span> <span class="c1">#put count of each 4 bits into those 4 bits
</span>    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>        <span class="c1">#put count of each 8 bits into those 8 bits
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">h01</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">;</span>  <span class="c1">#returns left 8 bits of x + (x&lt;&lt;8) + (x&lt;&lt;16) + (x&lt;&lt;24) + ...
</span>
</code></pre></div></div>

<p>Since 0 corresponds to the bit string 0b000000, this is the completely empty state, which we may call the vacuum. We need to set the amplitude of this index to 1.0 so that it accounts for the total quantum amplitude of being empty.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSites</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">NStates</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">NSites</span>

<span class="k">def</span> <span class="nf">vac</span><span class="p">(</span><span class="n">NStates</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NStates</span><span class="p">)</span>
    <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">state</span>
</code></pre></div></div>

<p>Now we get to the meat. How do we implement fermionic creation and annihilation operators commonly denoted $a_j^\dagger$ and $a_j$. The operators when applied to a state fill (create a particle) at an empty spot at site $j$, or empty it (annihilate the particle).
There is some truly funky business with fermions that we have to anticommute these operators. This is part of the mathematical origin of the Pauli Exclusion principle and has some relation to determinants, which we will see an aspect of later. Don‚Äôt get me wrong. These minus signs are weird.
To account for them, we pick a canonical ordering for the creation operators, in our case in descending order, for example $a_6^\dagger a_3^\dagger a_0^\dagger |0&gt;$. We only need anti-commute sufficiently to get an operator into it‚Äôs canonical position in the expression representing the state for example $a_3^\dagger a_6^\dagger a_5^\dagger a_4^\dagger a_0^\dagger |0&gt; = - a_6^\dagger a_5^\dagger a_4^\dagger a_3^\dagger a_0^\dagger |0&gt; $.
It‚Äôs complicated and it took me a couple tries to get the binary version of this right.</p>

<p>reshapeSite is a convenience function for reshaping the state vector so that the middle index is now specifying the filled or unfilled nature of site n.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">reshapeSite</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="c1">#returns state reshaped as (leftstatechanges(msb), occupy/unoccupied, rightstatechanges(lsb))
</span>    <span class="k">return</span> <span class="n">state</span><span class="p">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">**</span><span class="n">site</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">adag</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">reshapeSite</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>
    <span class="n">state</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">state</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">antiCommuteFactor</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>






</code></pre></div></div>

<p>We haven‚Äôt yet seen how to implement the anticommuting factor. This is where we need the Hamming weight function. We need to count the number of occupied states the the left of the particle (bits that are more significant than bit n). This is the number of adag operators we need to anticommute through to put the state into canonical ordering.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">antiCommuteFactor</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint64</span><span class="p">)</span>
    <span class="n">rightBinary</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">&gt;&gt;</span> <span class="n">site</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># shift out all the bits to the right
</span>    <span class="n">isOdd</span> <span class="o">=</span> <span class="n">popcount64c</span><span class="p">(</span><span class="n">rightBinary</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">isOdd</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">state</span>
</code></pre></div></div>

<p>I don‚Äôt want to use a bare ‚Äòa‚Äô for the annihilation operator. I used agad. So sue me. Otherwise it is very similar to adag.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">agad</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">reshapeSite</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>
    <span class="n">state</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span> <span class="c1">#turns 1 into a zero
</span>    <span class="n">state</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#nothing comes into the occupied state
</span>    <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">antiCommuteFactor</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>

</code></pre></div></div>

<p>Some other useful routines. A pretty printer avoids printing a bunch of zeros and puts it in bra ket notation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Num</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">reshapeSite</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>
    <span class="n">state</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#zero out if unoccupied
</span>    <span class="k">return</span> <span class="n">state</span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">prettyPrint</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">nsites</span><span class="p">):</span>
    <span class="c1">#avoids printing nearly zero, and puts in ket notation
</span>    <span class="n">returnstr</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">amp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">amp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="n">returnstr</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">amp</span><span class="p">)</span> <span class="o">+</span> <span class="s">" * |"</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">(</span><span class="n">index</span><span class="p">)[</span><span class="mi">2</span><span class="p">:].</span><span class="n">zfill</span><span class="p">(</span><span class="n">nsites</span><span class="p">)</span> <span class="o">+</span> <span class="s">"&gt; + "</span>
    <span class="k">return</span> <span class="n">returnstr</span> <span class="o">+</span> <span class="s">"0"</span>
</code></pre></div></div>

<p>Here we can see that alternate orderings of applying the operators give opposite signs out front.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">state1</span> <span class="o">=</span> <span class="n">adag</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">adag</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vac</span><span class="p">(</span><span class="n">NStates</span><span class="p">)))</span>
<span class="n">state2</span> <span class="o">=</span> <span class="n">adag</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">adag</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">vac</span><span class="p">(</span><span class="n">NStates</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">prettyPrint</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">NSites</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">prettyPrint</span><span class="p">(</span><span class="n">state2</span><span class="p">,</span> <span class="n">NSites</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0 * |000011&gt; + 0
-1.0 * |000011&gt; + 0
</code></pre></div></div>

<p>Now using these operators we could implement the application of a Hamiltonian fairly easily. We use the second quantized formulation of the single site Hamiltonian. The sum does it very every possible site.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">singleSiteH</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">NSites</span> <span class="c1">#modulo NSites to make periodic
</span>    <span class="k">return</span>      <span class="n">eps</span> <span class="o">*</span> <span class="n">Num</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">state</span><span class="p">)</span> <span class="o">+</span> \
                <span class="n">t</span> <span class="o">*</span> <span class="n">adag</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">agad</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">state</span><span class="p">))</span> <span class="o">+</span> \
                <span class="n">t</span> <span class="o">*</span> <span class="n">adag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">agad</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">state</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">H0</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">singleSiteH</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">state</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NSites</span><span class="p">)])</span>


</code></pre></div></div>

<p>Here we can compare the new way of applying H to the way at the beginning.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">state</span> <span class="o">=</span> <span class="n">adag</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">vac</span><span class="p">(</span><span class="n">NStates</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">prettyPrint</span><span class="p">((</span><span class="n">H0</span><span class="p">(</span><span class="n">state</span><span class="p">)),</span> <span class="n">NSites</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">oneH</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0 * |000001&gt; + 0.5 * |000010&gt; + 0.5 * |100000&gt; + 0
[ 1.   0.5  0.   0.   0.   0.5]
</code></pre></div></div>

<p>It is now possible to consider the interparticle interactions thought. This is something really new. We can unpack the binary string to a list of positions where it has a 1.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binaryToPositionList</span><span class="p">(</span><span class="n">occupation</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NSites</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">occupation</span> <span class="o">&gt;&gt;</span> <span class="n">site</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pos</span>
</code></pre></div></div>

<p>Given this position list it is striaghtforward to compute the energy of that configuration using a Coulomb $\frac{1}{r}$ potential for example.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="n">poslist</span><span class="p">):</span>
    <span class="n">U</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poslist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">U</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pos1</span> <span class="o">-</span> <span class="n">poslist</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">U</span>
</code></pre></div></div>

<p>In the occupation representation the potential V is actually a diagonal operator. This means we can use element wise multiplication to apply it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">applyV</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">V</span><span class="p">(</span><span class="n">binaryToPositionList</span><span class="p">(</span><span class="n">occ</span><span class="p">))</span> <span class="k">for</span> <span class="n">occ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NStates</span><span class="p">)])</span> <span class="o">*</span> <span class="n">state</span>
</code></pre></div></div>

<p>We can try it out. Indeed the two particles have energy $\frac{1}{4}$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">state</span> <span class="o">=</span> <span class="n">adag</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">adag</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">vac</span><span class="p">(</span><span class="n">NStates</span><span class="p">)))</span>
<span class="n">prettyPrint</span><span class="p">(</span><span class="n">applyV</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">NSites</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'0.25 * |010001&gt; + 0'
</code></pre></div></div>

<p>The total Hamiltonian is the sum of the single particle part and the interaction</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">H0</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">+</span> <span class="n">applyV</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prettyPrint</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">NSites</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'0.5 * |000101&gt; + 2.83333333333 * |001001&gt; + 0.5 * |001010&gt; + 2.75 * |010001&gt; + 0.5 * |010010&gt; + 0.5 * |100001&gt; + -0.5 * |101000&gt; + -0.5 * |110000&gt; + 0'
</code></pre></div></div>

<p>There we go. That‚Äôs a watershed moment!</p>

<p>Now, we‚Äôve only given ourselves the power to apply linear operators. True dense representation of the matrices would allow us to ask for inverse and eigenvalues and things.
But we can also approach perturbation theory which is designed to use only easy operations like multiplication. We‚Äôll examine that in the next part.</p>
:ET