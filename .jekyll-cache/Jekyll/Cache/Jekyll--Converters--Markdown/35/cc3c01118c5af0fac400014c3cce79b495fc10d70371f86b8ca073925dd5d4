I"˙<p>We need to build that back end baby. The butt so to speak. Where the action BE AT.</p>

<p>The idea is to have collaborative aiming of our laser across the internet.</p>

<p>Check it out¬†<a href="https://github.com/ishmandoo/laser">https://github.com/ishmandoo/laser</a></p>

<p>So we‚Äôre gonna docker this. Because we‚Äôre off the goddamn chain.</p>

<p>Ben already has some code on his github</p>

<p><a href="https://github.com/ishmandoo/multiplayer_test">https://github.com/ishmandoo/multiplayer_test</a></p>

<p>That we‚Äôre going to modify to our needs. He essentially used</p>

<p><a href="http://socket.io/get-started/chat">http://socket.io/get-started/chat</a>/ as a base level + some basic docker</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ubuntu

RUN apt-get update
RUN apt-get install -y nodejs
RUN apt-get install -y npm
RUN apt-get install -y git
RUN git clone https://github.com/ishmandoo/multiplayer_test.git
RUN cd multiplayer_test &amp;&amp; npm install

CMD ["nodejs", "multiplayer_test/server/server.js"]
</code></pre></div></div>

<p>So this already does what we need it to do basically. Just change the name of the git repository and it‚Äôll boot up the server.</p>

<p>check this out¬†<a href="https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images">https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images</a>¬†for more deets.</p>

<p>‚ÄúI built it with ¬†‚Äùdocker build -t laser .‚Äù</p>

<p>and ran it with ‚Äúdocker run -d -p 80:3000 laser‚Äù‚Äù- Ben</p>

<p>Okay, also technically we need a front end too, so</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch_events#Create_a_canvas">https://developer.mozilla.org/en-US/docs/Web/API/Touch_events#Create_a_canvas</a></p>

<p>duct taped together with the chat application and¬†<a href="http://stackoverflow.com/questions/4037212/html-canvas-full-screen">http://stackoverflow.com/questions/4037212/html-canvas-full-screen</a>¬†full screening.</p>

<p>We just need to tell the server when touch is down and where. We normalized x and y to be ratios of 0-1 fractions across the screen. It seems we can‚Äôt rely on not going a little over 1 maybe so be aware.</p>

<p>The Socket.io part is very straightforward.</p>

<p>The express stuffjust serves the ordinary webpages. (app.get)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var express = require('express');
var app = express();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function (req, res) {
  res.sendFile(__dirname + '/client/html/index.html');
});

app.use('/js', express.static(__dirname + '/client/js'));


io.on('connection', function(socket){
  console.log('a user connected');
  socket.pos = {x: 0, y:0}
  socket.touching = false;
  socket.updateTime = 0;


  socket.on('new pos', function (pos) {
    console.log(pos);
    socket.pos = pos;
    socket.touching = true;
    var date = new Date();
    socket.update_time = date.getTime();
  });

  socket.on('no touch', function (data) {
    console.log("no touch");
    socket.touching = false;
  });
});

app.get('/location', function(req, res){
  var pos = {x: 0, y: 0}
  var x_sum = 0;
  var y_sum = 0;
  var n_touching = 0;


  var date = new Date();
  var time = date.getTime();

  if (io.sockets) {
    var sockets = io.sockets.sockets;

    for (i = 0; i &lt; sockets.length; i++) {
      if ((sockets[i].touching) &amp;&amp; (time - sockets[i].update_time &lt; 10000)) {
        x_sum += sockets[i].pos.x;
        y_sum += sockets[i].pos.y;
        n_touching++;
      }
    }
  }

  if (n_touching &gt; 0){
    pos = {x: x_sum/n_touching, y: y_sum/n_touching}
  }

  //res.send(pos.x + ',' + pos.y);
  res.json(pos);
});

var server = http.listen(3000, function () {
  var host = server.address().address;
  var port = server.address().port;

  console.log('Example app listening at http://%s:%s', host, port);
});
</code></pre></div></div>

<p>The only thing kind of funky is storing data associated with each client. We just attach it to the socket object, which should be self cleaning to some degree. We also add a timeout just in case we somehow lose a touch end. Maybe unneccessary.</p>

<p>Polling the path /location will return json of the average position of everyone touching the screen.</p>

<p>All in all pretty straightforward. And it seems to work with our phones. Except not Beth.</p>

<p>Now onto the microcontroller code. Should be simple, but for some reason is not. We have to glue together a couple of things if we want to bolt the arduino to an esp8266. Alternatives are to go native on an esp8266 or use a Photon. It is bizarre to me that one of these is not a clear winner. Why is it not so incredibly easy to make http requests on the Photon?</p>

<p>Also, a comment: Being name the photon makes it impossible to search for you. It sounds cool, but it‚Äôs a bad name.</p>
:ET