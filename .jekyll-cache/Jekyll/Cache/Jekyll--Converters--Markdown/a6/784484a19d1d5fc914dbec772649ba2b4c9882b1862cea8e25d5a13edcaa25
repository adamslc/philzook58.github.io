I"9\<p><a href="https://en.wikipedia.org/wiki/Branch_and_bound">Branch and bound</a> is a useful problem solving technique. The idea is, if you have a minimization problem you want to solve, maybe there is a way to relax the constraints to an easier problem. If so, the solution of the easier problem is a lower bound on the possible solution of the hard problem. If the solution of the easier problem just so happens to also obey the more constrained hard problem, then it must also be the solution to the hard problem. You can also use the lower bound coming from a relaxed problem  to prune your search tree for the hard problem. If even the relaxed problem doesn’t beat the current best found, don’t bother going down that branch.</p>

<p>A standard place this paradigm occurs is in mixed integer programming. The relaxation of a binary constraint (either 0 or 1) can be all the values in between (any number between 0 and 1). If this relaxed problem can be expressed in a form amenable to a solver like a linear programming solver, you can use that to power the branch and bound search, also using returned solutions for possible heuristics.</p>

<p>I built a basic version of this that uses<a href="https://www.cvxpy.org/"> cvxpy</a> as the relaxed problem solver. Cvxpy already has much much faster mixed integer solvers baked in (which is useful to make sure mine is returning correct results), but it was an interesting exercise. The real reason I’m toying around is I kind of want the ability to add custom branching heuristics or inspect and maintain the branch and bound search tree, which you’d need to get into the more complicated guts of the solvers bound to cvxpy to get at. <a href="https://julialang.org/">Julia</a> might be a better choice.</p>

<p>A somewhat similar (and better) project is <a href="https://github.com/oxfordcontrol/miosqp">https://github.com/oxfordcontrol/miosqp</a> which doesn’t use cvxpy explicitly, but does have the branch and bound control in the python layer of the solver. There are also other projects that can use fairly arbitrary solvers like <a href="https://projects.coin-or.org/Bonmin">Bonmin</a></p>

<p>As a toy problem I’m using a knapsack problem where we have objects of different sizes and different values. We want to maximize the value while keeping the total size under the capacity of the bag. This can be phrased linearly like so: $ \max v \cdot x$ s.t. $ \sum_i s_i x_i&lt;= capacity $, $ x \in {0,1}$. The basic heuristic I’m using is to branch on variables that are either 0 or 1 in even the relaxed solution. The alternative branch hopefully gets pruned fast.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="n">cvx</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> 

<span class="k">class</span> <span class="nc">BBTreeNode</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="n">constraints</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">objective</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bool_vars</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">vars</span> <span class="o">=</span> <span class="nb">vars</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">constraints</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">objective</span> <span class="o">=</span> <span class="n">objective</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bool_vars</span> <span class="o">=</span> <span class="n">bool_vars</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">buildProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cvx</span><span class="p">.</span><span class="n">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">objective</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">constraints</span><span class="p">)</span> <span class="c1">#i put Minimize, just so you know that I'm assuming it
</span>        <span class="k">return</span> <span class="n">prob</span>
    <span class="k">def</span> <span class="nf">is_integral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-3</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-3</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">bool_vars</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">branch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1">#yeesh. Not good performance wise, but is simple implementation-wise
</span>                <span class="n">v</span> <span class="o">=</span> <span class="n">n1</span><span class="p">.</span><span class="n">heuristic</span><span class="p">()</span> <span class="c1">#dangerous what if they don't do the same one? I need to do it here though because I need access to copied v.
</span>                <span class="n">n1</span><span class="p">.</span><span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">v</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span> <span class="c1"># add in the new binary constraint
</span>                <span class="n">n1</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">n1</span><span class="p">.</span><span class="n">bool_vars</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c1">#remove binary constraint from bool var set
</span>                <span class="n">n1</span><span class="p">.</span><span class="nb">vars</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c1">#and add it into var set for later inspection of answer
</span>                <span class="c1">#self.children.append(n1)   # eventually I might want to keep around the entire search tree. I messed this up though
</span>                <span class="n">children</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>             
        <span class="k">return</span> <span class="n">children</span>
    <span class="k">def</span> <span class="nf">heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># a basic heuristic of taking the ones it seems pretty sure about
</span>        <span class="k">return</span> <span class="nb">min</span><span class="p">([(</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bool_vars</span><span class="p">)])[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">bbsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">buildProblem</span><span class="p">().</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="n">res</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">),</span> <span class="n">root</span><span class="p">)]</span>
        <span class="n">bestres</span> <span class="o">=</span> <span class="mf">1e20</span> <span class="c1"># a big arbitrary initial best objective value
</span>        <span class="n">bestnode</span> <span class="o">=</span> <span class="n">root</span> <span class="c1"># initialize bestnode to the root
</span>        <span class="k">print</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="n">nodecount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">nodecount</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># for statistics
</span>            <span class="k">print</span><span class="p">(</span><span class="s">"Heap Size: "</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">buildProblem</span><span class="p">()</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">prob</span><span class="p">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Result: "</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prob</span><span class="p">.</span><span class="n">status</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">"infeasible"</span><span class="p">,</span> <span class="s">"unbounded"</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="n">bestres</span> <span class="o">-</span> <span class="mf">1e-3</span><span class="p">:</span> <span class="c1">#even the relaxed problem sucks. forget about this branch then
</span>                    <span class="k">print</span><span class="p">(</span><span class="s">"Relaxed Problem Stinks. Killing this branch."</span><span class="p">)</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">is_integral</span><span class="p">():</span> <span class="c1">#if a valid solution then this is the new best
</span>                        <span class="k">print</span><span class="p">(</span><span class="s">"New Best Integral solution."</span><span class="p">)</span>
                        <span class="n">bestres</span> <span class="o">=</span> <span class="n">res</span>
                        <span class="n">bestnode</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#otherwise, we're unsure if this branch holds promise. Maybe it can't actually achieve this lower bound. So branch into it
</span>                    <span class="n">new_nodes</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">branch</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">new_node</span> <span class="ow">in</span> <span class="n">new_nodes</span><span class="p">:</span>
                        <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">),</span> <span class="n">new_node</span> <span class="p">)</span> <span class="p">)</span>  <span class="c1"># using counter to avoid possible comparisons between nodes. It tie breaks
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"Nodes searched: "</span><span class="p">,</span> <span class="n">nodecount</span><span class="p">)</span>      
        <span class="k">return</span> <span class="n">bestres</span><span class="p">,</span> <span class="n">bestnode</span>

<span class="c1"># a simple knapsack problem. we'll want to minimize the total cost of having each of these items, with different sizes.
# Use a random problem instance
</span><span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">prices</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">]</span> <span class="c1">#The relaxation of the binary variable constraint
</span><span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sizes</span><span class="o">*</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">]</span> <span class="c1"># total size of knapsack is 5
</span><span class="n">objective</span> <span class="o">=</span> <span class="n">prices</span> <span class="o">*</span> <span class="n">x</span>
<span class="n">bool_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)}</span> 
<span class="n">root</span> <span class="o">=</span> <span class="n">BBTreeNode</span><span class="p">(</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">objective</span><span class="o">=</span> <span class="n">objective</span><span class="p">,</span> <span class="n">bool_vars</span> <span class="o">=</span> <span class="n">bool_vars</span><span class="p">)</span>
<span class="n">res</span><span class="p">,</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">bbsolve</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">([(</span><span class="n">v</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">.</span><span class="n">bool_vars</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">v</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">.</span><span class="nb">vars</span><span class="p">]</span> <span class="p">)</span> <span class="p">))</span>

<span class="c1"># For comparison let's do the same problem using a built in mixed integer solver.
</span><span class="n">x</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">]</span>
<span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sizes</span><span class="o">*</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">objective</span> <span class="o">=</span> <span class="n">prices</span> <span class="o">*</span> <span class="n">x</span>
<span class="n">prob</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cvx</span><span class="p">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">),</span><span class="n">constraints</span><span class="p">)</span>
<span class="n">prob</span><span class="p">.</span><span class="n">solve</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<p>This is at least solving the problem fairly quickly. It needs better heuristics and to be sped up, which is possible in lots of ways. I was not trying to avoid all performance optimizations. It takes maybe 5 seconds, whereas the cvxpy solver is almost instantaneous.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Nodes searched:  67
[('var0[0]', 0.9999999958228145), ('var0[10]', -1.2718338055950193e-08), ('var0[11]', -1.3726395012104872e-08), ('var0[12]', 0.9999999982326986), ('var0[13]', 0.9999999973744331), ('var0[14]', 0.9999999988156902), ('var0[15]', -1.1908085711772973e-08), ('var0[16]', 0.9999999903780872), ('var0[17]', 0.9999999863334883), ('var0[18]', -1.1481655920777931e-08), ('var0[19]', 0.9999999996667646), ('var0[1]', 0.9999999969549299), ('var0[2]', 0.9999999979596141), ('var0[3]', -9.282428548104736e-09), ('var0[4]', -1.1378022795740783e-08), ('var0[5]', 0.9999999868240312), ('var0[6]', 0.9999999995068807), ('var0[7]', 0.9999999995399617), ('var0[8]', 0.9999999859520627), ('var0[9]', 0.9999999948062767)]
[ 1.00000000e+00  1.00000000e+00  1.00000000e+00 -1.44435650e-12
 -1.88491321e-12  1.00000000e+00  1.00000000e+00  1.00000000e+00
  1.00000000e+00  1.00000000e+00 -7.11338729e-13  1.99240081e-13
  1.00000000e+00  1.00000000e+00  1.00000000e+00 -1.48697107e-12
  1.00000000e+00  1.00000000e+00 -1.75111698e-12  1.00000000e+00]
</code></pre></div></div>

<p>Edit : I should investigate the Parameter functionality of cvxpy. That would make a make faster version than the one above based on deepcopy. If you made the upper and lower vectors on the binary variables parameters, you could restrict the interval to 0/1 without rebuilding the problem or copying everything.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#rough sketch
b = cvx.Variable(N) 
u = cvx.Parameter(N) 
u.value = np.ones(N)
l = cvx.Parameter(N) 
l.value = np.zeros(N)
constraints += [b &lt;= u, l &lt;= b]
# change l.value and u.value in search loop.
</code></pre></div></div>

:ET