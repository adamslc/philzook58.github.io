I"œK<p>The coulomb gas is a model of electrostatics where you take the discreteness of charge into account. That is what makes it hard compared to the continuous charge problem. Previously, Iâ€™ve used mixed integer programming to find lowest energy states of the<a href="http://www.philipzucker.com/solving-the-ising-model-using-a-mixed-integer-linear-program-solver-gurobi/"> ising model</a>.  This is even more obvious application of mixed integer programming to a physics model.</p>

<p>We ordinarily consider electric charge to be a continuum, but it isnâ€™t. It comes in chunks of the electron charge. Historically, people didnâ€™t even know that for quite a while. It is usually a reasonable approximation for most purposes to consider electric charge to be continuous</p>

<p>If you consider a network of capacitors cooled to the the level that there is not enough thermal energy to borrow to get an electron to jump, the charges on the capacitors will be <a href="https://en.wikipedia.org/wiki/Coulomb_blockade">observably discretized</a>. With a sufficiently slow cooling to this state, the charges should arrange themselves into the lowest energy state.</p>

<p>The coulomb gas model also is of interest due to its connections to the XY model, <a href="http://www.philipzucker.com/solving-the-xy-model-using-mixed-integer-optimization-in-python/">which Iâ€™ve taken a stab at with mixed integer programming before</a>. The coulomb gas models the energy of vortices in that model. I think the connection between the models actually requires a statistical or quantum mechanical context though, whereas weâ€™ve been looking at the classical energy minimization.</p>

<p>We can formulate the classical coulomb gas problem very straightforwardly as a mixed integer quadratic program. We can easily include an externally applied field and a charge conservation constraint if we so desire within the framework.</p>

<p>We write this down in python using the cvxpy library, which has a built in free MIQP solver, albeit not a very good one. Commercial solvers are probably quite a bit better.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="n">cvx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="c1">#grid size
</span><span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>
<span class="c1"># charge variables
</span><span class="n">q</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span> <span class="n">N</span><span class="o">*</span><span class="n">N</span> <span class="p">,</span><span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># build our grid
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> 
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> 
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s">'ij'</span><span class="p">)</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">Y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">Y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="n">N</span> <span class="c1">#regularization factor for self energy. convenience mostly
</span><span class="n">V</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">((</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">eps</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span> <span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="p">)</span>

<span class="n">U_external</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">Y</span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c1"># a constant electric field in the Y direction 
</span><span class="n">energy</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">quad_form</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">V</span><span class="p">)</span> <span class="o">+</span> <span class="n">U_external</span><span class="o">*</span><span class="n">q</span>

<span class="c1"># charge conservation constraint
</span><span class="n">prob</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cvx</span><span class="p">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">energy</span><span class="p">),[</span><span class="n">cvx</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">])</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">prob</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)))</span>

<span class="c1">#plotting junk
</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>  
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s">'3d'</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/coulomb-1-1024x768.png" alt="" />A plot of charge in a constant external electric field.</p>

<p>The results seems reasonable. It makes sense for charge to go in the direction of the electric field. Going to the corners makes sense because then like charges are far apart. So this might be working. Who knows.</p>

<h3 id="interesting-places-to-go-with-this">Interesting places to go with this:</h3>

<p>Prof Vanderbei shows how you can embed an <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">FFT </a>to enable making statements about both the time and frequency domain while keeping the problem sparse. The low time/memory $ N log(N) $ complexity of the FFT is reflected in the spasity of the resulting linear program.</p>

<p><a href="https://vanderbei.princeton.edu/tex/ffOpt/ffOptMPCrev4.pdf">https://vanderbei.princeton.edu/tex/ffOpt/ffOptMPCrev4.pdf</a></p>

<p>Hereâ€™s a sketch about what this might look like. Curiously, looking at the actual number of nonzeros in the problem matrices, there are way too many. I am not sure what is going on. Something is not performing as i expect in the following code</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="n">cvx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="c1"># import fft, ifft
</span><span class="k">def</span> <span class="nf">swizzle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">size</span>
    <span class="n">s</span> <span class="o">=</span>  <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2.j</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="c1">#print(s)
</span>    <span class="c1">#ret = cvx.hstack( [x + s*y, x - s*y]) 
</span>    <span class="c1">#print(ret.shape)
</span>    <span class="k">return</span> <span class="n">cvx</span><span class="p">.</span><span class="n">hstack</span><span class="p">(</span> <span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">y</span><span class="p">])</span> 


<span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">size</span>
    <span class="c1">#assert(2**int(log2(N)) == N) # power of 2
</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">even</span><span class="p">,</span> <span class="n">ce</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="n">ce</span>
        <span class="n">odd</span><span class="p">,</span> <span class="n">co</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="n">co</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="p">[</span><span class="n">z</span> <span class="o">==</span> <span class="n">swizzle</span><span class="p">(</span><span class="n">even</span><span class="p">,</span><span class="n">odd</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">z</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1">#np.ones(N) #np.random.rand(N)
</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span>
<span class="n">c</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span> <span class="o">==</span> <span class="n">v</span><span class="p">]</span>
<span class="n">prob</span> <span class="o">=</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Problem</span><span class="p">(</span> <span class="n">cvx</span><span class="p">.</span><span class="n">Minimize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">#print(prob.get_problem_data(cvx.OSQP))
</span><span class="n">res</span> <span class="o">=</span> <span class="n">prob</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1">#print(x.value)
</span><span class="k">print</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">scipy</span><span class="p">.</span><span class="n">fftpack</span><span class="p">.</span><span class="n">fft</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">scipy</span><span class="p">.</span><span class="n">fftpack</span><span class="p">.</span><span class="n">fft</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<p>The equivalent dense DFT:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
x = cvx.Variable(N, complex=True)
fred = cvx.Variable(N, complex=True)
c = [fred == np.exp(-2.j * np.pi * np.arange(N).reshape((N,1)) * np.arange(N).reshape((1,N)) / N) * x]
prob = cvx.Problem( cvx.Minimize(1), c)
print(prob.get_problem_data(cvx.OSQP))
</code></pre></div></div>

<p>It would be possible to use a frequency domain solution of the interparticle energy rather than the explicit coulomb law form. Hypothetically this might increase the sparsity of the problem.</p>

<p>It seems very possible to me in a similar manner to embed a fast multipole method or barnes-hut approximation within a MIQP. Introducing explicit charge summary variables for blocks would create a sparse version of the interaction matrix. So thatâ€™s fun.</p>

:ET