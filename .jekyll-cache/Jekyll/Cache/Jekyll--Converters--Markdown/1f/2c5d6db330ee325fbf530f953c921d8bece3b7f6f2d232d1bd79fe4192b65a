I" <p>We saw this cool Sol LeWitt wall at MASS MoCA. It did not escape our attention that it was basically an eikonal equation and that the weird junctures were caustic lines.</p>

<p>It was drawn with alternating colored marker lines appearing a cm away from the previous line. This is basically Huygens principal.</p>

<p>So I hacked together a demo in elm. Elm is a Haskell-ish language for the web.</p>

<p><img src="http://2.bp.blogspot.com/-m51gLYwv_ek/U_s-VGVmq-I/AAAAAAAABmo/cl7hJUjPgZA/s1600/P8080223.jpg" alt="" /></p>

<p>So I made a quick rip and run elm program to do this. This is the output, which I could make more dynamic.</p>

<p>The algorithm is to turn a list of points into their connecting lines. Then move the line perpendicular to itself, then recompute the new intersection points. It’s somewhat reminiscent of Verlet integration. Lines coordinates are momentum-like and points are position like and we alternate them. This is a finite difference version of the geometric Huygen’s principle.</p>

<p>Alternative methods which might work better include the Fast Marching Method or just using the wave equation and then plotting iso surfaces.</p>

<p>I also had to resample the function to get only the maximum y value for each x value in order to duplicate the LeWitt effect.</p>

<p><a href="http://www.philipzucker.com/wp-content/uploads/2017/08/sol.png"><img src="http://www.philipzucker.com/wp-content/uploads/2017/08/sol-300x300.png" alt="sol" /></a></p>

<p>These are the helper functions with lots of junk in there</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module LineHelpers exposing (..)
-- Maybe should just be doubles or nums

import Debug

fromJust : Maybe a -&gt; a
fromJust x = case x of
    Just y -&gt; y
    Nothing -&gt; Debug.crash "error: fromJust Nothing"

toPointString : List (number, number) -&gt; String
toPointString xs =
  case xs of
    (x,y) :: ys -&gt; (toString x) ++ "," ++ (toString y) ++ " " ++ (toPointString ys)
    _ -&gt; ""



crossProd : (number,number,number) -&gt; (number,number,number) -&gt; (number,number,number)
crossProd (a,b,c) (d,e,f) = (b * f - c * e, c * d - a * f, a * e - b * d)


type alias PointListH number = List (number,number,number)
type alias LineListH number = List (number,number,number)


-- gives the mapping function the list and the list shifted by 1
neighbormap f a = let a_ = fromJust (List.tail a) in List.map2 f a a_


crossNeighbor = neighbormap crossProd

norm a b = sqrt (a * a + b * b)
shiftLine delta (a,b,c)  = (a,b, (norm a b) * delta + c)

connectingLines = crossNeighbor
shiftLines delta = List.map (shiftLine delta)
intersections = crossNeighbor


-- nearly striaght lines will find their intersection at infinity.
-- maybe filter out a lower threshold on c
-- keep first and last point
last xs = let l = List.length xs in fromJust (List.head (List.drop (l - 1) xs))

timestep : Float -&gt; List (Float,Float, Float) -&gt; List (Float,Float, Float)
timestep delta points = let
        firstpoint = fromJust (List.head points)
        lastpoint = last points
        connectlines = connectingLines points
        newlines = shiftLines delta connectlines
        newpoints = intersections newlines
        filterednewpoints = List.filter (\(a,b,c) -&gt; (abs c) &gt; 0.01) newpoints
        normpoints = List.map normalize filterednewpoints
        result = firstpoint :: (normpoints ++ [lastpoint])
        resample = List.map (maxfunc (List.map dehomogenize result)) initx
        --result2 = removeoutoforder (-100000, 0,00) result
          in List.map homogenize (zip initx resample)


homogenize (a,b) = (a,b,1)
dehomogenize (a,b,c) = (a / c, b / c)
normalize = dehomogenize &gt;&gt; homogenize

zip = List.map2 (,)

initx = List.map (toFloat &gt;&gt;((*) 4.5)) (List.range -200 400)
--inity = List.map (\x -&gt; x * x / 50) initx
--inity = List.map (\x -&gt; 300 + x * x / -50) initx
--inity = List.map (\x -&gt; 25 * sin (x / 20) + 250) initx
inity = List.map (\x -&gt; 25 * sin (x / 20) + 250 + 15 * sin (x/13)) initx
initxy = zip initx inity
initxyh = List.map homogenize initxy


iterate n f x = if n == 0 then [] else (f x) :: iterate (n - 1) f (f x)

paths = (List.map &lt;&lt; List.map) dehomogenize (iterate 60 (timestep 5.0) initxyh)

colors = List.concat (List.repeat (List.length paths) ["red", "blue", "yellow"] )

removeoutoforder prev xs = case xs of
          y :: ys -&gt; if prev &lt; y then (y :: removeoutoforder y ys) else removeoutoforder prev ys
          _ -&gt; []

neighborzip a = let a_ = fromJust (List.tail a) in zip a a_
linearinterp x ((x1,y1), (x2,y2)) = (y1 * (x2 - x) + y2 * (x - x1)) / (x2 - x1)
maxfunc : List (Float, Float) -&gt; Float -&gt; Float
maxfunc points x = let
        pairs = neighborzip points

        filterfunc ((x1,y1), (x2,y2)) = (xor (x &lt; x1) (x &lt; x2))
        candidates = List.filter filterfunc pairs
        yvals = List.map (linearinterp x) candidates in Maybe.withDefault 100 (List.maximum yvals)
</code></pre></div></div>

<p>And this is the svg main program.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)
import Svg exposing (..)
import Svg.Attributes exposing (..)
import LineHelpers exposing (..)

roundRect : Html.Html msg
roundRect =
    svg
      [ width "1000", height "1000",viewBox "-100 0 350 350" ]
      (List.reverse ([--[ rect [ x "10", y "10", width "100", height "100", rx "15", ry "15" ] [],
      -- polyline [ fill "none", stroke "red", points "20,100 40,60 70,80 100,20" ] [],
       polyline [ fill "none", stroke "black", strokeWidth "5.0", points (LineHelpers.toPointString LineHelpers.initxy) ] []] ++
         (List.map2 (\path color -&gt; polyline [ fill "none", stroke color, strokeWidth "3.0", points (LineHelpers.toPointString path)] []) LineHelpers.paths LineHelpers.colors)))




main =
  Html.beginnerProgram { model = model, view = view, update = update }


-- MODEL

type alias Model = Int

model : Model
model =
  0


-- UPDATE

type Msg = Increment | Decrement

update : Msg -&gt; Model -&gt; Model
update msg model =
  case msg of
    Increment -&gt;
      model + 1

    Decrement -&gt;
      model - 1


-- VIEW

view : Model -&gt; Html Msg
view model =
  div []
    [ button [ onClick Decrement ] [ Html.text "-" ]
    , div [] [ Html.text (toString model) ]
    , button [ onClick Increment ] [ Html.text "+" ],
    roundRect
    ]
</code></pre></div></div>

<p>notes on elm</p>

<p>elm is installed with npm</p>

<p>elm-repl</p>

<p>you import packages (including your own) with</p>

<p>import ThisPackage</p>

<p>and you check types by just writing them and hitting enter rather than :t</p>

<p>elm-live is a very handy thing. A live reloading server that watches for changes in your files.</p>

<p>elm-make myfile.elm</p>

<p>will generate the javascript and html</p>

<p><a href="https://guide.elm-lang.org/">This</a> is a good tutorial and a good snippet to get you going</p>

<p>Differences from Haskell:</p>

<p>elm isn’t lazy which is probably good.</p>

<p>The composition operator (.) is now «</p>

<p>elm doesn’t have the multiline pattern match of haskell. You need  to use case expressions. I miss them.</p>

<p>typeclass facilities are not emphasized.</p>

<p>The list type is List a rather than [a]</p>

:ET