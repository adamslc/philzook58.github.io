I"ÁÅ<p>That‚Äôs a mouthful.</p>

<p>Lens are described as<a href="http://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html"> functional getters and setters</a>. The simple lens type is ``</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">Lens</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>. The setter is</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div></div>

<p>and the getter is</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>This type does not constrain lenses to obey the usual laws of getters and setters. So we can use/abuse lens structures for nontrivial computations that have forward and backwards passes that share information. <a href="https://julesh.com/">Jules Hedges</a> is particular seems to be a proponent for this idea.</p>

<p>I‚Äôve described before how to <a href="http://www.philipzucker.com/reverse-mode-differentiation-is-kind-of-like-a-lens-ii/">encode reverse mode automatic differentiation</a> in this style. I have suspicions that you can make iterative LQR and guass-seidel iteration have this flavor too, but I‚Äôm not super sure. My attempts ended somewhat <a href="https://github.com/philzook58/ConvexCat/blob/master/src/Lib.hs">unsatisfactorily</a> a whiles back but I think it‚Äôs not hopeless. The trouble was that you usually want the whole vector back, not just its ends.</p>

<p>I‚Äôve got another example in imperative program analysis that kind of makes sense and might be useful though. Toy repo here: <a href="https://github.com/philzook58/wp-lens">https://github.com/philzook58/wp-lens</a></p>

<p>In program analysis it sometimes helps to run a program both concretely and symbolically. <a href="https://en.wikipedia.org/wiki/Concolic_testing">Concolic</a> = CONCrete / symbOLIC. Symbolic stuff can slowly find hard things and concrete execution just sprays super fast and can find the dumb things really quick.</p>

<p>We can use a lens structure to organize a DSL for describing a simple imperative language</p>

<p>The forward pass is for the concrete execution. The backward pass is for transforming the post condition to a pre condition in a <a href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics">weakest precondition analysis</a>. Weakest precondition semantics is a way of specifying what is occurring in an imperative language. It tells how each statement transforms post conditions (predicates about the state after the execution) into pre conditions (predicates about before the execution). The concrete execution helps unroll loops and avoid branching if-then-else behavior that would make the symbolic stuff harder to process. I‚Äôve been flipping through <a href="https://seriouscomputerist.atariverse.com/media/pdf/book/Discipline%20of%20Programming.pdf">Djikstra‚Äôs book </a>on this. Interesting stuff, interesting man.</p>

<p>I often think of a state machine as a function taking <code class="language-plaintext highlighter-rouge">s -&gt; s</code>. However, this is kind of restrictive. It is possible to have heterogenous transformations <code class="language-plaintext highlighter-rouge">s -&gt; s'</code>. Why not? I think I am often thinking about finite state machines, which we really don‚Äôt intend to have a changing state size. Perhaps we allocated new memory or something or brought something into or out of scope. We could model this by assuming the memory was always there, but it seems wasteful and perhaps confusing. We need to a priori know everything we will need, which seems like it might break compositionally.</p>

<p>We could <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Imp.html">model our language</a> making some data type like<br />
<code class="language-plaintext highlighter-rouge">data Imp = Skip | Print String | Assign String Expr | Seq Imp Imp | ...</code><br />
and then build an interpreter</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">interp</span> <span class="o">::</span> <span class="kt">Imp</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s'</span>
</code></pre></div></div>

<p><img src="/assets/Imp-01.jpg" alt="Imp." /></p>

<p>But we can also cut out the middle man and directly define our language using combinators.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span><span class="n">s'</span>
</code></pre></div></div>

<p>To me this has some flavor of a finally tagless style.</p>

<p>Likewise for expressions. Expressions evaluate to something in the context of the state (they can lookup variables), so let‚Äôs just use</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>And, confusingly (sorry), I think it makes sense to use Lens in their original getter/setter intent for variables. So Lens structure is playing double duty.</p>

<p><code class="language-plaintext highlighter-rouge">type Var s a = Lens' s a</code></p>

<p>With that said, here we go.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kr">type</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s'</span> 
<span class="kr">type</span> <span class="kt">Lens'</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="n">set</span> <span class="n">l</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span> <span class="n">s</span> <span class="kr">in</span> <span class="n">f</span> <span class="n">a</span>

<span class="kr">type</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Lens'</span> <span class="n">s</span> <span class="n">a</span>

<span class="n">skip</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">skip</span> <span class="o">=</span> <span class="n">id</span>

<span class="n">sequence</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s'</span> <span class="n">s''</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s''</span>
<span class="n">sequence</span> <span class="o">=</span> <span class="n">flip</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>

<span class="n">assign</span> <span class="o">::</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">assign</span> <span class="n">v</span> <span class="n">e</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="n">v</span> <span class="n">s</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span>

<span class="p">(</span><span class="o">===</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">v</span> <span class="o">===</span> <span class="n">e</span> <span class="o">=</span> <span class="n">assign</span> <span class="n">v</span> <span class="n">e</span>

<span class="n">ite</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span>
<span class="n">ite</span> <span class="n">e</span> <span class="n">stmt1</span> <span class="n">stmt2</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span> <span class="kr">then</span> <span class="n">stmt1</span> <span class="n">s</span> <span class="kr">else</span> <span class="n">stmt2</span> <span class="n">s</span>

<span class="n">while</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">while</span> <span class="n">e</span> <span class="n">stmt</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span> <span class="kr">then</span> <span class="p">((</span><span class="n">while</span> <span class="n">e</span> <span class="n">stmt</span><span class="p">)</span> <span class="p">(</span><span class="n">stmt</span> <span class="n">s</span><span class="p">))</span> <span class="kr">else</span> <span class="n">s</span>

<span class="n">assert</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>  
<span class="n">assert</span> <span class="n">e</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span> <span class="kr">then</span> <span class="n">s</span> <span class="kr">else</span> <span class="n">undefined</span> 

<span class="n">abort</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span>  
<span class="n">abort</span> <span class="o">=</span> <span class="n">const</span> <span class="n">undefined</span>

</code></pre></div></div>

<p>Weakest precondition can be done similarly, instead we start from the end and work backwards</p>

<p>Predicates are roughly sets. A simple type for sets is</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">Pred</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p>Now, this doesn‚Äôt have much deductive power, but I think it demonstrates the principles simply. We could replace <code class="language-plaintext highlighter-rouge">Pred</code> with perhaps an SMT solver expression, or some data type for predicates, for which we‚Äôll need to implement things like substitution. Let‚Äôs not today.</p>

<p>A function</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div></div>

<p>is equivalent to</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">forall</span> <span class="n">c</span><span class="o">.</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div>

<p>. This is some kind of CPS / Yoneda transformation thing. A state transformer</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s'</span>
</code></pre></div></div>

<p>to predicate transformer</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">(</span><span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</code></pre></div></div>

<p>is somewhat evocative of that. I‚Äôm not being very precise here at all.</p>

<p>Without further ado, here‚Äôs how I think a weakest precondition looks roughly.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kr">type</span> <span class="kt">Lens'</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="n">set</span> <span class="n">l</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span> <span class="n">s</span> <span class="kr">in</span> <span class="n">f</span> <span class="n">a</span>

<span class="kr">type</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Lens'</span> <span class="n">s</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Pred</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="kr">type</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">=</span> <span class="kt">Pred</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Pred</span> <span class="n">s</span> 

<span class="n">skip</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">skip</span> <span class="o">=</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">post</span> <span class="kr">in</span> <span class="n">pre</span> <span class="c1">-- if</span>

<span class="n">sequence</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s'</span> <span class="n">s''</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s''</span>
<span class="n">sequence</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>

<span class="n">assign</span> <span class="o">::</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">assign</span> <span class="n">v</span> <span class="n">e</span> <span class="o">=</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">pre</span> <span class="n">s</span> <span class="o">=</span> <span class="n">post</span> <span class="p">(</span><span class="n">set</span> <span class="n">v</span> <span class="n">s</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">))</span> <span class="kr">in</span> <span class="n">pre</span>

<span class="p">(</span><span class="o">===</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">v</span> <span class="o">===</span> <span class="n">e</span> <span class="o">=</span> <span class="n">assign</span> <span class="n">v</span> <span class="n">e</span>

<span class="n">ite</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span>
<span class="n">ite</span> <span class="n">e</span> <span class="n">stmt1</span> <span class="n">stmt2</span> <span class="o">=</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">pre</span> <span class="n">s</span> <span class="o">=</span> <span class="kr">if</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="n">stmt1</span> <span class="n">post</span><span class="p">)</span> <span class="n">s</span> <span class="kr">else</span> <span class="p">(</span><span class="n">stmt2</span> <span class="n">post</span><span class="p">)</span> <span class="n">s</span> <span class="kr">in</span> <span class="n">pre</span>

<span class="n">abort</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span>  
<span class="n">abort</span> <span class="o">=</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="n">const</span> <span class="kt">False</span>

<span class="n">assert</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>  
<span class="n">assert</span> <span class="n">e</span> <span class="o">=</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">pre</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">post</span> <span class="n">s</span><span class="p">)</span> <span class="kr">in</span> <span class="n">pre</span>

<span class="cm">{-
-- tougher. Needs loop invariant
while :: Expr s Bool -&gt; Stmt s s -&gt; Stmt s s
while e stmt = \post -&gt; let pre s = if (e s) then ((while e stmt) (stmt post)) s else  in pre
-}</span>


</code></pre></div></div>

<p>Finally here is a combination of the two above that uses the branching structure of the concrete execution to aid construction of the precondition. Although I haven‚Äôt expanded it out, we are using the full <code class="language-plaintext highlighter-rouge">s t a b</code> parametrization of lens in the sense that states go forward and predicates come back.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kr">type</span> <span class="kt">Lens'</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="n">set</span> <span class="n">l</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span> <span class="n">s</span> <span class="kr">in</span> <span class="n">f</span> <span class="n">a</span>


<span class="kr">type</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Lens'</span> <span class="n">s</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Pred</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="kr">type</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="kt">Pred</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Pred</span> <span class="n">s</span><span class="p">)</span> <span class="c1">-- eh. Screw the newtype</span>

<span class="n">skip</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">skip</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>


<span class="n">sequence</span> <span class="o">::</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s'</span> <span class="n">s''</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s''</span>
<span class="n">sequence</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span>   <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">s</span> <span class="kr">in</span>
                       <span class="kr">let</span> <span class="p">(</span><span class="n">s''</span><span class="p">,</span> <span class="n">j'</span><span class="p">)</span> <span class="o">=</span> <span class="n">g</span> <span class="n">s'</span> <span class="kr">in</span>
                           <span class="p">(</span><span class="n">s''</span><span class="p">,</span> <span class="n">j</span> <span class="o">.</span> <span class="n">j'</span><span class="p">)</span>
<span class="n">assign</span> <span class="o">::</span> <span class="kt">Var</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">assign</span> <span class="n">v</span> <span class="n">e</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">set</span> <span class="n">v</span> <span class="n">s</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">),</span> <span class="nf">\</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="p">(</span><span class="n">set</span> <span class="n">v</span> <span class="n">s</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)))</span>

<span class="c1">--if then else</span>
<span class="n">ite</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s'</span>
<span class="n">ite</span> <span class="n">e</span> <span class="n">stmt1</span> <span class="n">stmt2</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> 
                    <span class="kr">if</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span> 
                    <span class="kr">then</span> <span class="kr">let</span> <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="n">wp</span><span class="p">)</span> <span class="o">=</span> <span class="n">stmt1</span> <span class="n">s</span> <span class="kr">in</span>
                         <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">wp</span> <span class="n">post</span> <span class="n">s</span><span class="p">))</span>
                    <span class="kr">else</span> <span class="kr">let</span> <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="n">wp</span><span class="p">)</span> <span class="o">=</span> <span class="n">stmt2</span> <span class="n">s</span> <span class="kr">in</span>
                            <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">e</span> <span class="n">s</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">wp</span> <span class="n">post</span> <span class="n">s</span><span class="p">))</span>

<span class="n">assert</span> <span class="o">::</span> <span class="kt">Pred</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">assert</span> <span class="n">p</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">pre</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">post</span> <span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span> <span class="n">s</span><span class="p">)</span> <span class="kr">in</span> <span class="n">pre</span><span class="p">)</span>

<span class="n">while</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="n">s</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Stmt</span> <span class="n">s</span> <span class="n">s</span>
<span class="n">while</span> <span class="n">e</span> <span class="n">stmt</span> <span class="o">=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">e</span> <span class="n">s</span> <span class="kr">then</span> <span class="kr">let</span> <span class="p">(</span><span class="n">s'</span> <span class="p">,</span> <span class="n">wp</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">while</span> <span class="n">e</span> <span class="n">stmt</span><span class="p">)</span> <span class="n">s</span> <span class="kr">in</span>
                                 <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="nf">\</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">pre</span> <span class="n">s''</span> <span class="o">=</span> <span class="p">(</span><span class="n">post</span> <span class="n">s''</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">wp</span> <span class="n">post</span> <span class="n">s''</span><span class="p">)</span> <span class="kr">in</span> <span class="n">pre</span><span class="p">)</span>   
                            <span class="kr">else</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nf">\</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="p">)</span>

<span class="cm">{-

-- declare and forget can change the size and shape of the state space.
-- These are heterogenous state commpands
declare :: Iso (s,Int) s' -&gt; Int -&gt; Stmt s s'   
declare iso defalt = (\s -&gt; to iso (s, defalt), \p -&gt; \s -&gt; p $ to iso (s, defalt)) 

forget :: Lens' s s' -&gt; Stmt s s' -- forgets a chunk of state

declare_bracket :: Iso (s,Int) s' -&gt; Int -&gt;  Stmt s' s' -&gt; Stmt s s
declare_bracket iso defalt stmt = (declare iso default) . stmt . (forget (_1 . iso))

</span></code></pre></div></div>

<p>Neat. Useful? Me dunno.</p>

:ET