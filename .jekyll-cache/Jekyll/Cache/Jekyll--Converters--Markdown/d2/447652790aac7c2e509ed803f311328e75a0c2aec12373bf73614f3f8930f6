I"öÁ<p>Edit: Itâ€™s up! <a href="https://learnxinyminutes.com/docs/coq/">https://learnxinyminutes.com/docs/coq/</a></p>

<p>Iâ€™ve been preparing a Learn X in Y tutorial for Coq. <a href="https://learnxinyminutes.com/">https://learnxinyminutes.com/</a></p>

<p>Iâ€™ve been telling people this and been surprised by how few people have heard of the site. Itâ€™s super quick intros to syntax and weirdness for a bunch of languages with inline code tutorials.<br />
I think that for me, a short description of that mundane syntactic and programming constructs of coq is helpful.<br />
Some guidance of the standard library, what is available by default. And dealing with Notation scopes, which is a pretty weird feature that most languages donâ€™t have. <br />
The manual actually has all this now. Itâ€™s really good. Like check this section out <a href="https://coq.inria.fr/refman/language/coq-library.html">https://coq.inria.fr/refman/language/coq-library.html</a> . But the manual is an intimidating documents. It starts with a BNF description of syntax and things like that. The really useful pedagogical stuff is scattered throughout it.</p>

<p>Anyway here is my draft (also here <a href="https://github.com/philzook58/learnxinyminutes-docs/blob/master/coq.html.markdown">https://github.com/philzook58/learnxinyminutes-docs/blob/master/coq.html.markdown</a> where the syntax highlighting isnâ€™t so janked up). Suggestions welcome. Or if this gets accepted, you can just make pull requests</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">

</span><span class="o">---</span><span class="w">
</span><span class="no">language</span><span class="p">:</span><span class="w"> </span><span class="no">Coq</span><span class="w">
</span><span class="no">filename</span><span class="p">:</span><span class="w"> </span><span class="nn">learncoq</span><span class="p">.</span><span class="no">v</span><span class="w">
</span><span class="no">contributors</span><span class="p">:</span><span class="w">
    </span><span class="o">-</span><span class="w"> </span><span class="o">[</span><span class="s2">"Philip Zucker"</span><span class="o">,</span><span class="w"> </span><span class="s2">"http://www.philipzucker.com/"</span><span class="o">]</span><span class="w">
</span><span class="o">---</span><span class="w">

</span><span class="no">The</span><span class="w"> </span><span class="no">Coq</span><span class="w"> </span><span class="no">system</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">proof</span><span class="w"> </span><span class="no">assistant</span><span class="pi">.</span><span class="w"> </span><span class="no">It</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">designed</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">build</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">verify</span><span class="w"> </span><span class="no">mathematical</span><span class="w"> </span><span class="no">proofs</span><span class="pi">.</span><span class="w"> </span><span class="no">The</span><span class="w"> </span><span class="no">Coq</span><span class="w"> </span><span class="no">system</span><span class="w"> </span><span class="no">contains</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">functional</span><span class="w"> </span><span class="no">programming</span><span class="w"> </span><span class="no">language</span><span class="w"> </span><span class="no">Gallina</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">capable</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">proving</span><span class="w"> </span><span class="no">properties</span><span class="w"> </span><span class="no">about</span><span class="w"> </span><span class="no">programs</span><span class="w"> </span><span class="no">written</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">this</span><span class="w"> </span><span class="no">language</span><span class="pi">.</span><span class="w">

</span><span class="no">Coq</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">dependently</span><span class="w"> </span><span class="no">typed</span><span class="w"> </span><span class="no">language</span><span class="pi">.</span><span class="w"> </span><span class="no">This</span><span class="w"> </span><span class="no">means</span><span class="w"> </span><span class="no">that</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">types</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">language</span><span class="w"> </span><span class="no">may</span><span class="w"> </span><span class="no">depend</span><span class="w"> </span><span class="no">on</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">values</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">variables</span><span class="pi">.</span><span class="w"> </span><span class="no">In</span><span class="w"> </span><span class="no">this</span><span class="w"> </span><span class="no">respect</span><span class="o">,</span><span class="w"> </span><span class="no">it</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">similar</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">other</span><span class="w"> </span><span class="no">related</span><span class="w"> </span><span class="no">languages</span><span class="w"> </span><span class="no">such</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">Agda</span><span class="o">,</span><span class="w"> </span><span class="no">Idris</span><span class="o">,</span><span class="w"> </span><span class="no">F</span><span class="o">*,</span><span class="w"> </span><span class="no">Lean</span><span class="o">,</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">others</span><span class="pi">.</span><span class="w"> </span><span class="no">Via</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">Curry</span><span class="o">-</span><span class="no">Howard</span><span class="w"> </span><span class="no">correspondence</span><span class="o">,</span><span class="w"> </span><span class="no">programs</span><span class="o">,</span><span class="w"> </span><span class="no">properties</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">proofs</span><span class="w"> </span><span class="no">are</span><span class="w"> </span><span class="no">formalized</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">same</span><span class="w"> </span><span class="no">language</span><span class="pi">.</span><span class="w">

</span><span class="no">Coq</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">developed</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">OCaml</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">shares</span><span class="w"> </span><span class="no">some</span><span class="w"> </span><span class="no">syntactic</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">conceptual</span><span class="w"> </span><span class="no">similiarity</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">it</span><span class="pi">.</span><span class="w"> </span><span class="no">Coq</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">language</span><span class="w"> </span><span class="no">containing</span><span class="w"> </span><span class="no">many</span><span class="w"> </span><span class="no">fascinating</span><span class="w"> </span><span class="no">but</span><span class="w"> </span><span class="no">difficult</span><span class="w"> </span><span class="no">topics</span><span class="pi">.</span><span class="w"> </span><span class="no">This</span><span class="w"> </span><span class="no">tutorial</span><span class="w"> </span><span class="no">will</span><span class="w"> </span><span class="no">focus</span><span class="w"> </span><span class="no">on</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">programming</span><span class="w"> </span><span class="no">aspects</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">Coq</span><span class="o">,</span><span class="w"> </span><span class="no">rather</span><span class="w"> </span><span class="no">than</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">proving</span><span class="pi">.</span><span class="w"> </span><span class="no">It</span><span class="w"> </span><span class="no">may</span><span class="w"> </span><span class="no">be</span><span class="w"> </span><span class="no">helpful</span><span class="o">,</span><span class="w"> </span><span class="no">but</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">necessary</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">learn</span><span class="w"> </span><span class="no">some</span><span class="w"> </span><span class="no">OCaml</span><span class="w"> </span><span class="kp">first</span><span class="o">,</span><span class="w"> </span><span class="no">especially</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">you</span><span class="w"> </span><span class="no">are</span><span class="w"> </span><span class="no">unfamiliar</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">functional</span><span class="w"> </span><span class="no">programming</span><span class="pi">.</span><span class="w"> </span><span class="no">This</span><span class="w"> </span><span class="no">tutorial</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">based</span><span class="w"> </span><span class="no">upon</span><span class="w"> </span><span class="no">its</span><span class="w"> </span><span class="no">OCaml</span><span class="w"> </span><span class="no">equivalent</span><span class="w">

</span><span class="no">The</span><span class="w"> </span><span class="no">standard</span><span class="w"> </span><span class="no">usage</span><span class="w"> </span><span class="no">model</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">Coq</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">write</span><span class="w"> </span><span class="no">it</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">interactive</span><span class="w"> </span><span class="no">tool</span><span class="w"> </span><span class="no">assistance</span><span class="o">,</span><span class="w"> </span><span class="no">which</span><span class="w"> </span><span class="no">operates</span><span class="w"> </span><span class="no">like</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="no">high</span><span class="w"> </span><span class="no">powered</span><span class="w"> </span><span class="no">REPL</span><span class="pi">.</span><span class="w"> </span><span class="no">Two</span><span class="w"> </span><span class="no">common</span><span class="w"> </span><span class="no">such</span><span class="w"> </span><span class="no">editors</span><span class="w"> </span><span class="no">are</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">CoqIDE</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="k">Proof</span><span class="w"> </span><span class="no">General</span><span class="w"> </span><span class="no">Emacs</span><span class="w"> </span><span class="no">mode</span><span class="pi">.</span><span class="w">

</span><span class="no">Inside</span><span class="w"> </span><span class="k">Proof</span><span class="w"> </span><span class="no">General</span><span class="w"> </span><span class="err">`</span><span class="no">Ctrl</span><span class="o">+</span><span class="no">C</span><span class="w"> </span><span class="o">&lt;</span><span class="no">enter</span><span class="o">&gt;</span><span class="err">`</span><span class="w"> </span><span class="no">will</span><span class="w"> </span><span class="no">evaluate</span><span class="w"> </span><span class="no">up</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">your</span><span class="w"> </span><span class="no">cursor</span><span class="pi">.</span><span class="w">


</span><span class="err">```</span><span class="no">coq</span><span class="w">
</span><span class="c">(*** Comments ***)</span><span class="w">

</span><span class="c">(* Comments are enclosed in (* and *). It's fine to nest comments. *)</span><span class="w">

</span><span class="c">(* There are no single-line comments. *)</span><span class="w">

</span><span class="c">(*** Variables and functions ***)</span><span class="w">

</span><span class="c">(* The Coq proof assistant can be controlled and queried by a command language called 
   the vernacular. Vernacular keywords are capitalized and the commands end with a period.
   Variable and function declarations are formed with the Definition vernacular. *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">.</span><span class="w">

</span><span class="c">(* Coq can sometimes infer the types of arguments, but it is common practice to annotate
   with types. *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">inc_nat</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">.</span><span class="w">

</span><span class="c">(* There exists a large number of vernacular commands for querying information. 
   These can be very useful. *)</span><span class="w">

</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">).</span><span class="w"> </span><span class="c">(* 2 : nat *)</span><span class="w"> </span><span class="c">(* Compute a result. *)</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="no">tt</span><span class="pi">.</span><span class="w"> </span><span class="c">(* tt : unit *)</span><span class="w"> </span><span class="c">(* Check the type of an expressions *)</span><span class="w">

</span><span class="k">About</span><span class="w"> </span><span class="no">plus</span><span class="pi">.</span><span class="w"> </span><span class="c">(* Prints information about an object *)</span><span class="w">

</span><span class="c">(* Print information including the definition *)</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w"> </span><span class="c">(* Inductive bool : Set := true : Bool | false : Bool *)</span><span class="w">  

</span><span class="k">Search</span><span class="w"> </span><span class="no">nat</span><span class="pi">.</span><span class="w"> </span><span class="c">(* Returns a large list of nat related values *)</span><span class="w">
</span><span class="k">Search</span><span class="w"> </span><span class="s2">"_ + _"</span><span class="o">.</span><span class="w"> </span><span class="c">(* You can also search on patterns *)</span><span class="w">
</span><span class="k">Search</span><span class="w"> </span><span class="o">(</span><span class="nv">?a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nv">?a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">bool</span><span class="o">).</span><span class="w"> </span><span class="c">(* Patterns can have named parameters  *)</span><span class="w">
</span><span class="k">Search</span><span class="w"> </span><span class="o">(</span><span class="nv">?a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">?a</span><span class="o">).</span><span class="w">

</span><span class="c">(* Locate tells you where notation is coming from. Very helpful when you encounter
   new notation. *)</span><span class="w">
</span><span class="no">Locate</span><span class="w"> </span><span class="s2">"+"</span><span class="o">.</span><span class="w"> 

</span><span class="c">(* Calling a function with insufficient number of arguments
   does not cause an error, it produces a new function. *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">make_inc</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="pi">.</span><span class="w"> </span><span class="c">(* make_inc is int -&gt; int -&gt; int *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">inc_2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">make_inc</span><span class="w"> </span><span class="mi">2</span><span class="o">.</span><span class="w">   </span><span class="c">(* inc_2 is int -&gt; int *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="no">inc_2</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="c">(* Evaluates to 5 *)</span><span class="w">

</span><span class="c">(* Definitions can be chained with "let ... in" construct.
   This is roughly the same to assigning values to multiple
   variables before using them in expressions in imperative
   languages. *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">add_xy</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="kr">in</span><span class="w">
                         </span><span class="kr">let</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="kr">in</span><span class="w">
                         </span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="pi">.</span><span class="w">


</span><span class="c">(* Pattern matching is somewhat similar to switch statement in imperative
   languages, but offers a lot more expressive power. *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">is_zero</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="kr">match</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">  </span><span class="c">(* The "_" pattern means "anything else". *)</span><span class="w">
    </span><span class="kr">end</span><span class="pi">.</span><span class="w">


</span><span class="c">(* You can define recursive function definition using the Fixpoint vernacular.*)</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">factorial</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">match</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="kp">with</span><span class="w">
                        </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
                        </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="no">n'</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">factorial</span><span class="w"> </span><span class="no">n'</span><span class="w">
                        </span><span class="kr">end</span><span class="pi">.</span><span class="w">


</span><span class="c">(* Function application usually doesn't need parentheses around arguments *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="no">factorial</span><span class="w"> </span><span class="mi">5</span><span class="o">.</span><span class="w"> </span><span class="c">(* 120 : nat *)</span><span class="w">

</span><span class="c">(* ...unless the argument is an expression. *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="no">factorial</span><span class="w"> </span><span class="o">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="w"> </span><span class="c">(* 24 : nat *)</span><span class="w">

</span><span class="c">(* You can define mutually recursive functions using "with" *)</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">is_even</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">match</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="no">n</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">is_odd</span><span class="w"> </span><span class="no">n</span><span class="w">
</span><span class="kr">end</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="no">is_odd</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">match</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="no">S</span><span class="w"> </span><span class="no">n</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">is_even</span><span class="w"> </span><span class="no">n</span><span class="w">
              </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="c">(* As Coq is a total programming language, it will only accept programs when it can
   understand they terminate. It can be most easily seen when the recursive call is
   on a pattern matched out subpiece of the input, as then the input is always decreasing
   in size. Getting Coq to understand that functions terminate is not always easy. See the
   references at the end of the artice for more on this topic. *)</span><span class="w">

</span><span class="c">(* Anonymous functions use the following syntax: *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">my_square</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">my_id</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">my_id2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">,</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="no">my_id</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="c">(* 3 : nat *)</span><span class="w">

</span><span class="c">(* You can ask Coq to infer terms with an underscore *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="no">my_id</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w"> 

</span><span class="c">(* An implicit argument of a function is an argument which can be inferred from contextual
   knowledge. Parameters enclosed in {} are implicit by default *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">my_id3</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="no">my_id3</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="c">(* 3 : nat *)</span><span class="w">

</span><span class="c">(* Sometimes it may be necessary to turn this off. You can make all arguments explicit
   again with @ *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">@</span><span class="no">my_id3</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">

</span><span class="c">(* Or give arguments by name *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="no">my_id3</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="p">:</span><span class="o">=</span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">

</span><span class="c">(*** Notation ***)</span><span class="w">

</span><span class="c">(* Coq has a very powerful Notation system that can be used to write expressions in more
   natural forms. *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="nn">Nat</span><span class="p">.</span><span class="no">add</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w"> </span><span class="c">(* 7 : nat *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w"> </span><span class="c">(* 7 : nat *)</span><span class="w">

</span><span class="c">(* Notation is a syntactic transformation applied to the text of the program before being
   evaluated. Notation is organized into notation scopes. Using different notation scopes allows for a weak notion of overloading. *)</span><span class="w">

</span><span class="c">(* Imports the Zarith module containing definitions related to the integers Z *)</span><span class="w">
</span><span class="k">Require</span><span class="w"> </span><span class="k">Import</span><span class="w"> </span><span class="no">ZArith</span><span class="pi">.</span><span class="w"> 

</span><span class="c">(* Notation scopes can be opened *)</span><span class="w">
</span><span class="no">Open</span><span class="w"> </span><span class="no">Scope</span><span class="w"> </span><span class="no">Z_scope</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Now numerals and addition are defined on the integers. *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="o">.</span><span class="w"> </span><span class="c">(* 8 : Z *)</span><span class="w">

</span><span class="c">(* Integer equality checking *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="c">(* false : bool *)</span><span class="w"> 

</span><span class="c">(* Locate is useful for finding the origin and definition of notations *)</span><span class="w">
</span><span class="no">Locate</span><span class="w"> </span><span class="s2">"_ =? _"</span><span class="o">.</span><span class="w"> </span><span class="c">(* Z.eqb x y : Z_scope *)</span><span class="w"> 
</span><span class="no">Close</span><span class="w"> </span><span class="no">Scope</span><span class="w"> </span><span class="no">Z_scope</span><span class="pi">.</span><span class="w">

</span><span class="c">(* We're back to nat being the default interpetation of "+" *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="o">.</span><span class="w"> </span><span class="c">(* 8 : nat *)</span><span class="w">

</span><span class="c">(* Scopes can also be opened inline with the shorthand % *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="mi">7</span><span class="o">)%</span><span class="no">Z</span><span class="pi">.</span><span class="w"> </span><span class="c">(* -21%Z : Z *)</span><span class="w">

</span><span class="c">(* Coq declares by default the following interpretation scopes: core_scope, type_scope, 
   function_scope, nat_scope, bool_scope, list_scope, int_scope, uint_scope. You may also
   want the numerical scopes Z_scope (integers) and Q_scope (fractions) held in the ZArith
   and QArith module respectively. *)</span><span class="w">

</span><span class="c">(* You can print the contents of scopes *)</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">Scope</span><span class="w"> </span><span class="no">nat_scope</span><span class="pi">.</span><span class="w">
</span><span class="c">(*
Scope nat_scope
Delimiting key is nat
Bound to classes nat Nat.t
"x 'mod' y" := Nat.modulo x y
"x ^ y" := Nat.pow x y
"x ?= y" := Nat.compare x y
"x &gt;= y" := ge x y
"x &gt; y" := gt x y
"x =? y" := Nat.eqb x y
"x  a
                                                  end.

(* A destructuring let is available if a pattern match is irrefutable *)
Definition my_fst2 {A B : Type} (x : A * B) : A := let (a,b) := x in
                                                   a.

(*** Lists ***)

(* Lists are built by using cons and nil or by using notation available in list_scope. *)
Compute cons 1 (cons 2 (cons 3 nil)). (*  (1 :: 2 :: 3 :: nil)%list : list nat *)
Compute (1 :: 2 :: 3 :: nil)%list. 

(* There is also list notation available in the ListNotations modules *)
Require Import List.
Import ListNotations. 
Compute [1 ; 2 ; 3]. (* [1; 2; 3] : list nat *)


(* 
There are a large number of list manipulation functions available, lncluding:

â€¢ length
â€¢ head : first element (with default) 
â€¢ tail : all but first element
â€¢ app : appending
â€¢ rev : reverse
â€¢ nth : accessing n-th element (with default)
â€¢ map : applying a function
â€¢ flat_map : applying a function returning lists 
â€¢ fold_left : iterator (from head to tail)
â€¢ fold_right : iterator (from tail to head) 

 *)

Definition my_list : list nat := [47; 18; 34].

Compute List.length my_list. (* 3 : nat *)
(* All functions in coq must be total, so indexing requires a default value *)
Compute List.nth 1 my_list 0. (* 18 : nat *) 
Compute List.map (fun x =&gt; x * 2) my_list. (* [94; 36; 68] : list nat *)
Compute List.filter (fun x =&gt; Nat.eqb (Nat.modulo x 2) 0) my_list. (*  [18; 34] : list nat *)
Compute (my_list ++ my_list)%list. (*  [47; 18; 34; 47; 18; 34] : list nat *)

(*** Strings ***)

Require Import Strings.String.

Open Scope string_scope.

(* Use double quotes for string literals. *)
Compute "hi"%string.

(* Strings can be concatenated with the "++" operator. *)
Compute String.append "Hello " "World". (* "Hello World" : string *)
Compute "Hello " ++ "World". (* "Hello World" : string *)

(* Strings can be compared for equality *)
Compute String.eqb "Coq is fun!"%string "Coq is fun!"%string. (* true : bool *)
Compute ("no" =? "way")%string. (* false : bool *)

Close Scope string_scope.

(*** Other Modules ***)

(* Other Modules in the standard library that may be of interest:

â€¢ Logic : Classical logic and dependent equality
â€¢ Arith : Basic Peano arithmetic
â€¢ PArith : Basic positive integer arithmetic
â€¢ NArith : Basic binary natural number arithmetic
â€¢ ZArith : Basic relative integer arithmetic
â€¢ Numbers : Various approaches to natural, integer and cyclic numbers (currently axiomatically and on top of 2^31 binary words)
â€¢ Bool : Booleans (basic functions and results)
â€¢ Lists : Monomorphic and polymorphic lists (basic functions and results), Streams (infinite sequences
defined with co-inductive types)
â€¢ Sets : Sets (classical, constructive, finite, infinite, power set, etc.)
â€¢ FSets : Specification and implementations of finite sets and finite maps (by lists and by AVL trees)
â€¢ Reals : Axiomatization of real numbers (classical, basic functions, integer part, fractional part, limit, derivative, Cauchy series, power series and results,...)
â€¢ Relations : Relations (definitions and basic results)
â€¢ Sorting : Sorted list (basic definitions and heapsort correctness)
â€¢ Strings : 8-bits characters and strings
â€¢ Wellfounded : Well-founded relations (basic results)
 *)

(*** User-defined data types ***)

(* Because Coq is dependently typed, defining type aliases is no different than defining
   an alias for a value. *)

Definition my_three : nat := 3.
Definition my_nat : Type := nat.

(* More interesting types can be defined using the Inductive vernacular. Simple enumeration
   can be defined like so *)
Inductive ml := OCaml | StandardML | Coq.
Definition lang := Coq.  (* Has type "ml". *)

(* For more complicated types, you will need to specify the types of the constructors. *)

(* Type constructors don't need to be empty. *)
Inductive my_number := plus_infinity
                     | nat_value : nat -&gt; my_number.
Compute nat_value 3. (* nat_value 3 : my_number *)


(* Record syntax is sugar for tuple-like types. It defines named accessor functions for
   the components *)
Record Point2d (A : Set) := mkPoint2d { x2 : A ; y2 : A }. 
Definition mypoint : Point2d nat :=  {| x2 := 2 ; y2 := 3 |}.
Compute x2 nat mypoint. (* 2 : nat *)
Compute mypoint.(x2 nat). (* 2 : nat *) 

(* Types can be parameterized, like in this type for "list of lists
   of anything". 'a can be substituted with any type. *)
Definition list_of_lists a := list (list a).
Definition list_list_nat := list_of_lists nat.

(* Types can also be recursive. Like in this type analogous to
   built-in list of naturals. *)

Inductive my_nat_list := EmptyList | NatList : nat -&gt; my_nat_list -&gt; my_nat_list.
Compute NatList 1 EmptyList. (*  NatList 1 EmptyList : my_nat_list *)

(** Matching type constructors **)

Inductive animal := Dog : string -&gt; animal | Cat : string -&gt; animal.

Definition say x :=
    match x with
    | Dog x =&gt; (x ++ " says woof")%string
    | Cat x =&gt; (x ++ " says meow")%string
    end.

Compute say (Cat "Fluffy"). (* "Fluffy says meow". *)

(** Traversing data structures with pattern matching **)

(* Recursive types can be traversed with pattern matching easily.
   Let's see how we can traverse a data structure of the built-in list type.
   Even though the built-in cons ("::") looks like an infix operator,
   it's actually a type constructor and can be matched like any other. *)
Fixpoint sum_list l :=
    match l with
    | [] =&gt; 0
    | head :: tail =&gt; head + (sum_list tail)
    end.

Compute sum_list [1; 2; 3]. (* Evaluates to 6 *)


(*** A Taste of Proving ***)
(* Explaining the proof language is out of scope for this tutorial, but here is a taste to
   whet your appetite. Check the resources below for more. *)

(* A fascinating feature of dependently type based theorem provers is that the same
  primitive constructs underly the proof language as the programming features.
  For example, we can write and prove the proposition A and B implies A in raw Gallina *)

Definition my_theorem : forall A B, A /\ B -&gt; A := fun A B ab =&gt; match ab with
                                            | (conj a b) =&gt; a
                                                       end.

(* Or we can prove it using tactics. Tactics are a macro language to help build proof terms
   in a more natural style and automate away some drudgery. *)
Theorem my_theorem2 : forall A B, A /\ B -&gt; A.
Proof.
  intros A B ab.  destruct ab as [ a b ]. apply a.
Qed.

(* We can prove easily prove simple polynomial equalities using the automated tactic ring. *)
Require Import Ring.
Require Import Arith.
Theorem simple_poly : forall (x : nat), (x + 1) * (x + 2) = x * x + 3 * x + 2.
  Proof. intros. ring. Qed.

(* Here we prove the closed form for the sum of all numbers 1 to n using induction *)

Fixpoint sumn (n : nat) : nat :=
  match n with
  | 0 =&gt; 0
  | (S n') =&gt; n + (sumn n')
  end.

Theorem sum_formula : forall n, 2 * (sumn n) = (n + 1) * n.
Proof. intros. induction n.
       - reflexivity. (* 0 = 0 base case *)
       - simpl. ring [IHn]. (* induction step *)
Qed.
</span></code></pre></div></div>

<p>With this we have only scratched the surface of Coq. It is a massive ecosystem with many interesting and peculiar topics leading all the way up to modern research.</p>

<h2 id="further-reading">Further reading</h2>

<ul>
  <li><a href="https://coq.inria.fr/refman/">The Coq reference manual</a></li>
  <li><a href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a></li>
  <li><a href="http://adam.chlipala.net/cpdt/">Certfied Programming with Dependent Types</a></li>
  <li><a href="https://math-comp.github.io/mcb/">Mathematical Components</a></li>
  <li><a href="http://www.cse.chalmers.se/research/group/logic/TypesSS05/resources/coq/CoqArt/">Coqâ€™Art: The Calculus of Inductive Constructions</a></li>
  <li><a href="http://adam.chlipala.net/frap/">FRAP</a></li>
</ul>

<p>Bonus. An uneditted list of tactics. Youâ€™d probably prefer <a href="https://pjreddie.com/coq-tactics/">https://pjreddie.com/coq-tactics/</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>


(*** Tactics ***)
 (* Although we won't explain their use in detail, here is a list of common tactics. *)

(* 

    * exact
    * simpl
    * intros
    * apply
    * assert
    * destruct
    * induction
    * reflexivity
    * rewrite
    * inversion
    * injection
    * discriminate
    * fold
    * unfold


        Tacticals
    * try
    * ;
        * repeat
        *



 Automatic
    * auto
    * eauto
    * tauto
    * ring
    * ring_simplify
    * psatz
    * lia
    * ria


LTac is a logic programming scripting language for tactics

       From Tatics chapter of LF
        intros: move hypotheses/variables from goal to context
reflexivity: finish the proof (when the goal looks like e = e)
apply: prove goal using a hypothesis, lemma, or constructor
apply... in H: apply a hypothesis, lemma, or constructor to a hypothesis in the context (forward reasoning)
apply... with...: explicitly specify values for variables that cannot be determined by pattern matching
simpl: simplify computations in the goal
simpl in H: ... or a hypothesis
rewrite: use an equality hypothesis (or lemma) to rewrite the goal
rewrite ... in H: ... or a hypothesis
symmetry: changes a goal of the form t=u into u=t
symmetry in H: changes a hypothesis of the form t=u into u=t
unfold: replace a defined constant by its right-hand side in the goal
unfold... in H: ... or a hypothesis
destruct... as...: case analysis on values of inductively defined types
destruct... eqn:...: specify the name of an equation to be added to the context, recording the result of the case analysis
induction... as...: induction on values of inductively defined types
injection: reason by injectivity on equalities between values of inductively defined types
discriminate: reason by disjointness of constructors on equalities between values of inductively defined types
assert (H: e) (or assert (e) as H): introduce a "local lemma" e and call it H
                                              generalize dependent x: move the variable x (and anything else that depends on it) from the context back to an explicit hypothesis in the goal formula

clear H: Delete hypothesis H from the context.
subst x: For a variable x, find an assumption x = e or e = x in the context, replace x with e throughout the context and current goal, and clear the assumption.
subst: Substitute away all assumptions of the form x = e or e = x (where x is a variable).
rename... into...: Change the name of a hypothesis in the proof context. For example, if the context includes a variable named x, then rename x into y will change all occurrences of x to y.
assumption: Try to find a hypothesis H in the context that exactly matches the goal; if one is found, behave like apply H.
contradiction: Try to find a hypothesis H in the current context that is logically equivalent to False. If one is found, solve the goal.
constructor: Try to find a constructor c (from some Inductive definition in the current environment) that can be applied to solve the current goal. If one is found, behave like apply c.
                                                                                       (* Dependent types. Using dependent types for programming tasks tends to be rather unergonomic in Coq. 
We briefly mention here as an advanced topic that there exists a more sophistictaed match statement that is needed for dependently typed. See for example the "Convoy" pattern.
*)

(*** Other topics ***)

(* Dependently Typed Programming - Most of the above syntax has its equivalents in OCaml. Coq also has the capability for full dependently typed programming. There is an extended pattern matching syntax available for this purpose.

   Extraction - Coq can be extracted to OCaml and Haskell code for their more performant runtimes and ecosystems
   Modules / TypeClasses - Modules and Typeclasses are methods for organizing code. They allow a different form of overloading than Notation
   Setoids - 
   Termination - Gallina is a total functional programming language. It will not allow you to write functions that do not obviously terminate. For functions that do terminate but non-obviously, it requires some work to get Coq to understand this.
   Coinductive - Coinductive types such as streams are possibly infinite values that stay productive.


 *)

</code></pre></div></div>

:ET