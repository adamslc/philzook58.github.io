I"Ä<p>Welcome back, friend.</p>

<p>In the <a href="http://www.philipzucker.com/a-touch-of-topological-quantum-computation-in-haskell-pt-i/">last</a> <a href="http://www.philipzucker.com/a-touch-of-topological-quantum-computation-in-haskell-pt-ii-automating-drudgery/">two</a> posts, I described the basics of how to build and manipulate the Fibonacci anyon vector space in Haskell.</p>

<p>As a personal anecdote, trying to understand the category theory behind the theory of anyons is one of the reasons I started learning Haskell. These spaces are typically described using the terminology of category theory. I found it very frustrating that anyons were described in an abstract and confusing terminology. I really wondered if people were just making things harder than they have to be. I think Haskell is a perfect playground to clarify these constructions. While the category theory stuff isn‚Äôt strictly necessary, it is interesting and useful once you get past the frustration.</p>

<p>Unfortunately, I can‚Äôt claim that this article is going to be enough to take you from zero to categorical godhood</p>

<p><img src="https://pbs.twimg.com/media/DjuKrDCVsAAG_Iy.jpg" alt="" /></p>

<p>but I hope everyone can get something out of it. Give it a shot if you‚Äôre interested, and don‚Äôt sweat the details.</p>

<h4 id="the-aroma-of-categories">The Aroma of Categories</h4>

<p>I think <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.211.4754&amp;rep=rep1&amp;type=pdf">Steve Awodey</a> gives an excellent nutshell of category theory in the introductory section to his book:</p>

<p>‚ÄúWhat is category theory? As a first approximation, one could say that category theory is the mathematical study of (abstract) algebras of functions. Just as group theory is the abstraction of the idea of a system of permutations of a set or symmetries of a geometric object, so category theory arises from the idea of a system of functions among some objects.‚Äù</p>

<p>For my intuition, a category is any ‚Äúthings‚Äù that plug together. The ‚Äúin‚Äù of a thing has to match the ‚Äúout‚Äù of another thing in order to hook them together. In other words, the requirement for something to be a category is having a notion of composition. The things you plug together are called the morphisms of the category and the matching ports are the objects of the category. The additional requirement of always having an identity morphism (a do-nothing connection wire) is usually there once you have composition, although it is good to take especial note of it.</p>

<p>Category theory is an elegant framework for how to think about these composing things in a mathematical way. In my experience, thinking in these terms leads to good abstractions, and useful analogies between disparate things.</p>

<p>It is helpful for any abstract concept to list some examples to expose the threads that connect them. Category theory in particular has a ton of examples connecting to many other fields because it is a science of analogy. These are the examples of categories I usually reach for. Which one feels the most comfortable to you will depend on your background.</p>

<ul>
  <li>Hask. Objects are types. Morphisms are functions between those types</li>
  <li>Vect. Objects are vector spaces, morphisms are linear maps (roughly matrices).</li>
  <li>Preorders. Objects are values. Morphisms are the inequalities between those values.</li>
  <li>Sets. Objects are Sets. Morphisms are functions between sets.</li>
  <li>Cat. Objects are categories, Morphisms are functors. This is a pretty cool one, although complete categorical narcissism.</li>
  <li>Systems and Processes.</li>
  <li>The Free Category of a directed graphs. Objects are vertices. Morphisms are paths between vertices</li>
</ul>

<h4 id="generic-programming-and-typeclasses">Generic Programming and Typeclasses</h4>

<p>The goal of generic programming is to run programs that you write once in many way.</p>

<p>There are many ways to approach this generic programming goal, but one way this is achieved in Haskell is by using Typeclasses. Typeclasses allow you to overload names, so that they mean different things based upon the types involved. Adding a vector is different than adding a float or int, but there are programs that can be written that reasonably apply in both situations.</p>

<p>Writing your program in a way that it applies to disparate objects requires abstract ways of talking about things. Mathematics is an excellent place to mine for good abstractions. In particular, the category theory abstraction has demonstrated itself to be a very useful unified vocabulary for mathematical topics. I, and others, find it also to be a beautiful aesthetic by which to structure programs.</p>

<p>In the Haskell base library there is a Category typeclass defined in <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Category.html">base</a>. In order to use this, you need to import the Prelude in an unusual way.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;{-# LANGUAGE NoImplicitPrelude #-} 
import Prelude hiding ((.), id) &lt;/code&gt;
</code></pre></div></div>

<p>The Category typeclass is defined on the type that corresponds to the morphisms of the category. This type has a slot for the input type and a slot for the output type. In order for something to be a category, it has to have an identity morphisms and a notion of composition.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;class Category cat where
     id :: cat a a
     (.) :: cat b c -&gt; cat a b -&gt; cat a c&lt;/code&gt;
</code></pre></div></div>

<p>The most obvious example of this Category typeclass is the instance for the ordinary Haskell function (-&gt;). The identity corresponds to the standard Haskell identity function, and composition to ordinary Haskell function composition.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;instance Category (-&gt;) where     
   id = \x -&gt; x
   f . g = \x -&gt; f (g x)&lt;/code&gt;
</code></pre></div></div>

<p>Another example of a category that we‚Äôve already encountered is that of linear operators which we‚Äôll call LinOp. LinOp is an example of a Kliesli arrow, a category built using monadic composition rather than regular function composition. In this case, the monad <code class="language-plaintext highlighter-rouge">Q</code> from <a href="http://www.philipzucker.com/a-touch-of-topological-quantum-computation-in-haskell-pt-i/">my first post</a> takes care of the linear pipework that happens between every application of a LinOp. The fish <code class="language-plaintext highlighter-rouge">&lt;=&lt;</code> operator is monadic composition from <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html">Control.Monad</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;newtype LinOp a b = LinOp {runLin :: a -&gt; Q b} 
instance Category LinOp where
   id = LinOp pure 
   (LinOp f) . (LinOp g) = LinOp (f &lt;=&lt; g) &lt;/code&gt;
</code></pre></div></div>

<p>A related category is the FibOp category. This is the category of operations on Fibonacci anyons, which are also linear operations. It is LinOp specialized to the Fibonacci anyon space. All the operations we‚Äôve previously discussed (F-moves, braiding) are in this category.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;newtype FibOp a b = FibOp {runFib :: (forall c. FibTree c a -&gt; Q (FibTree c b))} 
instance Category (FibOp) where
   id = FibOp pure
   (FibOp f) . (FibOp g) = FibOp (f &lt;=&lt; g)&lt;/code&gt;
</code></pre></div></div>

<p>The ‚Äúfeel‚Äù of category theory takes focus away from the objects and tries to place focus on the morphisms. There is a style of functional programming called <a href="https://wiki.haskell.org/Pointfree">‚Äúpoint-free‚Äù</a> where you avoid ever giving variables explicit names and instead use pipe-work combinators like <code class="language-plaintext highlighter-rouge">(.)</code>, <code class="language-plaintext highlighter-rouge">fst</code>, <code class="language-plaintext highlighter-rouge">snd</code>, or <code class="language-plaintext highlighter-rouge">(***)</code>. This also has a feel of de-emphasizing objects. Many of the combinators that get used in this style have categorical analogs. In order to generically use categorical typeclasses, you have to write your program in this point free style.</p>

<p>It is possible for a program written in the categorical style to be a reinterpreted as a program, a linear algebra operation, a circuit, or a diagram, all without changing the actual text of the program. For more on this, I highly recommend Conal Elliot‚Äôs <a href="http://conal.net/papers/compiling-to-categories/"> compiling to categories</a>, which also puts forth a methodology to avoid the somewhat unpleasant point-free style using a compiler plug-in. This might be an interesting place to mine for a good quantum programming language. YMMV.</p>

<h3 id="monoidal-categories">Monoidal Categories.</h3>

<p>Putting two processes in parallel can be considered a kind of product. A category is <a href="https://en.wikipedia.org/wiki/Monoidal_category">monoidal </a>)if it has this product of this flavor, and has isomorphisms for reassociating objects and producing or consuming a unit object. This will make more sense when you see the examples.</p>

<p>We can sketch out this monoidal category concept as a typeclass, where we use <code class="language-plaintext highlighter-rouge">()</code> as the unit object.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;class Category k =&gt; Monoidal k where
     parC :: k a c -&gt; k b d -&gt; k (a,b) (c,d)
     assoc :: k ((a,b),c) (a,(b,c))
     assoc' :: k (a,(b,c)) ((a,b),c)
     leftUnitor :: k ((),a) a
     leftUnitor' :: k a ((),a)
     rightUnitor :: k (a,()) a
     rightUnitor' :: k a (a,()) &lt;/code&gt;
</code></pre></div></div>

<h4 id="instances">Instances</h4>

<p>In Haskell, the standard monoidal product for regular Haskell functions is <code class="language-plaintext highlighter-rouge">(***)</code> from <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html">Control.Arrow</a>. It takes two functions and turns it into a function that does the same stuff, but on a tuple of the original inputs. The associators and unitors are fairly straightforward. We can freely dump unit <code class="language-plaintext highlighter-rouge">()</code> and get it back because there is only one possible value for it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;(***) :: (a -&gt; c) -&gt; (b -&gt; d) -&gt; ((a,b) -&gt; (c,d))
f *** g = \(x,y) -&gt; (f x, g y) Ôªø&lt;/code&gt;







&lt;code&gt;instance Monoidal (-&gt;) where
   parC f g = f *** g 
   assoc ((x,y),z) = (x,(y,z))
   assoc' (x,(y,z)) = ((x,y),z)
   leftUnitor (_, x) = x
   leftUnitor' x = ((),x)
   rightUnitor (x, _) = x
   rightUnitor' x = (x,()) &lt;/code&gt;
</code></pre></div></div>

<p>The monoidal product we‚Äôll choose for LinOp is the tensor/outer/<a href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecke</a>r product.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;kron :: Num b =&gt; W b a -&gt; W b c -&gt; W b (a,c)
kron (W x) (W y) = W [((a,c), r1 * r2) | (a,r1) &lt;- x , (c,r2) &lt;- y ]&lt;/code&gt;
</code></pre></div></div>

<p>Otherwise, LinOp is basically a monadically lifted version of (-&gt;). The one dimensional vector space <code class="language-plaintext highlighter-rouge">Q ()</code> is completely isomorphic to just a number. Taking the Kronecker product with it is basically the same thing as scalar multiplying (up to some shuffling).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;instance Monoidal LinOp where
    parC (LinOp f) (LinOp g) = LinOp $ \(a,b) -&gt; kron (f a) (g b) 
    assoc = LinOp  (pure . assoc)
    assoc' = LinOp (pure . unassoc)
    leftUnitor = LinOp (pure . leftUnitor)
    leftUnitor' = LinOp (pure .leftUnitor')
    rightUnitor = LinOp (pure . rightUnitor)
    rightUnitor' = LinOp (pure . rightUnitor')&lt;/code&gt;
</code></pre></div></div>

<p>Now for a confession. I made a misstep in my first post. In order to make our Fibonacci anyons jive nicely with our current definitions, I should have defined our identity particle using <code class="language-plaintext highlighter-rouge">type Id = ()</code> rather than <code class="language-plaintext highlighter-rouge">data Id</code>. We‚Äôll do that now. In addition, we need some new primitive operations for absorbing and emitting identity particles that did not feel relevant at that time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;rightUnit :: FibTree e (a,Id) -&gt; Q (FibTree e a)
rightUnit (TTI t _) = pure t
rightUnit (III t _) = pure t

rightUnit' :: FibTree e a -&gt; Q (FibTree e (a,Id))
rightUnit' t@(TTT _ _) = pure (TTI¬† t ILeaf)
rightUnit' t@(TTI _ _) = pure (TTI¬† t ILeaf)
rightUnit' t@(TIT _ _) = pure (TTI¬† t ILeaf)
rightUnit' t@(III _ _) = pure (III¬† t ILeaf)
rightUnit' t@(ITT _ _) = pure (III¬† t ILeaf)
rightUnit' t@(ILeaf) = pure (III¬†t ILeaf)
rightUnit' t@(TLeaf) = pure (TTI¬†t ILeaf)

leftUnit :: FibTree e (Id,a) -&gt; Q (FibTree e a)
leftUnit = rightUnit &lt;=&lt; braid

-- braid vs braid' doesn't matter, but it has a nice symettry.
leftUnit' :: FibTree e a -&gt; Q (FibTree e (Id,a))
leftUnit' = braid' &lt;=&lt; rightUnit' &lt;/code&gt;
</code></pre></div></div>

<p>With these in place, we can define a monoidal instance for <code class="language-plaintext highlighter-rouge">FibOp</code>. The extremely important and intriguing F-move operations are the <code class="language-plaintext highlighter-rouge">assoc</code> operators for the category. While other categories have <code class="language-plaintext highlighter-rouge">assoc</code> that feel nearly trivial, these F-moves don‚Äôt feel so trivial.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;instance Monoidal (FibOp) where
    parC (FibOp f) (FibOp g) = (FibOp (lmap f)) . (FibOp (rmap g))
    assoc = FibOp  fmove'
    assoc' = FibOp fmove
    leftUnitor = FibOp leftUnit
    leftUnitor' = FibOp leftUnit'
    rightUnitor = FibOp rightUnit
    rightUnitor' = FibOp rightUnit'&lt;/code&gt;
</code></pre></div></div>

<h4 id="this-is-actually-useful">This is actually useful</h4>

<p>The <code class="language-plaintext highlighter-rouge">parC</code> operation is extremely useful to explicitly note in a program. It is an opportunity for optimization. It is possible to inefficiently implement <code class="language-plaintext highlighter-rouge">parC</code> in terms of other primitives, but it is very worthwhile to implement it in new primitives (although I haven‚Äôt here). In the case of (-&gt;), <code class="language-plaintext highlighter-rouge">parC</code> is an explicit location where actual computational parallelism is available. Once you perform <code class="language-plaintext highlighter-rouge">parC</code>, it is not longer obviously apparent that the left and right side of the tuple share no data during the computation. In the case of LinOp and FibOp, <code class="language-plaintext highlighter-rouge">parC</code> is a location where you can perform factored linear computations. The matrix vector product $latex (A \otimes B)(v \otimes w)$ can be performed individually $latex (Av)\otimes (Bw)$. In the first case, where we densify $latex A \otimes B$ and then perform the multiplication, it costs $latex O((N_A N_B)^2)$ time, whereas performing them individually on the factors costs $latex O( N_A^2 + N_B^2)$ time, a significant savings. Applied category theory indeed.</p>

<h4 id="laws">Laws</h4>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/judgedrd1-1024x503.png" alt="" />Judge Dredd courtesy of David</p>

<p>Like many typeclasses, these monoidal morphisms are assumed to follow certain laws. Here is a sketch (for a more thorough discussion check out the <a href="https://en.wikipedia.org/wiki/Monoidal_category">wikipedia page</a>):</p>

<ul>
  <li>Functions with a tick at the end like <code class="language-plaintext highlighter-rouge">assoc'</code> should be the inverses of the functions without the tick like <code class="language-plaintext highlighter-rouge">assoc</code>, e.g. <code class="language-plaintext highlighter-rouge">assoc . assoc' = id</code></li>
  <li>The <code class="language-plaintext highlighter-rouge">parC</code> operation is (bi)functorial, meaning it obeys the commutation law <code class="language-plaintext highlighter-rouge">parC (f . f') (g . g') = (parC f g) . (parC f' g')</code> i.e. it doesn‚Äôt matter if we perform composition before or after the <code class="language-plaintext highlighter-rouge">parC</code>.</li>
  <li>The pentagon law for <code class="language-plaintext highlighter-rouge">assoc</code>: Applying <code class="language-plaintext highlighter-rouge">leftbottom</code> is the same as applying <code class="language-plaintext highlighter-rouge">topright</code></li>
</ul>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Monoidal_category_pentagon.svg/1400px-Monoidal_category_pentagon.svg.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;leftbottom :: (((a,b),c),d) -&gt; (a,(b,(c,d)))
leftbottom =¬†assoc . assoc

topright :: (((a,b),c),d) -&gt; (a,(b,(c,d)))
topright =¬†(id *** assoc) . assoc . (assoc *** id)&lt;/code&gt;
</code></pre></div></div>

<ul>
  <li>The triangle law for the unitors:</li>
</ul>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Monoidal_category_triangle.svg/800px-Monoidal_category_triangle.svg.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;topright' :: ((a,()),b) -&gt; (a,b)
topright' = (id *** leftUnitor) . assoc
leftside :: ((a,()),b) -&gt; (a,b)
leftside = rightUnitor *** id&lt;/code&gt;
</code></pre></div></div>

<h4 id="string-diagrams">String Diagrams</h4>

<p>String diagrams are a diagrammatic notation for monoidal categories. Morphisms are represented by boxes with lines.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-6.png" alt="" /></p>

<p>Composition <code class="language-plaintext highlighter-rouge">g . f</code> is made by connecting lines.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-7.png" alt="" /></p>

<p>The identity <code class="language-plaintext highlighter-rouge">id</code> is a raw arrow.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-8.png" alt="" /></p>

<p>The monoidal product of morphisms $latex f \otimes g$ is represented by placing lines next to each other.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-9.png" alt="" /></p>

<p>The diagrammatic notion is so powerful because the laws of monoidal categories are built so deeply into it they can go unnoticed. Identities can be put in or taken away. Association doesn‚Äôt even appear in the diagram. The boxes in the notation can naturally be pushed around and commuted past each other.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-3-1024x668.png" alt="" /></p>

<p>This corresponds to the property</p>

<p>$latex (id \otimes g) \circ (f \otimes id) = (f \otimes id) \circ (id \otimes g)$</p>

<p>What expression does the following diagram represent?</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-2-1.png" alt="" /></p>

<p>Is it $latex (f \circ f‚Äô) \otimes (g \circ g‚Äô)$ (in Haskell notation <code class="language-plaintext highlighter-rouge">parC (f . f') (g . g')</code> )?</p>

<p>Or is it $latex (f \otimes g) \circ (f‚Äô \otimes g‚Äô)$ (in Haskell notation <code class="language-plaintext highlighter-rouge">(parC f g) . (parC f' g')</code>?</p>

<p>Answer: It doesn‚Äôt matter because the functorial requirement of <code class="language-plaintext highlighter-rouge">parC</code> means the two expressions are identical.</p>

<p>There are a number of notations you might meet in the world that can be interpreted as String diagrams. Three that seem particular pertinent are:</p>

<ul>
  <li>Quantum circuits</li>
</ul>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/Quantum_circuit_composition.svg/300px-Quantum_circuit_composition.svg.png" alt="Image result for quantum circuits" /></p>

<ul>
  <li>Penrose Notation for tensors <a href="https://en.wikipedia.org/wiki/Penrose_graphical_notation">https://en.wikipedia.org/wiki/Penrose_graphical_notation</a></li>
</ul>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/Penrose_covariant_derivate.png" alt="" /></p>

<ul>
  <li><em><strong>Anyon Diagrams!</strong></em></li>
</ul>

<p><img src="https://3c1703fe8d.site.internapcdn.net/newman/gfx/news/hires/2014/fibonacciqua.png" alt="" /></p>

<h4 id="braided-and-symmetric--monoidal-categories-categories-that-braid-and--swap">Braided and Symmetric  Monoidal Categories: Categories That Braid and  Swap</h4>

<p>Some monoidal categories have a notion of being able to braid morphisms. If so, it is called a <a href="https://en.wikipedia.org/wiki/Braided_monoidal_category">braided monoidal category</a> (go figure).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;class Monoidal k =&gt; Braided k where
    over :: k (a,b) (b,a)
    under :: k (a,b) (b,a)&lt;/code&gt;
</code></pre></div></div>

<p>The over and under morphisms are inverse of each other <code class="language-plaintext highlighter-rouge">over . under = id</code>. The <code class="language-plaintext highlighter-rouge">over</code> morphism pulls the left morphism over the right, whereas the <code class="language-plaintext highlighter-rouge">under</code> pulls the left under the right. The diagram definitely helps to understand this definition.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-4.png" alt="" /></p>

<p>These over and under morphisms need to play nice with the associator of the monoidal category. These are laws that valid instance of the typeclass should follow. We actually already met them in the very first post.</p>

<p>If the over and under of the braiding are the same the category is a <a href="https://en.wikipedia.org/wiki/Symmetric_monoidal_category">symmetric monoidal category</a>. This typeclass needs no extra functions, but it is now intended that the law <code class="language-plaintext highlighter-rouge">over . over = id</code> is obeyed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;class Braided k =&gt; Symmetric k where&lt;/code&gt;
</code></pre></div></div>

<p>When we draw a braid in a symmetric monoidal category, we don‚Äôt have to be careful with which one is over and under, because they are the same thing.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/02/8acaa5b6-50cc-4208-89da-414b21867064-5.png" alt="" /></p>

<p>The examples that come soonest to mind have this symmetric property, for example (-&gt;) is a symmetric monoidal category..</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;swap :: (a, b) -&gt; (b, a)
swap (x,y) = (y,x)&lt;/code&gt;







&lt;code&gt;instance Braided (-&gt;) where
    over = swap
    under = swap
instance Symmetric (-&gt;)&lt;/code&gt;
</code></pre></div></div>

<p>Similarly <code class="language-plaintext highlighter-rouge">LinOp</code> has an notion of swapping that is just a lifting of <code class="language-plaintext highlighter-rouge">swap</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;instance Braided (LinOp) where
    over = LinOp (pure . swap)
    under = LinOp (pure . swap)
instance Symmetric LinOp &lt;/code&gt;
</code></pre></div></div>

<p>However, FibOp is not symmetric! This is perhaps at the core of what makes FibOp so interesting.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;instance Braided FibOp where
    over = FibOp braid
    under = FibOp braid'&lt;/code&gt;
</code></pre></div></div>

<h4 id="automating-association">Automating Association</h4>

<p><a href="http://www.philipzucker.com/a-touch-of-topological-quantum-computation-in-haskell-pt-ii-automating-drudgery/">Last time,</a> we spent a lot of time doing weird typelevel programming to automate the pain of manual association moves. We can do something quite similar to make the categorical reassociation less painful, and more like the carefree ideal of the string diagram if we replace composition <code class="language-plaintext highlighter-rouge">(.)</code> with a slightly different operator</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;(...) :: ReAssoc b b' =&gt; FibOp b' c -&gt; FibOp a b -&gt; FibOp a c
(FibOp f) ... (FibOp g) = FibOp $ f &lt;=&lt; reassoc &lt;=&lt; g&lt;/code&gt;
</code></pre></div></div>

<p>Before defining <code class="language-plaintext highlighter-rouge">reassoc</code>, let‚Äôs define a helper LeftCollect typeclass. Given a typelevel integer n, it will reassociate the tree using a binary search procedure to make sure the left branch <code class="language-plaintext highlighter-rouge">l</code> at the root has <code class="language-plaintext highlighter-rouge">Count l = n</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;leftcollect :: forall n gte l r o e. (gte ~ CmpNat n (Count l), LeftCollect n gte (l,r) o) =&gt; FibTree e (l,r) -&gt; Q (FibTree e o)
leftcollect x = leftcollect' @n @gte x

class LeftCollect n gte a b | n gte a -&gt; b where
    leftcollect' :: FibTree e a -&gt; Q (FibTree e b)

-- The process is like a binary search.
-- LeftCollect pulls n leaves into the left branch of the tuple

-- If n is greater than the size of l, we recurse into the right branch with a new number of leaves to collect
-- then we do a final reshuffle to put those all into the left tree.
instance (
   k ~ Count l,
   r ~ (l',r'),
   n' ~ (n - k),
   gte ~ CmpNat n' (Count l'), 
   LeftCollect n' gte r (l'',r'')) =&gt; LeftCollect n 'GT (l,r) ((l,l''),r'') where
        leftcollect' x = do       
               x' &lt;- rmap (leftcollect @n') x -- (l,(l'',r'')) -- l'' is size n - k
               fmove x'  -- ((l,l''),r'') -- size of (l,l'') = k + (n-k) = n
instance (
    l ~ (l',r'),
    gte ~ CmpNat n (Count l'), 
    LeftCollect n gte l (l'',r'')) =&gt; LeftCollect n 'LT (l,r) (l'',(r'',r)) where
        leftcollect' x = do       
                x' &lt;- lmap (leftcollect @n) x -- ((l'',r''),r) -- l'' is of size n
                fmove' x'  -- (l'',(r'',r)

instance LeftCollect n 'EQ (l,r) (l,r) where
    leftcollect' = pure&lt;/code&gt;
</code></pre></div></div>

<p>Once we have LeftCollect, the typeclass ReAssoc is relatively simple to define. Given a pattern tree, we can count the elements in it‚Äôs left branch and LeftCollect the source tree to match that number. Then we recursively apply reassoc in the left and right branch of the tree. This means that every node has the same number of children in the tree, hence the trees will end up in an identical shape (modulo me mucking something up).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;class ReAssoc a b where
    reassoc :: FibTree e a -&gt; Q (FibTree e b)
instance (n ~ Count l',
    gte ~ CmpNat n (Count l), 
    LeftCollect n gte (l,r) (l'',r''),    
    ReAssoc l'' l',
    ReAssoc r'' r') =&gt; ReAssoc (l,r) (l',r') where
        reassoc x = do 
                    x' &lt;- leftcollect @n x
                    x'' &lt;- rmap reassoc x'
                    lmap reassoc x''
                    
--instance {-# OVERLAPS #-} ReAssoc a a where
 --   reassoc = pure
    
instance ReAssoc Tau Tau where
    reassoc = pure
instance ReAssoc Id Id where
    reassoc = pure&lt;/code&gt;
</code></pre></div></div>

<p>It seems likely that one could write equivalent instances that would work for an arbitrary monoidal category with a bit more work. We are aided somewhat by the fact that <code class="language-plaintext highlighter-rouge">FibOp</code> has a finite universe of possible leaf types to work with.</p>

<h3 id="closing-thoughts">Closing Thoughts</h3>

<p>While our categorical typeclasses are helpful and nice, I should point out that they are not going to cover all the things that can be described as categories, even in Haskell. Just like the Functor typeclass does not describe all the conceptual <a href="http://www.haskellforall.com/2012/09/the-functor-design-pattern.html">functors you might mee</a>t. One beautiful monoidal category is that of Haskell Functors under the monoidal product of <a href="https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Data-Functor-Compose.html">Functor Composition</a>. More on this to come, I think. <a href="https://parametricity.com/posts/2015-07-18-braids.html">https://parametricity.com/posts/2015-07-18-braids.html</a></p>

<p>We never even touched the dot product in this post. This corresponds to another doodle in a string diagram, and another <a href="https://en.wikipedia.org/wiki/Dagger_symmetric_monoidal_category">power</a> to add to your category. It is somewhat trickier to work with cleanly in familiar Haskell terms, I think because (-&gt;) is at least not super obviously a dagger category?</p>

<p>You can find a hopefully compiling version of all my snippets and more in my chaotic mutating Github repo <a href="https://github.com/philzook58/fib-anyon">https://github.com/philzook58/fib-anyon</a></p>

<p>See you next time.</p>

<h4 id="references">References</h4>

<p>The <a href="http://math.ucr.edu/home/baez/rosetta.pdf">Rosetta Stone paper</a> by Baez and Stay is probably the conceptual daddy of this entire post (and more).</p>

<p>Bartosz Milewski‚Äôs Category Theory for Programmer‚Äôs <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">blog</a> (online book really) and <a href="https://www.youtube.com/user/DrBartosz/playlists">youtube</a> series are where I learned most of what I know about category theory. I highly recommend them (huge Bartosz fanboy).</p>

<p>Catsters - <a href="https://byorgey.wordpress.com/catsters-guide-2/">https://byorgey.wordpress.com/catsters-guide-2/</a></p>

<p><a href="https://en.wikibooks.org/wiki/Haskell/Category_theory">https://en.wikibooks.org/wiki/Haskell/Category_theory</a></p>

<p><a href="https://www.math3ma.com/blog/what-is-category-theory-anyway">https://www.math3ma.com/blog/what-is-category-theory-anyway</a></p>

<p>There are fancier embeddings of category theory and monoidal categories than I‚Äôve shown here. Often you want constrained categories and the ability to choose unit objects. I took a rather simplistic approach here.</p>

<p><a href="http://hackage.haskell.org/package/constrained-categories">http://hackage.haskell.org/package/constrained-categories</a></p>

<p><a href="http://hackage.haskell.org/package/data-category">http://hackage.haskell.org/package/data-category</a></p>

<p>http://www.philipzucker.com/resources-string-diagrams-adjunctions-kan-extensions/</p>

<p><a href="https://parametricity.com/posts/2015-07-18-braids.html">https://parametricity.com/posts/2015-07-18-braids.html</a></p>

<p>https://www.youtube.com/watch?v=eOdBTqY3-Og</p>

:ET