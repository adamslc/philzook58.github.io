I"<p>A long list of scattered thoughts. I need more examples.</p>

<p>Functors:</p>

<p>fmap generalizes map on lists. If you can apply a function and inject it into a container it is a functor.</p>

<p>Examples: trees. Simple wrappers. Records.</p>

<p>Alternatively Functors are category theory functors. The combo of the type constructor (Which maps a into Constructor a) and fmap (which maps the morphisms)</p>

<p>Foldable:</p>

<p>foldMap is like concatMap.</p>

<p>I am confused.</p>

<p>Traversable:</p>

<p>traverse is like fmap except ‚Äúeffectful‚Äù?</p>

<p>traverse is like mapM for applicatives? Like a mapA. mapM is like map except it uses bind instead of apply. So if you had a list of Maybe Ints you could mapM over them to apply a monadically defined function Int -&gt; mb to all elements. So instead you use &lt;*&gt; I guess? If you had a‚Ä¶</p>

<p>sequence is like? It flips outside and inside wrappers? List of Maybes to a Maybe List. Like transposing a matrix ? Hmm. The matrix is a bit confusing because there is a traversable and an applicative at play</p>

<p>I am confused.</p>

<p>Applicative:</p>

<p>slightly less powerful monads. Equal to do notation if you don‚Äôt use values until the return.</p>

<p>Applying a list of functions to a list of arguments. Either zipwise or nondeterministic/cartesian product wise.</p>

<p>If you fmap &lt;$&gt; a multiargument function over a list you get a list of functions via currying.</p>

<p>(+) &lt;$&gt; [1,2] &lt;*&gt; [7,8]</p>

<p>will return a list of all possible sum combos via the default applicative list instance.</p>

<p>I am pretty darn confused about applicative. I don‚Äôt have examples of applicatives that aren‚Äôt also monads although I‚Äôve seen the claim there are many.</p>

<p>Lens:</p>

<p>Look at Simon Peyton Jones talk. It helped a lot. Ed Khmett‚Äôs talk is very puzzling from the get go. It assumes comfort levels with traversable and foldable.</p>

<p>Lens a b are kind of functiony ‚Äúthings‚Äù that have a big object a and a focus within that object b.</p>

<p>Simplest lens would be a hand written setter and getter functions</p>

<p>something like the _1 lens would look like</p>

<p><em>1 ¬†{get = (x,y) -&gt; x, set a = (</em>,y)-&gt;(a,y)}</p>

<p>Composable. Sort of compose setters and getters if one guy is inside of another. I think there is some pipework for getting set to work.</p>

<p>Can be unified into a single interface. Lens‚Äô which uses Functorial trickery. Using trivial seeming Functors can be useful. Identity and Const.</p>

<p>Interesting connection between type level and value level.</p>

<p>fix, id, const and Fix Identity and Const</p>

<p>Recursion Schemes:</p>

<p><a href="http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/">http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/</a></p>

<p>Nutso shit.</p>

<p>Maybe a start is to try to right fold in terms of fix. Don‚Äôt use recursion except fix</p>

<p>Bananas Barbed Wire territory. Paper is incomprehensible due to using Squiggol notation</p>

<p>fix f = let x= fx in x</p>

<p>let is a primitive construct of its own.</p>

<p>bottom is the value a function returns when it gets into an infinite loop (If we insist on things being for real mathematical functions that have to return). bottom is always a possible value. You can‚Äôt really return bottom in some sense because of the Halting problem being unable to determine if stuff will halt (although in special cases its possible btw).</p>

<p><a href="https://en.wikibooks.org/wiki/Haskell/Denotational_semantics">https://en.wikibooks.org/wiki/Haskell/Denotational_semantics</a></p>

<p>Profunctors:</p>

<p>Seem really important. This is the most promising area for me to find a good approach to anyon models.</p>

<p>Contravariant Functors are functors where fmap kind of reverse what happens.</p>

<p>There is a related funniness where you would apply f then apply g but the composition is written g . f ¬†The order is swapped in some kind of wonky way between application and composition</p>

<p>Wrapping Isomorphisms as type. The Product type of the map and inverse map of the isomorphism.</p>

<p>Monads:</p>

<p>Labelled arrows that aren‚Äôt quite functions. Partial functions, Linear functions, Nondeterministic functions, random functions, state dependent functions.</p>

<p>bind is an awful lot like function application $.</p>

<p>Useful technique: Dumb write all the stuff you need to pass around, then try and push it all onto the right hand side. state dumbly = s -&gt; a -&gt; (s‚Äô , b) . Returns new state s‚Äô and result b when given original state s and argument a.</p>

<p>DRYing up function pipework (always error checking in every function).</p>

<p>It might tend to be better to understand and use monads without delving into their definition. They form their own language. (DSL) Undoing do notation in your head is a nightmare</p>

<p>CoMonad:</p>

<p>contextual arrow instead of effectful arrow</p>

<p>duplicate instead of join</p>

<p>Monad Transformers:</p>

<p>Stacking monads. That‚Äôs all I got.</p>

:ET