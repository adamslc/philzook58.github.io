I"%[<p>I’m a guy who is somewhat familiar with Haskell who is trying to learn Rust. So I thought I’d try to replicate some cool Haskell functionality in Rust. I would love to hear comments, because I’m trying to learn. I have no sense of Rust aesthetics yet and in particular I have no idea how this interacts with the borrow system. What follows is a pretty rough brain dump</p>

<p>GADTs (Generalized algebraic data types) are an extension in Haskell that allows you to write constrained type signatures for your data constructors. They also change how the type checking of pattern matching is processed.</p>

<p>GADTs are sometimes described/faked by being built by making data types that hold equality/unification constraints. Equality constraints in Haskell like <code class="language-plaintext highlighter-rouge">a ~ Int</code> are fairly magical and the Rust compiler does not support them in an obvious way. Maybe this is the next project. Figure out how to fake ’em if one can. I don’t think this is promising though, because faking them will be a little wonky, and then GADTs are a little wonky on top of that. See https://docs.rs/refl/0.1.2/refl/ So we’ll go another (related) road.</p>

<p>This is roughly what GADTs look like in Haskell.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data MyGadt a where
  TBool :: Bool -&gt; MyGadt Bool
  TInt :: Int -&gt; MyGadt Int
</code></pre></div></div>

<p>And here is one style of encoding using smart constructors and a typeclass for elimination (pattern matching is replicated as a function that takes callbacks for the data held in the different cases). Regular functions can have a restricted type signature than the most general one their implementation implies. The reason to use a typeclass is so that we can write the eliminator as returning the same type that the GADT supplies. There isn’t an explicit equality constraint. A kind of Leibnitz equality <code class="language-plaintext highlighter-rouge">(forall f. f a -&gt; f b)</code>is hiding in the eliminator. The Leibnitz equality can be used in place of (~) constraints at some manual cost. <a href="http://code.slipthrough.net/2016/08/10/approximating-gadts-in-purescript/"></a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data MyGadt2 a = TBool2 Bool | TInt2 Int
-- smart constructors. Hide the original constructors
tInt :: Int -&gt; MyGadt2 Int
tInt = TInt

tBool :: Bool -&gt; MyGadt2 Bool
tBool = TBool

-- gadt eliminator
class MyGadtElim a where
   elimMyGadt :: forall f. MyGadt2 a -&gt; (Bool -&gt; f Bool) -&gt; (Int -&gt; f Int) -&gt; f a

instance MyGadtElim Int where
   elimMyGadt (TInt2 x) fb fi = fi x
   elimMyGadt _ _ _ = error "How did TBool2 get type MyGadt2 Int?"
instance MyGadtElim Bool where
   elimMyGadt (TBool2 x) fb fi = fb x
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">forall f :: * -&gt; *</code> is a problem for Rust. Rust does not have higher kinded types, although they can be faked to some degree. https://gist.github.com/CMCDragonkai/a5638f50c87d49f815b8 There are murmurs of Associated Type Constructors / GATs , whatever those are , that help ease the pain, but I’m pretty sure they are not implemented anywhere yet.
I’m going to do something related, a defunctionalization of the higher kinded types. We make an application trait, that will apply the given type function tag to the argument. What I’m doing is very similar to what happens in the singletons library, so we may be getting some things for free.</p>

<p>https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">App1</span> <span class="p">{</span> <span class="k">type</span> <span class="n">T</span><span class="p">;}</span>
<span class="n">Then</span> <span class="n">in</span> <span class="n">order</span> <span class="n">to</span> <span class="n">define</span> <span class="n">a</span> <span class="n">new</span> <span class="n">typelevel</span> <span class="n">function</span> <span class="n">rip</span> <span class="n">out</span> <span class="n">a</span> <span class="n">quick</span> <span class="n">tag</span> <span class="k">type</span> <span class="n">and</span> <span class="n">an</span> <span class="n">App</span> <span class="k">impl</span><span class="py">.

struct</span> <span class="n">F1</span> <span class="p">{}</span>
<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">F1</span><span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It might be possible to sugar this up with a macro. It may also be possible to write typelevel functions in a point free style without defining new function tag names. The combinators Id, Comp, Par, Fst, Snd, Dup, Const are all reasonably definable and fairly clear for small functions. Also the combinator S if you want to talk SKI combinatory calculus, which is unfit for humans. https://en.wikipedia.org/wiki/SKI_combinator_calculus For currying, I used a number for how many arguments are left to be applied (I’m not sure I’ve been entirely consistent with these numbers). You need to do currying quite manually. It may be better to work with tuplized arguments</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Vec1</span> <span class="p">{}</span> <span class="c">// number is number of aspplications left.</span>
<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">Vec1</span><span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="nb">Vec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nf">Id</span><span class="p">();</span>

<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">Id</span><span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c">// partially applied const.</span>
<span class="c">// struct Const()</span>
<span class="c">// call this next one const1</span>
<span class="k">struct</span> <span class="nf">Const1</span><span class="p">();</span>
<span class="k">struct</span> <span class="nf">Const</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">);</span> <span class="c">// should be Const1</span>
<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">Const1</span> <span class="p">{</span> <span class="c">// partial application</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="nb">Const</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="nb">Const</span><span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span> 
<span class="p">}</span>



<span class="k">struct</span> <span class="n">Fst</span> <span class="p">{}</span>
<span class="k">impl</span>  <span class="n">App1</span><span class="o">&lt;</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Fst</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
<span class="p">}</span> 

<span class="k">struct</span> <span class="n">Snd</span> <span class="p">{}</span>
<span class="k">impl</span>  <span class="n">App1</span><span class="o">&lt;</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Snd</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>
<span class="p">}</span> 


<span class="k">struct</span> <span class="n">Dup</span><span class="p">{}</span>
<span class="k">impl</span>  <span class="n">App1</span> <span class="k">for</span> <span class="n">Dup</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span> 

<span class="k">struct</span> <span class="n">Par2</span> <span class="p">{}</span>
<span class="k">struct</span> <span class="nf">Par1</span> <span class="p">(</span><span class="n">PhantomData</span><span class="p">);</span>
<span class="k">struct</span> <span class="nf">Par</span> <span class="p">(</span><span class="n">PhantomData</span> <span class="p">,</span> <span class="n">PhantomData</span> <span class="p">);</span>
<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">Par2</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">Par1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">Par1</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">Par</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">App1</span><span class="o">&lt;</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Par</span> <span class="k">where</span> <span class="n">F</span> <span class="p">:</span> <span class="n">App1</span><span class="p">,</span> <span class="n">G</span> <span class="p">:</span> <span class="n">App1</span>  <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="nn">F</span><span class="p">::</span><span class="n">T</span><span class="p">,</span> <span class="nn">G</span><span class="p">::</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c">// In order to curry, i think I'd have to define a name for every curried form.</span>


<span class="c">// combinator calculus Const is K, Id is I, and here is S combinator. Yikes.</span>
<span class="k">type</span> <span class="n">I</span> <span class="o">=</span> <span class="n">Id</span><span class="p">;</span>
<span class="k">type</span> <span class="n">K</span> <span class="o">=</span> <span class="nb">Const</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">S3</span><span class="p">{}</span>
<span class="k">struct</span> <span class="nf">S2</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">);</span>
<span class="k">struct</span> <span class="nf">S1</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">,</span> <span class="n">PhantomData</span><span class="p">);</span>
<span class="c">// struct S(PhantomData, PhantomData, PhantomData);</span>
<span class="k">impl</span>  <span class="n">App1</span> <span class="k">for</span> <span class="n">S1</span> <span class="k">where</span> <span class="n">A</span> <span class="p">:</span> <span class="n">App1</span><span class="p">,</span> <span class="n">B</span> <span class="p">:</span> <span class="n">App1</span><span class="p">,</span> <span class="o">&gt;</span><span class="p">::</span><span class="n">T</span> <span class="p">:</span> <span class="n">App1</span><span class="o">&lt;</span> <span class="o">&gt;</span><span class="p">::</span><span class="n">T</span> <span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span>  <span class="o">&lt;</span> <span class="o">&gt;</span><span class="p">::</span><span class="n">T</span>   <span class="k">as</span> <span class="n">App1</span><span class="o">&lt;</span> <span class="o">&gt;</span><span class="p">::</span><span class="n">T</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">::</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>  


<span class="k">struct</span> <span class="nf">Comp2</span><span class="p">();</span>
<span class="k">struct</span> <span class="nf">Comp1</span> <span class="p">(</span><span class="n">PhantomData</span><span class="p">);</span>
<span class="k">struct</span> <span class="nf">Comp</span> <span class="p">(</span><span class="n">PhantomData</span><span class="p">,</span> <span class="n">PhantomData</span><span class="p">);</span>
<span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">Comp</span> <span class="k">where</span> <span class="n">G</span> <span class="p">:</span> <span class="n">App1</span><span class="p">,</span> <span class="n">F</span> <span class="p">:</span> <span class="n">App1</span><span class="o">&lt;&gt;</span><span class="p">::</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">T</span> <span class="o">=</span>  <span class="o">&gt;</span><span class="p">::</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>  
<span class="n">Anyway</span><span class="p">,</span> <span class="n">the</span> <span class="n">following</span> <span class="n">is</span> <span class="n">a</span> <span class="n">translation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">above</span> <span class="nf">Haskell</span> <span class="p">(</span><span class="n">well</span><span class="p">,</span> <span class="n">I</span> <span class="n">didn</span><span class="err">’</span><span class="n">t</span> <span class="n">wrap</span> <span class="n">an</span> <span class="n">actual</span> <span class="nb">i64</span> <span class="n">or</span> <span class="nb">bool</span> <span class="n">in</span> <span class="n">there</span> <span class="n">but</span> <span class="n">I</span> <span class="n">could</span> <span class="n">have</span> <span class="n">I</span> <span class="n">think</span><span class="p">)</span><span class="py">. You</span> <span class="n">need</span> <span class="n">to</span> <span class="n">hide</span> <span class="n">the</span> <span class="n">actual</span> <span class="n">constructors</span> <span class="n">labeled</span> <span class="n">INTERNAL</span> <span class="n">in</span> <span class="n">a</span> <span class="n">user</span> <span class="n">inaccessible</span> <span class="n">module</span><span class="py">.

enum</span> <span class="n">Gadt</span> <span class="p">{</span>
    <span class="nf">TIntINTERNAL</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">),</span>
    <span class="nf">TBoolINTERNAL</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">)</span>
    
<span class="p">}</span>
<span class="c">// then build the specialzied constructors that </span>
<span class="k">fn</span> <span class="nf">TBool</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Gadt</span><span class="p">{</span>
    <span class="nn">Gadt</span><span class="p">::</span><span class="nf">TBoolINTERNAL</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">TInt</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Gadt</span><span class="p">{</span>
    <span class="nn">Gadt</span><span class="p">::</span><span class="nf">TIntINTERNAL</span><span class="p">(</span><span class="n">PhantomData</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The smart constructors put the right type in the parameter spot</p>

<p>Then pattern matching is a custom trait per gadtified type. Is it possible to unify the different elimination traits that will come up into a single Elim trait? I’m 50-50 about whether this is possible. What we’re doing is a kind of fancy map_or_else if that helps you.</p>

<p>https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait GadtElim {
    type Inner;
fn gadtElim(&amp;self, case1 : &gt;::T   , case2 : &gt;::T ) -&gt; &gt;::T  where 
         F : App1,
         F : App1,
         F : App1;
         

}


impl GadtElim for Gadt {
    type Inner = i64;
    fn gadtElim(&amp;self, case1 : &gt;::T   , case2 : &gt;::T ) -&gt; &gt;::T  where 
         F : App1,
         F : App1,
         F : App1{
        match self{
            Gadt::TIntINTERNAL(PhantomData) =&gt; case2,
            Gadt::TBoolINTERNAL(PhantomData) =&gt; panic!("Somehow TBool has type Gadt")// Will never be reached though. god willing
        }
    }
}
impl GadtElim for Gadt {
    type Inner = bool;
    fn gadtElim(&amp;self, case1 : &gt;::T , case2 : &gt;::T ) -&gt; &gt;::T  where 
         F : App1,
         F : App1,
         F : App1{
        match self{
            Gadt::TIntINTERNAL(PhantomData) =&gt; panic!("Somehow TInt has type Gadt"),
            Gadt::TBoolINTERNAL(PhantomData) =&gt; case1 // Will never be reached though. god willing
        }
    }
}
</code></pre></div></div>
<p>Usage. You have to explicitly pass the return type function to the eliminator. No inference is done for you. It’s like Coq’s match but worse. BTW the dbg! macro is the greatest thing on earth. Well done, Rust.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nf">TInt</span><span class="p">()</span><span class="py">.gadtElim</span><span class="p">::(</span><span class="k">true</span> <span class="p">,</span> <span class="mi">34</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">z2</span> <span class="o">=</span> <span class="nf">TBool</span><span class="p">()</span><span class="py">.gadtElim</span><span class="p">::(</span><span class="k">true</span> <span class="p">,</span> <span class="mi">34</span><span class="p">);</span>

    <span class="nd">dbg!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
    <span class="nd">dbg!</span><span class="p">(</span><span class="n">z2</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">F7</span> <span class="p">{}</span> <span class="c">// You need to do this. Kind of sucks. macroify? App!(F = Vec)</span>
    <span class="k">impl</span> <span class="n">App1</span> <span class="k">for</span> <span class="n">F7</span> <span class="p">{</span> <span class="k">type</span> <span class="n">T</span> <span class="o">=</span> <span class="nb">Vec</span><span class="p">;</span> <span class="p">}</span>
    <span class="nd">dbg!</span><span class="p">(</span><span class="nf">TInt</span><span class="p">()</span><span class="py">.gadtElim</span><span class="p">::(</span><span class="nd">vec!</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="kc">false</span><span class="p">)</span> <span class="p">,</span> <span class="nd">vec!</span><span class="p">(</span><span class="mi">34</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">46</span><span class="p">)));</span>
</code></pre></div></div>
<p>You can make helpers that don’t require explicit types to be given</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">gadtRec</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="k">impl</span> <span class="n">GadtElim</span><span class="p">,</span> <span class="n">case1</span> <span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">case2</span> <span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">x</span><span class="py">.gadtElim</span><span class="p">::</span><span class="o">&gt;</span><span class="p">(</span><span class="n">case1</span> <span class="p">,</span> <span class="n">case2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>One could also make an Eq a b type with Refl similarly. Then we need typelevel function tags that take two type parameter. Which, with currying or tupling, we may already have.</p>

<p>Questions:</p>

<p>Is this even good? Or is it a road of nightmares? Is this even emulating GADTs or am I just playing phantom type games?</p>

<p>We aren’t at full gadt. We don’t have existential types. Rust has some kind of existential story evolving (already there?), but the state of it is confusing to me. Something to play with. Higher rank functions would help?</p>

<p>Are overlapping typeclasses a problem in Rust?</p>

<p>Again, I have given nearly zero thought to borrowing and how it interacts with this. I’m a Rust n00b. I should think about it. Different eliminators based on whether you own or are borrowing?.</p>

<p>How much of singleton style dependent types do we get from this? It feels like we have already paid the cost of defunctionalizing. http://hackage.haskell.org/package/singletons</p>

<p>My current playground for this is at <a href="https://github.com/philzook58/typo"></a></p>

<p>Edit: Rust is an ML with affine types and a syntax facelift roughly. So Ocaml is a good place to pump. Oleg Kiselyov had a fascinating approach that sort of smuggles through an Option type in an equality type using mutation. I wonder how well that would mesh with Rust. It seems obviously not thread safe unless you can make the mutation and matching atomic.</p>

<p><a href="http://okmij.org/ftp/ML/GADT.txt"></a></p>

<p><a href="okmij.org/ftp/ML/first-class-modules/"></a></p>

<p><a href="https://blog.janestreet.com/more-expressive-gadt-encodings-via-first-class-modules/"></a></p>
:ET