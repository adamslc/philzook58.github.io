I"ç<p>Graphviz is a graph visualization tool <a href="https://www.graphviz.org/">https://www.graphviz.org/</a>. In Conal Elliott‚Äôs Compiling to categories <a href="http://conal.net/papers/compiling-to-categories/">http://conal.net/papers/compiling-to-categories/</a>, compiling code to its corresponding graphviz representation was one very compelling example. These graphs are very similar to the corresponding string diagram of the monoidal category expression, but they also look like boolean circuit diagrams. Besides in Conal Elliott‚Äôs Haskell implementation, there is an implementation in the Julia Catlab.jl project <a href="https://epatters.github.io/Catlab.jl/stable/">https://epatters.github.io/Catlab.jl/stable/</a></p>

<p>I‚Äôve basically implemented a toy version of a similar thing in python. It lets you do things like this</p>

<p>[gist https://gist.github.com/philzook58/50209a590fb294849699e034875fd762#file-adder-py]</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2020/02/adders.png" alt="" /></p>

<p>Why python?</p>

<ul>
  <li>Python is the lingua franca of computing these days. Many people encounter it, even people whose main thing isn‚Äôt computers.</li>
  <li>The python ecosystem is nutso good.</li>
  <li>Julia is kind of an uphill battle for me. I‚Äôm fighting the battle ( <a href="https://github.com/philzook58/Rel.jl">https://github.com/philzook58/Rel.jl</a> ) , but I already know python pretty well. I can rip this out and move on.</li>
</ul>

<p>What I did was implement some wrappers around the graphviz python package. It exposes a not very feature rich stateful interface. It is pretty nice that it prints the graphs inline in jupyter notebooks though.</p>

<p>The code is written in a style very similar (and hopefully overloadable with)  to that of z3py relation algebra. <a href="http://www.philipzucker.com/a-sketch-of-categorical-relation-algebra-combinators-in-z3py/">http://www.philipzucker.com/a-sketch-of-categorical-relation-algebra-combinators-in-z3py/</a> . There is a fairly general cookbook method here for categorifying dsl.  Since graphviz does not directly expose fresh node creation as far as I can tell, I made my own using a random number generator. The actual combinators are graphviz object processors, so we build up a giant functional chain of processors and then actually execute it with <code class="language-plaintext highlighter-rouge">run</code>. The inputs and outputs are represented by lists of node names. The is some design space to consider here.</p>

<p>I also had to use class based wrappers Based on the precedent set by the python 3 matrix multiplication operator @, I think it is a requirement that this also be used for category composition. <code class="language-plaintext highlighter-rouge">id</code> is a keyword or something in python unfortunately. For monoidal product, I feel like overloading power ** looks nice even if it is a nonsensical analogy, * is also not too bad. I went with * for now.</p>

<p>The graphviz graphs aren‚Äôt quite string diagrams. They make no promise to preserve the ordering of your operations, but they seem to tend to.</p>

<p>[gist https://gist.github.com/philzook58/50209a590fb294849699e034875fd762#file-graphcat-py]</p>

<p>Here‚Äôs some example usage</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;cup = GraphCat.cup()
cap = GraphCat.cap()
d =  cap @ (I * I) @ cup  #(I * cap) @ (I * I * I) @ (cup * I) 
d.run()&lt;/code&gt;
</code></pre></div></div>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2020/02/cupcap.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;d = plus @ (GC.const(1) * GC.const(2))
d = d.run()
&lt;/code&gt;
</code></pre></div></div>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2020/02/adders-1.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;GC = GraphCat
f = GraphCat.named_simple("f")
g = GraphCat.named_simple("g")
I = GraphCat.idd()
dump = GC.dump()
dup = GC.dup()
diagram = ((f * I) @ dup @ g @ (dump * I)  @ (I * f) @ (f * f)) * g
diagram.run()&lt;/code&gt;
</code></pre></div></div>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2020/02/randomstuff.png" alt="" /></p>

<p>Class based overloading is the main paradigm of overloading in python. You overload a program into different categories, by making a program take in the appropriate category class as a parameter.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;# by passing in different category classes, we can make polymorphic functions
# They have to have a uniform interface though, which is hard to constrain in python.
def polymorphic_prog(M):
    idd = M.idd()
    dump = M.dump()
    dup = M.dup()
    return (idd * dump) @ dup
polymorphic_prog(GraphCat).run()&lt;/code&gt;
</code></pre></div></div>

<p>For example something like this ought to work. Then you can get the graph of some matrix computation to go along with it‚Äôs numpy implementation</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;class FinVect(np.ndarray):

    def compose(f,g):
        return f @ g
    def idd(n):
        return np.eye(n)
    def par(f,g):
        return np.kron(f,g)
    def __mult__(self,rhs):
        return np.kron(f,g)
# and so on. &lt;/code&gt;
</code></pre></div></div>

<p>Maybe outputting tikz is promising? <a href="https://github.com/negrinho/sane_tikz">https://github.com/negrinho/sane_tikz</a></p>

:ET