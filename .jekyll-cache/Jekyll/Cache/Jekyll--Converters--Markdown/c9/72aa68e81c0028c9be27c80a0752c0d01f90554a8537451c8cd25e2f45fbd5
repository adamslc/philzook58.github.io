I"ﬂË<p>I‚Äôve been reading about the Algebra of Programming lately and <em>lovin‚Äô it</em>. See <a href="http://www4.di.uminho.pt/~jno/ps/pdbc.pdf">J.N. Oliveira‚Äôs draft text</a> in particular and the links in the references. I‚Äôve started exploring the stuff from this post and more over here: <a href="https://github.com/philzook58/rel">https://github.com/philzook58/rel</a></p>

<h2 id="why-and-what">Why and What?</h2>

<p>Relations can expand the power of functional programming for the purpose of specification.</p>

<p>The point of a specification is to be able to write down in a very compact and clear way your intent for a program, more clearly and compactly than a full implementation could be written. It therefore makes sense to add to your specification language constructs that are not necessarily executable or efficient for the sake of compactness and clarity.  When one needs executability or efficiency, one writes an implementation whose behavior you can connect to the spec via a formal or informal process.</p>

<p>Functional programming, with it‚Äôs focus on the abstraction of the mathematical function, is a good trade-off between executability, efficiency, and expressibility. It lies in a reasonable location between the ideas amenable to reasoning by a human mind and the command-driven requirements of the machines.</p>

<p>Functions are a specialization of relations. Relations extend the mathematical notion of functions with constructs like nondeterministic choice, failure and converse. These constructs are not always obviously executable or efficient. However, they greatly extend the abilities of reasoning and the clarity of expression of a specification.</p>

<p>The point-free style of reasoning about functions extends to a point-free style reasoning about relations, which is known as <a href="https://en.wikipedia.org/wiki/Relation_algebra">relation algebra</a>. There are rich analogies with databases, category theory, linear algebra, and other topics.</p>

<p>Plus, I think it is very neato for some reason. If anyone ever thinks something is really neato, isn‚Äôt it worth giving it a listen?</p>

<h3 id="a-simple-representation-of-relations-in-haskell">A Simple Representation of Relations in Haskell</h3>

<p>The simplest description of relations is as a set of tuples. So first let‚Äôs talk a bit about the options for sets in Haskell.</p>

<h4 id="sets-in-haskell">Sets in Haskell</h4>

<p>There are a couple different reasonable ways to represent sets in Haskell.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[a]</code> or <code class="language-plaintext highlighter-rouge">Vector a</code></li>
  <li>a -&gt; Bool</li>
  <li><code class="language-plaintext highlighter-rouge">Set a</code> ‚Äì a tree based Set from the <a href="http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html">containers</a> package.</li>
</ul>

<p>These have different performance characteristics and different power. The list <code class="language-plaintext highlighter-rouge">[a]</code> is very simple and has specialized pleasant syntax available. The indicator function <code class="language-plaintext highlighter-rouge">a -</code>&gt; <code class="language-plaintext highlighter-rouge">Bool</code> gives you no ability to produce values of type <code class="language-plaintext highlighter-rouge">a</code>, but can easily denote very sophisticated spaces. <code class="language-plaintext highlighter-rouge">Set a</code> is a good general purpose data structure with fast lookup. You might also choose to mix and match combinations of these. Interconversion is often possible, but expensive. This is not a complete list of possibilities for sets, for example you may want a representation with a <a href="http://eptcs.web.cse.unsw.edu.au/paper.cgi?MSFP2014.3">stronger possibility for search</a>.</p>

<h4 id="relations-in-haskell">Relations in Haskell</h4>

<p>We can directly use the definition of relations as a set of tuples with the above</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span>
<span class="kr">type</span> <span class="kt">SetRel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Set</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">FunRel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p>But we also have the option to ‚Äúcurry‚Äù  our relation representations, sort of mixing and matching properties of these representations.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">List</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="c1">-- Commonly seen type  in List monad/logic programming</span>
<span class="kr">type</span> <span class="kt">MapRel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Map</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>You might also choose to package up multiples of these representations, choosing the most appropriate as the situation requires, see for example the <a href="http://hackage.haskell.org/package/relation-0.2.1/docs/Data-Relation.html">relation</a> package, whose type holds both <code class="language-plaintext highlighter-rouge">Map a (Set b)</code> and <code class="language-plaintext highlighter-rouge">Map b (Set a)</code>.</p>

<p>Despite fiendishly poor performance, for simplicity and list comprehension syntax we are going to be using <code class="language-plaintext highlighter-rouge">type Rel a b = [(a,b)]</code> for the remainder of the post.</p>

<p>I‚Äôm also taking the restriction that we‚Äôre working in bounded enumerable spaces for ease. I assume such a requirement can be lifted for many purposes, but finite spaces like these are especially well tamed. The following typeclass and definition is very useful in this case.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">BEnum</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Enum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Bounded</span> <span class="n">a</span><span class="p">)</span> 
<span class="n">enumAll</span> <span class="o">::</span> <span class="p">(</span><span class="kt">BEnum</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">enumAll</span> <span class="o">=</span> <span class="p">[</span><span class="n">minBound</span> <span class="o">..</span> <span class="n">maxBound</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="functions-and-relations">Functions and Relations</h4>

<p>Functions can be thought of as relations with the special property that for each left part of the tuple, there is exactly one right side and every possible left side appears. The relation corresponding to a function $ f$ looks like \(F = \{(x,y) \vert x \in X, y \in Y, y = f (x)\}\).</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">tabulate</span> <span class="o">::</span> <span class="p">(</span><span class="kt">BEnum</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">tabulate</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">]</span>
</code></pre></div></div>

<p>There is a natural and slightly clever lifting of function composition to relations. We now check whether there exists a value that is in the right side of one and the left side of the other.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">rcompose</span> <span class="o">::</span> <span class="kt">Eq</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">b</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">c</span>
<span class="n">rcompose</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="p">,</span> <span class="p">(</span><span class="n">b'</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">b'</span> <span class="o">==</span> <span class="n">b</span><span class="p">]</span>

<span class="n">rid</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Enum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Bounded</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">a</span>
<span class="n">rid</span> <span class="o">=</span> <span class="n">tabulate</span> <span class="n">id</span>
</code></pre></div></div>

<p>Because of these two operations (and their properties of associativity and absorption), <a href="https://ncatlab.org/nlab/show/Rel">FinRel is a category</a>. We do however need the <code class="language-plaintext highlighter-rouge">Eq b</code> restriction to make <code class="language-plaintext highlighter-rouge">Rel</code> an instance of the category typeclass, so it does not quite fit the definition of <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Category.html">category in base</a>. It is a <a href="http://hackage.haskell.org/package/constrained-categories">constrained category</a>.</p>

<p>We can lift the common arrow/categorical combinators up to relations for example.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">-- arrow/category combinators</span>
<span class="n">rfan</span> <span class="o">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> 
<span class="n">rfan</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">a'</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a'</span><span class="p">]</span>

<span class="n">rfst</span> <span class="o">::</span> <span class="kt">BEnum</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">a</span> 
<span class="n">rfst</span> <span class="o">=</span> <span class="n">tabulate</span> <span class="n">fst</span> 

<span class="n">rsnd</span> <span class="o">::</span> <span class="kt">BEnum</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">b</span> 
<span class="n">rsnd</span> <span class="o">=</span> <span class="n">tabulate</span> <span class="n">snd</span>

<span class="n">rleft</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Enum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Bounded</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> 
<span class="n">rleft</span> <span class="o">=</span> <span class="n">tabulate</span> <span class="kt">Left</span>

<span class="n">rright</span> <span class="o">::</span> <span class="kt">BEnum</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">b</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> 
<span class="n">rright</span> <span class="o">=</span> <span class="n">tabulate</span> <span class="kt">Right</span>

<span class="n">reither</span> <span class="o">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">b</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">c</span> 
<span class="n">reither</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">f</span><span class="p">]</span> <span class="o">++</span> <span class="p">[(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">g</span><span class="p">]</span> 

</code></pre></div></div>

<p>With these combinators, you have access to many functions on basic non-recursive algebraic data types. By combining them in a point free style, you can build some other useful combinators.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">--- goofy inefficient definitions</span>
<span class="n">dup</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="n">dup</span> <span class="o">=</span> <span class="n">rfan</span> <span class="n">rid</span> <span class="n">rid</span>
<span class="n">swap</span> <span class="o">::</span><span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="n">swap</span> <span class="o">=</span> <span class="n">rfan</span> <span class="n">rsnd</span> <span class="n">rfst</span>
<span class="n">par</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">c</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">c</span> <span class="n">d</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> 
<span class="n">par</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span>  <span class="n">rfan</span> <span class="p">(</span><span class="n">rcompose</span> <span class="n">f</span> <span class="n">rfst</span><span class="p">)</span> <span class="p">(</span><span class="n">rcompose</span> <span class="n">g</span> <span class="n">rsnd</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="an-aside-relations-linear-algebra-databases">An Aside: Relations, Linear Algebra, Databases</h4>

<p>The composition operation described above is not so unfamiliar as it may first appear.</p>

<p>Relation algebra has a <a href="https://arxiv.org/pdf/1809.00641.pdf">great similarity to linear algebra</a>. This connection can be made more clear by considering sparsity patterns of matrices and tensors. Sparsity patterns are a useful abstraction of linear algebraic operations. Instead of considering matrices of numbers, instead the entries are ‚Äúzero‚Äù and ‚Äúpossibly nonzero‚Äù or, if you prefer, a matrix of boolean values corresponding to those same questions.</p>

<p>The ordinary row times column matrix multiplication corresponds to relation composition. Replace * with AND  and + with OR. If any of the numbers is zero, then multiplying them will result in zero. In summing two numbers, if either is possibly nonzero, then the result is possibly nonzero.</p>

<p>Another interesting way of looking at it is that we are replacing the summation binding form $ \sum_i$ with the logical  quantifier $ \exists_i$. Both introduce a scoped ‚Äúdummy variable‚Äù  i and have a lot of syntactic similarity. Other related forms include $ \lambda i$, $ \forall i$, $ \int di$,  $ \max_i$ .</p>

<p>There is also an analog of the point free relation algebra in linear algebra. Linear algebra has the most widely used point free notation in the world, matrix notation. Consider the expressions $ Ax=b$ and $ X = ABC$ as compared to $ \sum_j A_{ij} x_j = b_i$ and $ X_{il} = \sum_{jk} A_{ij} B_{jk} C_{kl} $. Matrix notation is SO much better for certain calculations. Other pieces of the matrix notation include transpose, inverse, Kronecker product, the Khatri-Rao product, and Hadamard product. Their properties are more clear in the index free form in my opinion. I believe even massive tensor expressions can be written index free using these operators. There are also analogies to be drawn between the <a href="http://math.ucr.edu/home/baez/rosetta.pdf">graphical notations in these different fields</a>.</p>

<p>Databases can be thought of very similarly to sparse matrices. In principle, you could enumerate all the possible values for a column of a database. So you could think of a database as a giant matrix with a 1 if the item is in the database and 0 if not. Databases are very very sparse from this perspective, and you would never store them this way. The join operation is a relative of relational composition, however join usually operates via looking at the column names, whereas our join is position based.</p>

<p><a href="https://en.wikipedia.org/wiki/Query_optimization">Query optimization</a> in databases has interesting analogs in sparse linear algebra.  For example, the Taco compiler <a href="http://tensor-compiler.org/">http://tensor-compiler.org/</a> is doing something very akin to a query optimizer.</p>

<h4 id="inverting-relations">Inverting Relations</h4>

<p>Unlike functions, Relations are always ‚Äúinvertible‚Äù.  We call this the converse of a relation. When a function is invertible, it corresponds to the converse. In terms of the tuples underlying our representation, it just swaps them. Relations also possess operations <code class="language-plaintext highlighter-rouge">trans</code> and <code class="language-plaintext highlighter-rouge">untrans</code> that may be thought of as a kind of currying or as a partial inverse on a single parameter.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">converse</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">b</span> <span class="n">a</span>
<span class="n">converse</span> <span class="o">=</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">r</span><span class="p">]</span>

<span class="n">untrans</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">c</span>
<span class="n">untrans</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span><span class="n">c</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">))</span> <span class="o">&lt;-</span> <span class="n">r</span><span class="p">]</span>

<span class="n">trans</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">trans</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">))</span><span class="o">|</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span><span class="n">c</span><span class="p">)</span>  <span class="o">&lt;-</span> <span class="n">r</span><span class="p">]</span>
</code></pre></div></div>

<p>Orderings can also be lifted to relations \((\leq) = \{ (a,b) \vert a \leq b \}\) . The composition of relations also respects the usual composition of ordering.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">reflectOrd</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">a</span>
<span class="n">reflectOrd</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">]</span>
</code></pre></div></div>

<p>Nondeterministic choice is sometimes represented in Haskell using Set returning functions <code class="language-plaintext highlighter-rouge">a -&gt; [b]</code>. You may recall this from the context of the List monad. In fact in this case, we have an isomorphism as evidenced by <code class="language-plaintext highlighter-rouge">tabulateSearch</code> and <code class="language-plaintext highlighter-rouge">searchRel</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">tabulateSearch</span> <span class="o">::</span> <span class="kt">BEnum</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">tabulateSearch</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">,</span> <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">f</span> <span class="n">a</span><span class="p">]</span>

<span class="n">searchRel</span> <span class="o">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span>
<span class="n">searchRel</span> <span class="n">r</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">|</span> <span class="p">(</span><span class="n">a'</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">r</span><span class="p">,</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a'</span><span class="p">]</span>
</code></pre></div></div>

<p>Similarly partial functions can be reflected into relations</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">tabulatePartial</span> <span class="o">::</span> <span class="kt">BEnum</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">tabulatePartial</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">,</span> <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">toList</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)]</span>
</code></pre></div></div>

<p>A useful trick is to lift sets/subsets to relations as a diagonal relation. \(\{(a,a) \vert a \in S \}\). Projection onto the set can be achieve by composing with this relation. The identity results if you are talking about the entire set S.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">diagRel</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">a</span>
<span class="n">diagRel</span> <span class="o">=</span> <span class="n">map</span> <span class="n">dup</span> <span class="kr">where</span> <span class="n">dup</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

<span class="n">leftSet</span> <span class="o">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">leftSet</span> <span class="o">=</span> <span class="n">nub</span> <span class="o">.</span> <span class="p">(</span><span class="n">map</span> <span class="n">fst</span><span class="p">)</span>

<span class="n">rightSet</span> <span class="o">::</span> <span class="kt">Eq</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">rightSet</span> <span class="o">=</span> <span class="n">nub</span> <span class="o">.</span> <span class="p">(</span><span class="n">map</span> <span class="n">snd</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="comparing-relations">Comparing Relations</h4>

<p>We can compare sets by asking if one is a subset of the other $ A\subseteq B$ . Relations can also be compared by this operation, which we call relational inclusion.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">rSub</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">rSub</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">and</span> <span class="p">[</span><span class="n">x</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">ys</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>

<span class="n">x</span> <span class="o">&lt;~</span> <span class="n">y</span> <span class="o">=</span> <span class="n">rSub</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div></div>

<p>A subservient notion to this is relational equality.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="n">rEq</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">rEq</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs</span> <span class="p">`</span><span class="n">rSub</span><span class="p">`</span> <span class="n">ys</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ys</span> <span class="p">`</span><span class="n">rSub</span><span class="p">`</span> <span class="n">xs</span><span class="p">)</span>

<span class="n">x</span> <span class="o">~~</span> <span class="n">y</span> <span class="o">=</span> <span class="n">rEq</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div></div>

<p>Relational algebra is chockful of inequality style reasoning, which is richer and slightly more complicated than equality style reasoning. This is one of the benefits of moving from functional descriptions to a relational description.</p>

<p>Relations also form a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice</a> with respect to these comparisons. What the hell are lattices? In the context of finite relations, lattices may be over powered mathematical machinery, but it really is useful down the line.  They give you binary operators that play nice with some kind of ordering, in our case relational inclusion. These two operations are the meet and the join, which find the greatest lower bound and least upper bound  of the operands respectively. For our relations, these correspond to the more familiar notion of set intersection and union. The intersection of two sets is the biggest set that is in both of them. The union is the smallest set for which both sets are a subset of it.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">meet'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">meet'</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">ys</span><span class="p">]</span> <span class="c1">-- intersection</span>

<span class="n">join'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">join'</span> <span class="n">p</span> <span class="n">q</span> <span class="o">=</span> <span class="n">nub</span> <span class="p">(</span><span class="n">p</span> <span class="o">++</span> <span class="n">q</span><span class="p">)</span> <span class="c1">-- union</span>


<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Lattice</span> <span class="p">(</span><span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">x</span> <span class="o">/\</span> <span class="n">y</span> <span class="o">=</span> <span class="n">meet'</span> <span class="n">x</span> <span class="n">y</span>
    <span class="n">x</span> <span class="o">\/</span> <span class="n">y</span> <span class="o">=</span> <span class="n">join'</span> <span class="n">x</span> <span class="n">y</span>

</code></pre></div></div>

<p>Using meet/join vs intersection/union becomes more interesting when the domain is fancier than relations over finite domains. Issues of infinity can make this interesting, or when using a representation that can‚Äôt explicitly represent arbitrary unions or intersections, but that instead has to approximate them. My favorite example is polyhedra. Polyhedra are not closed under unions. So in this case the join and union do not coincide. You need to take a convex hull of the union instead, which is the best approximation.  Concretely, polyhedra can be represented as a list of their vertices, which generate the polyhedron. There is no way to express a union in this representation. Concatenating the lists represents taking the convex hull of the union.</p>

<p>An additional property that a lattice may possess is a largest and small element, called top ($ \top$ ) and bottom ($ \bot$). Our finite domain relations do have these.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">BoundedMeetSemiLattice</span> <span class="p">(</span><span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">top</span> <span class="o">::</span> <span class="p">(</span><span class="kt">BEnum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> 
    <span class="n">top</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">]</span>
<span class="c1">-- all possible tuples</span>

<span class="c1">-- because of superclass constraints :(</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">BoundedJoinSemiLattice</span> <span class="p">(</span><span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">bottom</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span> <span class="c1">-- no tuples</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="kt">[]</span> 
</code></pre></div></div>

<h4 id="relational-division">Relational Division</h4>

<p>And now finally we get to one of the most interesting, powerful, and confusing operations: relational division. Relational division is a kind of pseudo inverse to relational composition. In linear algebra, the pseudo inverse is a matrix that does the best job it can to invert another matrix in a least squares sense. If the matrix is actually invertible, it equals the inverse. Relational division does the best job it can to invert a relational composition. Instead of taking least squares as a criteria, it ensures that the result doesn‚Äôt over approximate. If you had the inequality $ X \cdot Y \subseteq Z$ and you want to  solve for X, relational division is the thing that does that. The right division $ Q = Z/Y$ is the largest relation such that $ Q \cdot Y \subseteq Z$.</p>

<p>A helpful example is the similar <a href="https://en.wikipedia.org/wiki/Relational_algebra#Division">operation of division in database tables</a>.</p>

<p>And here is an implementation that I think is correct. I‚Äôve goofed it up a couple times, it is a rather confusing construct.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">rdiv</span> <span class="o">::</span> <span class="p">(</span><span class="kt">BEnum</span> <span class="n">a</span><span class="p">,</span> <span class="kt">BEnum</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">b</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">rdiv</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>  <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">,</span> <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">enumAll</span><span class="p">,</span> <span class="n">all</span> <span class="p">(</span><span class="nf">\</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">y</span><span class="p">)`</span><span class="n">implies</span><span class="p">`</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">x</span><span class="p">))</span> <span class="p">(</span><span class="n">rightSet</span> <span class="n">y</span><span class="p">)]</span>
</code></pre></div></div>

<p>There also exists a very similar operation of <code class="language-plaintext highlighter-rouge">ldiv</code>.</p>

<p>Relational division encapsulates many notions of searching or optimizing. I invite you to read more about it in J.N. Oliveira‚Äôs text or the Bird &amp; de Moor text.</p>

<h3 id="properties-and-quickcheck">Properties and QuickCheck</h3>

<p><img src="/assets/sketch1562042676469-576x1024.png" alt="Oh. Mah. Glob. You guys. So many properties. " /></p>

<p>(Artwork courtesy of David)</p>

<p>Relation algebra is so chock full of properties. This is a perfect opportunity for some <a href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">QuickCheck </a>, a randomized property testing framework. There are so many more to test. I need to dig through to collect up all the identities.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kr">type</span> <span class="kt">R1</span> <span class="o">=</span> <span class="kt">Rel</span> <span class="kt">Bool</span> <span class="kt">Ordering</span>

<span class="n">prop_ridleft</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="kt">Bool</span> <span class="kt">Ordering</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_ridleft</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rid</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">~~</span> <span class="n">x</span>

<span class="n">prop_ridright</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="kt">Bool</span> <span class="kt">Ordering</span>  <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_ridright</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">rid</span><span class="p">)</span> <span class="o">~~</span> <span class="n">x</span>

<span class="n">prop_meet</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">R1</span>  <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_meet</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/\</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;~</span> <span class="n">x</span>

<span class="n">prop_meet'</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">R1</span>  <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_meet'</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/\</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;~</span> <span class="n">y</span>

<span class="n">prop_join_univ</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_join_univ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">\/</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;~</span> <span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;~</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;~</span> <span class="n">z</span><span class="p">))</span>

<span class="n">prop_join</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">R1</span>  <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_join</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&lt;~</span> <span class="p">(</span><span class="n">x</span> <span class="o">\/</span> <span class="n">y</span><span class="p">)</span> 

<span class="n">prop_meet_univ</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_meet_univ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;~</span> <span class="p">(</span><span class="n">x</span> <span class="o">/\</span> <span class="n">y</span><span class="p">))</span> <span class="o">==</span> <span class="p">((</span><span class="n">z</span> <span class="o">&lt;~</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;~</span> <span class="n">y</span><span class="p">))</span>

<span class="n">prop_top</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_top</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;~</span> <span class="n">top</span>

<span class="n">prop_bottom</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_bottom</span> <span class="n">x</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">&lt;~</span> <span class="n">x</span>

<span class="n">prop_bottom'</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_bottom'</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">~~</span> <span class="p">(</span><span class="n">bottom</span> <span class="o">::</span> <span class="kt">R1</span><span class="p">)</span>

<span class="n">prop_trans_iso</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Ordering</span><span class="p">)</span> <span class="kt">Word8</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_trans_iso</span> <span class="n">x</span> <span class="o">=</span> <span class="n">untrans</span> <span class="p">(</span><span class="n">trans</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span>

<span class="n">prop_rdiv</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="kt">Bool</span> <span class="kt">Ordering</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="kt">Word8</span> <span class="kt">Ordering</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_rdiv</span> <span class="n">g</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;&lt;</span> <span class="p">(</span><span class="n">rdiv</span> <span class="n">g</span> <span class="n">j</span><span class="p">))</span> <span class="o">&lt;~</span> <span class="n">g</span>

<span class="n">prop_con</span> <span class="o">::</span> <span class="kt">R1</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_con</span> <span class="n">x</span> <span class="o">=</span> <span class="n">con</span> <span class="p">(</span><span class="n">con</span> <span class="n">x</span><span class="p">)</span> <span class="o">~~</span> <span class="n">x</span>

<span class="n">prop_rdiv'</span> <span class="o">::</span> <span class="kt">Rel</span> <span class="kt">Bool</span> <span class="kt">Word8</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="kt">Bool</span> <span class="kt">Ordering</span> <span class="o">-&gt;</span> <span class="kt">Rel</span> <span class="kt">Word8</span> <span class="kt">Ordering</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">prop_rdiv'</span> <span class="n">x</span> <span class="n">g</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;~</span> <span class="p">(</span><span class="n">rdiv</span> <span class="n">g</span> <span class="n">j</span><span class="p">))</span> <span class="o">==</span> <span class="p">((</span><span class="n">j</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;~</span> <span class="n">g</span><span class="p">)</span> 

</code></pre></div></div>

<h3 id="bits-and-bobbles">Bits and Bobbles</h3>

<ul>
  <li>Relations over continuous spaces. Vector subspaces (Linear Relations), Polyhedra (Linear inequality relations).</li>
  <li>Non Bool-valued Relations. Replace $ \exists_x$ with $ \max_x$. The weighted edgelist of a graph is a natural relation. By using composition we can ask about paths. We still have a comparison operator $ \subseteq $ which now respects the ordering of weights</li>
  <li><a href="https://www.sciencedirect.com/science/article/pii/S1567832612000525">Galois connections are cool.</a></li>
  <li>Relations combined with recursion schemes. Recursion schemes are the point free way of describing recursion.</li>
  <li>Moving into infinite spaces. How do we cope?</li>
  <li>Faster search. Some relations are best specified by functions, Maps,  others, mixes and matching.</li>
  <li>If you ‚Äúsingletonize‚Äù relations a la the Agda project <a href="https://github.com/scmu/aopa">https://github.com/scmu/aopa</a>, you get very interesting <a href="https://github.com/philzook58/rel/blob/master/src/ProRel.hs">interconnections with profunctor</a>s, which people say are a <a href="https://bartoszmilewski.com/2016/07/25/profunctors-as-relations/">categorical generalization of relations</a>.</li>
  <li><a href="http://conal.net/papers/compiling-to-categories/">Point-free DSLs are interesting and pleasant</a>. Many worries about alpha renaming are gone, at the expense of point-free pain. A DSL like this may be necessary to choose good relational query plans</li>
</ul>

<p>Edit: A follow up post on that type level angle here <a href="http://www.philipzucker.com/relational-algebra-with-fancy-types/">http://www.philipzucker.com/relational-algebra-with-fancy-types/</a></p>

<h3 id="references">References</h3>

<ul>
  <li><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=2ahUKEwj03e7d9r7iAhVodt8KHaf1DAUQFjAAegQIAhAC&amp;url=http%3A%2F%2Fwww4.di.uminho.pt%2F~jno%2Fps%2Fpdbc.pdf&amp;usg=AOvVaw0rK14EmhIYhNl_Kar8jshY">www4.di.uminho.pt/~jno/ps/pdbc.pdf</a> JN Oliveira Program Design By Calculation draft</li>
  <li><a href="https://themattchan.com/docs/algprog.pdf">https://themattchan.com/docs/algprog.pdf</a> algebra of programming textbook</li>
  <li><a href="https://en.wikipedia.org/wiki/Relation_algebra">https://en.wikipedia.org/wiki/Relation_algebra</a></li>
  <li><a href="https://github.com/scmu/aopa">https://github.com/scmu/aopa</a></li>
  <li><a href="https://www.sciencedirect.com/science/article/pii/S1567832612000525">https://www.sciencedirect.com/science/article/pii/S1567832612000525</a> Programming from Galois Connections</li>
  <li>http://www.cs.tau.ac.il/~msagiv/courses/asv/absint-1.pdf Abstract interpetation notes</li>
  <li><a href="https://forum.azimuthproject.org/discussion/1828/lecture-4-chapter-1-galois-connections">https://forum.azimuthproject.org/discussion/1828/lecture-4-chapter-1-galois-connections</a> John Baez on Galois connections <a href="https://www.azimuthproject.org/azimuth/show/Applied+Category+Theory+Course#Course">https://www.azimuthproject.org/azimuth/show/Applied+Category+Theory+Course#Course</a></li>
  <li>Backhouse algebra of programming for graphs <a href="http://www.cs.nott.ac.uk/~psarb2/MPC/BasicGraphTheory.pdf">http://www.cs.nott.ac.uk/~psarb2/MPC/BasicGraphTheory.pdf</a></li>
  <li><a href="http://relmics.mcmaster.ca/html/index.html">http://relmics.mcmaster.ca/html/index.html</a></li>
</ul>

<p>Edit : A math exchange question about <code class="language-plaintext highlighter-rouge">a -&gt; [b]</code> relational type. <a href="https://math.stackexchange.com/questions/3360026/can-division-be-expressed-intensionally-in-relation-algebra/3361351#3361351">https://math.stackexchange.com/questions/3360026/can-division-be-expressed-intensionally-in-relation-algebra/3361351#3361351</a></p>

<p>Edit: An interesting comment and related library from /u/stevana</p>

<p><a href="https://www.reddit.com/r/haskell/comments/c8bdpk/a_short_skinny_on_relations_towards_the_algebra/eslwxp7/">Comment</a> from discussion <a href="https://www.reddit.com/r/haskell/comments/c8bdpk/a_short_skinny_on_relations_towards_the_algebra/">A Short Skinny on Relations towards the Algebra of Programming - Hey There Buddo!</a>.</p>

:ET