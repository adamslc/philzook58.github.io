I"pπ<p>Dumping these notes out there as is. Some material is out of date. Hope they‚Äôre useful.</p>

<h1 id="what-is-drake">What is Drake?</h1>

<p>From the Drake Website (<a href="https://drake.mit.edu/">https://drake.mit.edu/</a>):</p>

<p>‚ÄúDrake (‚Äúdragon‚Äù in Middle English) is a C++ toolbox started by the Robot Locomotion Group at the MIT Computer Science and Artificial Intelligence Lab (CSAIL). The development team has now grown significantly, with core development led by the Toyota Research Institute. It is a collection of tools for analyzing the dynamics of our robots and building control systems for them, with a heavy emphasis on optimization-based design/analysis.</p>

<p>While there are an increasing number of simulation tools available for robotics, most of them function like a black box: commands go in, sensors come out. Drake aims to simulate even very complex dynamics of robots (e.g. including friction, contact, aerodynamics, ‚Ä¶), but always with an emphasis on exposing the structure in the governing equations (sparsity, analytical gradients, polynomial structure, uncertainty quantification, ‚Ä¶) and making this information available for advanced planning, control, and analysis algorithms. Drake provides interfaces to high-level languages (MATLAB, Python, ‚Ä¶) to enable rapid-prototyping of new algorithms, and also aims to provide solid open-source implementations for many state-of-the-art algorithms. Finally, we hope Drake provides many compelling examples that can help people get started and provide much needed benchmarks. We are excited to accept user contributions to improve the coverage.‚Äù</p>

<p>Drake is a powerful toolkit for the control of dynamical systems, and I hope I lower some of the barrier to entry with this post. Be forewarned, Drake changes quickly with time, and some of the following may be out of date (especially the rigid body trees) or ill advised. Use your judgement.</p>

<h1 id="getting-drake">Getting Drake</h1>

<p>Drake may be installed from binaries or source. Both may be gotten here:</p>

<p><a href="https://drake.mit.edu/installation.html">https://drake.mit.edu/installation.html</a></p>

<h1 id="using-bazel">Using Bazel</h1>

<p>Drake uses Bazel as a build tool. Bazel is an open-source build and test tool similar to Make, Maven, and Gradle.</p>

<p>There are three commands that you need to know:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bazel build</code></li>
  <li><code class="language-plaintext highlighter-rouge">bazel run</code></li>
  <li><code class="language-plaintext highlighter-rouge">bazel query</code></li>
</ul>

<p>Query is very useful for investigating available binaries within the examples folder and elsewhere.</p>

<p>The notation <code class="language-plaintext highlighter-rouge">//</code> is used to refer to the build‚Äôs main directory. This corresponds to the drake folder.</p>

<p><code class="language-plaintext highlighter-rouge">...</code> is the notation for everything in the subdirectory</p>

<p>Examples:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bazel build //...</code> will build everything in the project.</li>
  <li>To query all the binaries available for tools run <code class="language-plaintext highlighter-rouge">bazel query //tools/...</code></li>
</ul>

<h1 id="using-pydrake">Using Pydrake</h1>

<p>Drake can be run natively in C++, or by using its MATLAB, python, or Julia bindings. This manual will be focusing on using Drake in python. By default pydrake will not be in the path. You can put pydrake into the path after building by running the following line or adding it to your .bashrc</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;export PYTHONPATH=~/drake/drake-build/install/lib/python2.7/site-packages:${PYTHONPATH}&lt;/code&gt;
</code></pre></div></div>

<p>The following line will import everything in Drake into the python namespace.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;from pydrake.all import *&lt;/code&gt;
</code></pre></div></div>

<p>Drake is only compatible with python 2.7. If your default system install is <code class="language-plaintext highlighter-rouge">python3</code>, you may need to explicitly run the command <code class="language-plaintext highlighter-rouge">python2</code>.</p>

<p>The following message may be thrown if you inadvertently use <code class="language-plaintext highlighter-rouge">python3</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;Traceback (most recent call last):
File "inverse_kinematics.py", line 2, in &lt;module&gt;
from pydrake.all import

...

ImportError: dynamic module does not define module export function (PyInit__common_py)&lt;/code&gt;
</code></pre></div></div>

<p>Pydrake itself has generated documentation available here:</p>

<p><a href="http://drake.mit.edu/pydrake/index.html">http://drake.mit.edu/pydrake/index.html</a></p>

<p>This is an extremely useful resource.</p>

<p>A very useful tool for exploring and confirming the Drake functionality and syntax is the python REPL. From the python REPL or within your code, it is useful to inspect an object using either <code class="language-plaintext highlighter-rouge">help(obj)</code> or <code class="language-plaintext highlighter-rouge">print(dir(obj))</code> which will print a list of all the properties available on your object.</p>

<h1 id="drake-resources">Drake resources</h1>

<h2 id="doxygen">Doxygen</h2>

<p>Besides the source code itself, the most accurate and up to date information is available in searchable form on the Doxygen page. This is a useful reference, but can be overwhelming.</p>

<p><a href="https://drake.mit.edu/doxygen_cxx/index.html">https://drake.mit.edu/doxygen_cxx/index.html</a></p>

<h2 id="underactuated-robotics-textbook-and-examples">Underactuated Robotics textbook and examples</h2>

<p>Drake has a textbook being built alongside it by Russ Tedrake.</p>

<p><a href="http://underactuated.mit.edu/underactuated.html">http://underactuated.mit.edu/underactuated.html</a></p>

<p>In particular the python source used to generate some of the examples in the book is worth examining.</p>

<p><a href="https://github.com/RussTedrake/underactuated/tree/master/src">https://github.com/RussTedrake/underactuated/tree/master/src</a></p>

<p>The full course is available online both on Edx and more recent versions on Youtube.</p>

<p><a href="http://underactuated.csail.mit.edu/Spring2018/">http://underactuated.csail.mit.edu/Spring2018/</a></p>

<h2 id="examples-directory">Examples directory.</h2>

<p>A useful source of use cases for drake can be found in the examples directory within the Drake project. As of October 2018 the contents include:</p>

<ul>
  <li>Cartpole - The cartpole is a classic control system consisting of a pendulum attached to a linearly actuated cart. In this directory you can find examples</li>
  <li>Pendulum</li>
  <li>Double Pendulum</li>
  <li>Acrobot - The Acrobot is a double pendulum system actuated at the shoulder</li>
  <li>Kinova Jaco Arm - A commercially available robotic arm</li>
  <li>Kuka Iiwa Arm - A commerically available robotic arm</li>
  <li>Particles</li>
  <li>Bouncing Ball</li>
  <li>Contact Model - Contains bowling pins, a gripper, and sliding bricks demonstrating Drakes ability to simulate contact dynamics</li>
  <li>Rimless Wheel - A very simple model of a walking robot</li>
  <li>Compass Gait - A slightly less simple model of a walking robot</li>
  <li>Atlas - Examples concerning the Atlas humanoid robot</li>
  <li>zmp</li>
  <li>quadcopter</li>
  <li>and others</li>
</ul>

<p>Additional usage examples for pydrake can be found in the drake/bindings/pydrake/test folder.</p>

<h2 id="periscope-tutorials">Periscope Tutorials</h2>

<p>There is a set of Jupyter notebook based tutorials for some basic Drake functionality in python.</p>

<p><a href="https://github.com/gizatt/drake_periscope_tutorial">https://github.com/gizatt/drake_periscope_tutorial</a></p>

<h1 id="drake-concepts">Drake Concepts</h1>

<h2 id="simulation">Simulation</h2>

<p>For dynamic simulation, Drake exposes a Lego block interface for building complex systems out of smaller pieces, a paradigm similar to Simulink and other modeling software.</p>

<p>Objects possess input and output ports. One wires up input ports to output ports to build composite systems.</p>

<p>To build a simple forward simulation, construct a builder object. Then add all subsystems to the builder object. Explicitly connected input and output ports together. One possible cause of crashes may be leaving ports unconnected.</p>

<p>Once the entire system has been built, a Simulator object can be constructed from it. You may select an integration scheme and set initial conditions by getting a context from the Simulator object. The context holds state information.</p>

<p>There following excerpt from <a href="https://github.com/RussTedrake/underactuated/tree/master/src/simple">https://github.com/RussTedrake/underactuated/tree/master/src/simple</a> shows how to define a simple system and simulate it.</p>

<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;from pydrake.systems.framework import VectorSystem

# Define the system.
class SimpleContinuousTimeSystem(VectorSystem):
def __init__(self):
VectorSystem.__init__(self,
0, # Zero inputs.
1) # One output.
self._DeclareContinuousState(1) # One state variable.

# xdot(t) = -x(t) + x^3(t)
def _DoCalcVectorTimeDerivatives(self, context, u, x, xdot):
xdot[:] = -x + x**3

# y(t) = x(t)
def _DoCalcVectorOutput(self, context, u, x, y):
y[:] = x&lt;/code&gt;
</code></pre></div></div>

<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;import matplotlib.pyplot as plt
from pydrake.all import (DiagramBuilder, SignalLogger, Simulator)
from continuous_time_system import *

# Create a simple block diagram containing our system.
builder = DiagramBuilder()
system = builder.AddSystem(SimpleContinuousTimeSystem())
logger = builder.AddSystem(SignalLogger(1))
builder.Connect(system.get_output_port(0), logger.get_input_port(0))
diagram = builder.Build()

# Create the simulator.
simulator = Simulator(diagram)

# Set the initial conditions, x(0).
state = simulator.get_mutable_context().get_mutable_continuous_state_vector()
state.SetFromVector([0.9])

# Simulate for 10 seconds.
simulator.StepTo(10)

# Plot the results.
plt.plot(logger.sample_times(), logger.data().transpose())
plt.xlabel('t')
plt.ylabel('x(t)')
plt.show()&lt;/code&gt;
</code></pre></div></div>

<h4 id="refs">Refs:</h4>

<p><a href="http://underactuated.mit.edu/underactuated.html?chapter=systems">http://underactuated.mit.edu/underactuated.html?chapter=systems</a></p>

<h2 id="rigid-body-trees">Rigid Body Trees</h2>

<p>Edit : I think the Rigid Body Trees interface is deprecated. Use Multi Body Trees.</p>

<p>There are two complementary perspectives to take of the degrees of freedom of a robot, intrinsic coordinates and extrinsic coordinates. The intrinsic coordinates have one variable per degree of freedom of the robot. A common example is a set of joint angles. The dynamics are simply expressed in the intrinsic coordinates and can derived using Lagrangian mechanics. The extrinsic coordinates specify the spatial locations and orientation of frames attached to the robot. These are called frames. These spatial coordinates may be constrained in a relationship by a rigid mounting or gearing, so there may be more extrinsic frames available than intrinsic coordinates. Extrinsic coordinates are particularly pertinent for discussions of geometry, contact, and external forces.</p>

<p>Drake uses the URDF (Universal Robot Description Format) format. This is a common robot format originating in the ROS community for which you can find models of many commercial robots online. It is an XML based format with visualization, inertial, and collision tags.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/00/Cart-pendulum.svg" alt="" /></p>

<p>This is an example URDF for a pendulum cart system.</p>

<hr />

<h3 id="example-pendulum-urdf">Example: Pendulum URDF</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;

&lt;robot xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://drake.mit.edu" name="CartPole"&gt;

    &lt;link name="ground"&gt;
        &lt;visual&gt;
            &lt;origin rpy="0 0 0" xyz="0 0 -5"&gt;&lt;/origin&gt;
            &lt;geometry&gt;
                &lt;box size="1000 1000 10"&gt;&lt;/box&gt;
            &lt;/geometry&gt;
            &lt;material&gt;
                &lt;color rgba="0.93 .74 .4 1"&gt;&lt;/color&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;link name="cart"&gt;
        &lt;inertial&gt;
            &lt;origin rpy="0 0 0" xyz="0 0 -.5"&gt;&lt;/origin&gt;
            &lt;mass value="10"&gt;&lt;/mass&gt;
            &lt;inertia ixz="0" ixx="0" ixy="0" izz="0" iyy="0" iyz="0"&gt;&lt;/inertia&gt;
        &lt;/inertial&gt;
        &lt;visual&gt;
            &lt;origin rpy="0 0 0" xyz="0 0 .25"&gt;&lt;/origin&gt;
            &lt;geometry&gt;
                &lt;box size=".6 .3 .3"&gt;&lt;/box&gt;
            &lt;/geometry&gt;
            &lt;material&gt;
                &lt;color rgba="0 1 0 1"&gt;&lt;/color&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
        &lt;visual&gt;
            &lt;origin rpy="0 0 0" xyz=".15 0 .025"&gt;&lt;/origin&gt;
            &lt;geometry&gt;
                &lt;sphere radius=".05"&gt;&lt;/sphere&gt;
            &lt;/geometry&gt;
            &lt;material&gt;
                &lt;color rgba="0 0 0 1"&gt;&lt;/color&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
        &lt;visual&gt;
            &lt;origin rpy="0 0 0" xyz="-.15 0 .025"&gt;&lt;/origin&gt;
            &lt;geometry&gt;
                &lt;sphere radius=".05"&gt;&lt;/sphere&gt;
            &lt;/geometry&gt;
            &lt;material&gt;
                &lt;color rgba="0 0 0 1"&gt;&lt;/color&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;link name="pole"&gt;
        &lt;inertial&gt;
            &lt;origin rpy="0 0 0" xyz="0 0 -.5"&gt;&lt;/origin&gt;
            &lt;mass value="1"&gt;&lt;/mass&gt;
            &lt;inertia ixz="0" ixx="0" ixy="0" izz="0" iyy="0" iyz="0"&gt;&lt;/inertia&gt;
        &lt;/inertial&gt;
        &lt;visual&gt;
            &lt;origin rpy="0 0 0" xyz="0 0 -.25"&gt;&lt;/origin&gt;
            &lt;geometry&gt;
                 &lt;cylinder length=".5" radius=".01"&gt;&lt;/cylinder&gt;
            &lt;/geometry&gt;
            &lt;material&gt;
                &lt;color rgba="1 0 0 1"&gt;&lt;/color&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
        &lt;visual&gt;
            &lt;origin rpy="0 0 0" xyz="0 0 -.5"&gt;&lt;/origin&gt;
            &lt;geometry&gt;
                 &lt;sphere radius=".05"&gt;&lt;/sphere&gt;
            &lt;/geometry&gt;
            &lt;material&gt;
                &lt;color rgba="0 0 1 1"&gt;&lt;/color&gt;
            &lt;/material&gt;
        &lt;/visual&gt;
    &lt;/link&gt;

    &lt;joint type="prismatic" name="x"&gt;
        &lt;parent link="ground"&gt;&lt;/parent&gt;
        &lt;child link="cart"&gt;&lt;/child&gt;
        &lt;origin xyz="0 0 0"&gt;&lt;/origin&gt;
        &lt;axis xyz="1 0 0"&gt;&lt;/axis&gt;
        &lt;dynamics damping="0.1"&gt;&lt;/dynamics&gt;
    &lt;/joint&gt;

    &lt;joint type="continuous" name="theta"&gt;
        &lt;parent link="cart"&gt;&lt;/parent&gt;
        &lt;child link="pole"&gt;&lt;/child&gt;
        &lt;origin xyz="0 0 .25"&gt;&lt;/origin&gt;
        &lt;axis xyz="0 1 0"&gt;&lt;/axis&gt;
        &lt;dynamics damping="0.1"&gt;&lt;/dynamics&gt;
    &lt;/joint&gt;

    &lt;transmission type="SimpleTransmission" name="cart_force"&gt;
        &lt;actuator name="force"&gt;&lt;/actuator&gt;
        &lt;joint name="x"&gt;&lt;/joint&gt;
        &lt;mechanicalreduction&gt;1&lt;/mechanicalreduction&gt;
    &lt;/transmission&gt;
&lt;/robot&gt;&lt;/code&gt;
</code></pre></div></div>

<p>Ref:</p>

<p><a href="https://github.com/RussTedrake/underactuated/blob/master/src/cartpole/cartpole.urdf">https://github.com/RussTedrake/underactuated/blob/master/src/cartpole/cartpole.urdf</a></p>

<hr />

<p>The RigidBodyTree is a Drake class that describes both the intrinsic and extrinsic properties of a linkage. RigidBodyTrees may be built from a URDF file, some of which are packaged inside of Drake. For example, the Jaco arm URDF is available packaged with Drake.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;jaco_urdf = FindResourceOrThrow(
    "drake/manipulation/models/jaco_description/urdf/j2n6s300.urdf")
tree = RigidBodyTree(jaco_urdf, FloatingBaseType.kFixed)&lt;/code&gt;
</code></pre></div></div>

<p>The full properties of the RigidBodyTree class are available at <a href="https://drake.mit.edu/pydrake/pydrake.multibody.rigid_body_tree.html">https://drake.mit.edu/pydrake/pydrake.multibody.rigid_body_tree.html</a> , but it will be useful to highlight some of the most commonly used functionality.</p>

<p>You can probe the RigidBodyTree for useful properties about the linkage, for example the number of intrinsic coordinates, or the number of bodies in the tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;print(tree.get_num_positions())
print(tree.get_num_velocities())
print(tree.get_num_bodies())&lt;/code&gt;
</code></pre></div></div>

<p>For many operations, one needs to perform the forward dynamics to build a kinematic cache that needs to be supplied later.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;q = np.zeros(tree.get_num_positions())
v = np.zeros(tree.get_num_velocities())
cache = tree.doKinematics(q,v)&lt;/code&gt;
</code></pre></div></div>

<p>Drake describes the dynamics in terms of the intrinsic coordinates. The robot manipulator equations have the common form  (See <a href="http://underactuated.csail.mit.edu/underactuated.html?chapter=multibody">http://underactuated.csail.mit.edu/underactuated.html?chapter=multibody</a> )</p>

<p>$latex M(q)\ddot{q} + C(q,\dot{q})\dot{q} = \tau_g(q) + Bu $</p>

<p>where q is the state vector, M is the inertia matrix, C captures Coriolis forces, and $latex \tau_g$ is the gravity vector. The matrix B maps control inputs u into generalized forces.</p>

<p>External forces on the tree are described as wrenches. Wrenches are an object that combines forces and torques. In Drake, they are specified by 6 dimensional vectors. From the Drake docs:</p>

<p>‚ÄúA column vector consisting of one wrench (spatial force) = [r X f; f], where f is a force (translational force) applied at a point P and r is the position vector from a point O (called the ‚Äúmoment center‚Äù) to point P.‚Äù</p>

<p>Drake will also compute the quantities in the manipulator equation. For example, to compute the term $latex C(q,v,f_{ext})$ in the manipulator equations with no externally applied wrenches.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;bodies = [tree.get_body(j) for j in range(tree.get_num_bodies())]
no_wrench = { body : np.zeros(6) for body in bodies}
print(tree.dynamicsBiasTerm(cache, no_wrench))&lt;/code&gt;
</code></pre></div></div>

<p>Drake can be asked to compute the other terms in the manipulator equation as well. Drake can compute the center of mass of the entire tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;tree.centerOfMass(cache)&lt;/code&gt;
</code></pre></div></div>

<p>Drake provides a couple of useful mappings between the intrinsic and extrinsic coordinates.</p>

<p>First, given a set of internal coordinates, Drake can transform these into frames, which may be expressed in yet another coordinate system.</p>

<p>The extrinsic frames can be expressed as a function of the intrinsic coordinates</p>

<p>$latex X_i = f_i(x_j) $</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;tree.relativeTransform(cache, 0, 9)&lt;/code&gt;
</code></pre></div></div>

<p>Returns a $latex 4\times 4$ transformation matrix between body 0 and 9 of the tree. The upper $latex 3\times 3$ block corresponds to a rotation matrix, and the last column a translation vector of the frame.</p>

<p>The Jacobian of this mapping,</p>

<p>$latex J_{ij} = \frac{\partial f_i}{\partial x_j} $</p>

<p>is useful for translating externally described small displacements, velocities, forces, and torques, into the equivalent terms for the intrinsic coordinates.</p>

<p>The time derivative or differential of a frame will possess a linear and angular velocity. These come packed in a 6 dimensional vector called the Twist.</p>

<p><a href="https://en.wikipedia.org/wiki/Screw_theory#Twist">https://en.wikipedia.org/wiki/Screw_theory#Twist</a></p>

<p>The geometric Jacobian function returns the Jacobian in a sparse format. It returns a tuple of a $latex m\times 6$ matrix and a $latex 1\times m$ vector of indices to which coordinates these correspond.<br />
The function takes the id of three different frames. In this example, it computes the differential of the transformation from frame 0 to frame 9 expressed in frame 3.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;tree.geometricJacobian(cache, 0, 9, 3)&lt;/code&gt;
</code></pre></div></div>

<p>The dense matrix can be constructed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;jsparse, inds = tree.geometricJacobian(cache, 0, 9, 0)
jdense = np.zeros((tree.get_num_positions(), 6))
jdense[inds, :] = jsparse&lt;/code&gt;
</code></pre></div></div>

<p>Refs:</p>

<p>A Mathematical Introduction to Robotic Manipulation - <a href="https://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf">https://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf</a></p>

<p><a href="http://underactuated.csail.mit.edu/underactuated.html?chapter=intro">http://underactuated.csail.mit.edu/underactuated.html?chapter=intro</a></p>

<h1 id="visualization">Visualization</h1>

<p>The Drake visualizer may be found in the tools folder. The Drake visualizer needs to be running before any applications that needs to communicate with it are started. To get the drake visualizer running run the following command from the drake directory</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;bazel run //tools:drake_visualizer&lt;/code&gt;
</code></pre></div></div>

<p>May need to run commands here to make LCM work and visualizer not crash immediately</p>

<p><a href="http://lcm-proj.github.io/multicast_setup.html">http://lcm-proj.github.io/multicast_setup.html</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;sudo ifconfig lo multicast
sudo route add -net 224.0.0.0 netmask 240.0.0.0 dev lo&lt;/code&gt;
</code></pre></div></div>

<h1 id="kinova-ros-package">Kinova ROS package</h1>

<p>The Kinova Jaco arm is easily communicated to through the Kinova ROS package</p>

<p><a href="https://github.com/Kinovarobotics/kinova-ros">https://github.com/Kinovarobotics/kinova-ros</a></p>

<p>The package as of October 2018 supports Ubuntu 14.04 and ROS Indigo. The package includes bindings to the Jaco SDK for reading sensor data and giving motion commands. The package supports a variety of control modes, including torque control.</p>

<p>To update functionality to ubuntu 16.04 and ROS Kinetic you may wish to pull from this external branch</p>

<p><a href="https://github.com/CNURobotics/kinova-ros/tree/kinetic_devel">https://github.com/CNURobotics/kinova-ros/tree/kinetic_devel</a></p>

<p>or try the beta branch</p>

<p><a href="https://github.com/Kinovarobotics/kinova-ros/tree/kinova-ros-beta">https://github.com/Kinovarobotics/kinova-ros/tree/kinova-ros-beta</a></p>

<p>The Gazebo simulator seems to have a great deal of trouble.</p>

<p>One suggestion is that you have to add a small nonzero size parameter to your URDF files. <a href="https://github.com/Kinovarobotics/kinova-ros/issues/103">https://github.com/Kinovarobotics/kinova-ros/issues/103</a></p>

<p>The topics made available by the ROS Package are</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;/j2n6s300_driver/fingers_action/finger_positions/cancel
/j2n6s300_driver/fingers_action/finger_positions/feedback
/j2n6s300_driver/fingers_action/finger_positions/goal
/j2n6s300_driver/fingers_action/finger_positions/result
/j2n6s300_driver/fingers_action/finger_positions/status
/j2n6s300_driver/in/cartesian_force
/j2n6s300_driver/in/cartesian_velocity
/j2n6s300_driver/in/joint_torque
/j2n6s300_driver/in/joint_velocity
/j2n6s300_driver/joints_action/joint_angles/cancel
/j2n6s300_driver/joints_action/joint_angles/feedback
/j2n6s300_driver/joints_action/joint_angles/goal
/j2n6s300_driver/joints_action/joint_angles/result
/j2n6s300_driver/joints_action/joint_angles/status
/j2n6s300_driver/out/cartesian_command
/j2n6s300_driver/out/finger_position
/j2n6s300_driver/out/joint_angles
/j2n6s300_driver/out/joint_command
/j2n6s300_driver/out/joint_state
/j2n6s300_driver/out/joint_torques
/j2n6s300_driver/out/tool_pose
/j2n6s300_driver/out/tool_wrench
/j2n6s300_driver/pose_action/tool_pose/cancel
/j2n6s300_driver/pose_action/tool_pose/feedback
/j2n6s300_driver/pose_action/tool_pose/goal
/j2n6s300_driver/pose_action/tool_pose/result
/j2n6s300_driver/pose_action/tool_pose/status
/j2n6s300_driver/trajectory_controller/command
/j2n6s300_driver/trajectory_controller/state&lt;/code&gt;
</code></pre></div></div>

<h2 id="ros-intercommunication">ROS Intercommunication</h2>

<p>The communication stack used by Drake is Lightweight Communications and Marshalling (LCM). For interconnection to the rest of the ROS ecosystem, this adds a layer of friction.</p>

<p>One option is to use the lcm_to_ros project https://github.com/nrjl/lcm_to_ros</p>

<p>This is a generator for building republishers of messages going between ROS and LCM</p>

<p>Another option is to build custom subscribers and publishers as in the following example.</p>

<p><a href="http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28python%29">http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28python%29</a></p>

<h2 id="example-connecting-drake-visualizer-to-external-jaco-arm">Example: Connecting Drake Visualizer to External Jaco Arm</h2>

<p>In another terminal turn on the Jaco driver</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;roslaunch kinova_bringup kinova_robot.launch kinova_robotType:=j2n6s300&lt;/code&gt;
</code></pre></div></div>

<p>Also get the drake visualizer running from the drake directory before running the script</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;bazel run //tools:drake_visualizer&lt;/code&gt;
</code></pre></div></div>

<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;import rospy
from pydrake.all import *
import numpy as np
from sensor_msgs.msg import JointState
jaco_urdf = FindResourceOrThrow("drake/manipulation/models/jaco_description/urdf/j2n6s300.urdf")
tree = RigidBodyTree(jaco_urdf , FloatingBaseType.kFixed)

builder = DiagramBuilder()

lc = DrakeLcm()
vis = DrakeVisualizer(tree, lc)
robot = builder.AddSystem(RigidBodyPlant(tree))
publisher = builder.AddSystem(vis)
builder.Connect(robot.get_output_port(0), publisher.get_input_port(0))

diagram = builder.Build()
simulator = Simulator(diagram)
simulator.set_target_realtime_rate(1.0)
simulator.set_publish_every_time_step(False)
context = simulator.get_mutable_context()
state = context.get_mutable_continuous_state_vector()
state.SetFromVector(np.zeros(9*2))
simulator.Initialize()


q = None
v = None
f = None
def callback(data):
        global q, v, f
        q = np.array(data.position)
        v = np.array(data.velocity)
        f = np.array(data.effort)
        # Some of the coordinates are offset between the Kinova Ros package and the Drake model
        q[1] = np.pi + q[1]
        q[2] = np.pi + q[2]


rospy.init_node('listener', anonymous=True)
rospy.Subscriber("/j2n6s300_driver/out/joint_state", JointState, callback)

rate = rospy.Rate(4)
rate.sleep()
while not rospy.is_shutdown():
        state = context.get_mutable_continuous_state_vector()
        state.SetFromVector(np.append(q,v))
        simulator.Initialize()
        rate.sleep()&lt;/code&gt;
</code></pre></div></div>

<p><img src="drake_vis.png" alt="The Drake Visualizer" /></p>

<hr />

<h2 id="example-crumpling-jaco">Example: Crumpling Jaco</h2>

<p>A simple example of the simulation capabilities is the simulation of an unactuated Jaco arm.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;import rospy
from pydrake.all import *
import numpy as np
from sensor_msgs.msg import JointState
jaco_urdf = FindResourceOrThrow("drake/manipulation/models/jaco_description/urdf/j2n6s300.urdf")
tree = RigidBodyTree(jaco_urdf , FloatingBaseType.kFixed)

builder = DiagramBuilder()

lc = DrakeLcm()
vis = DrakeVisualizer(tree, lc)
robot = builder.AddSystem(RigidBodyPlant(tree))
publisher = builder.AddSystem(vis)
builder.Connect(robot.get_output_port(0), publisher.get_input_port(0))
force = builder.AddSystem(ConstantVectorSource(np.zeros(9)))
builder.Connect(force.get_output_port(0), robot.get_input_port(0))

diagram = builder.Build()
simulator = Simulator(diagram)
simulator.set_target_realtime_rate(1.0)
simulator.set_publish_every_time_step(False)
context = simulator.get_mutable_context()
state = context.get_mutable_continuous_state_vector()
state.SetFromVector(np.zeros(9*2)+0.1)
simulator.Initialize()
simulator.StepTo(10)&lt;/code&gt;
</code></pre></div></div>

<h1 id="optimization-solvers">Optimization Solvers</h1>

<p>Drake provides a common interface to many optimization solvers. Because of the tight integration, Drake has the capability to directly build the equations of motion for a system into a form the solver can comprehend.</p>

<p>The Mathematical Program class provides a high level interface to the different solvers. This class can be constructed as an object on it‚Äôs own or as returned by other helper classes such as trajectory optimization builders.</p>

<p>Drake provides a symbolic expression modeling language in which to describe constraints and costs.</p>

<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;from pydrake.all import *
import numpy as np

m = MathematicalProgram()

xs = m.NewContinuousVariables(2, 'x')
print(xs)
c = np.array([-1,-1])
m.AddCost( c[0]*xs[0] + c[1]*xs[1] )

m.AddLinearConstraint(xs[0] == 0)
m.AddLinearConstraint(3*xs[1] + xs[0] &lt;= -1)

print(m.linear_equality_constraints())
print(m.bounding_box_constraints())
print(m.linear_costs()[0])
print(m.Solve())
print(m.GetSolverId().name())
print(m.GetSolution(xs))&lt;/code&gt;
</code></pre></div></div>

<hr />

<p>There are a large variety of solvers out there for problems of different structure.</p>

<p>A Mathematical Program is generally of the form</p>

<p>$latex \min f(x) \   s.t. $<br />
$latex g(x) \ge 0 $<br />
$latex h(x) = 0 $</p>

<p>One of the oldest and most studied class of these programs are known as Linear Programs which has linear cost and constraints. This mathematical program has very efficient solvers available for it.</p>

<p>A large class of optimization problems that are tractable are known as Convex Optimization problems. The cost functions must be bowl shaped (convex), the inequality constraints must define convex regions and the equality constraints must be affine (linear + offset). For this class, gradient descent roughly works and refinements of gradient descent like Newton‚Äôs method work even better. Convexity implies that greedy local moves are also acceptable global moves and there are no local minima or tendril regions to get caught in.</p>

<p>The common reference for convex optimization is the textbook by Boyd and Vandenberghe freely available at <a href="http://web.stanford.edu/~boyd/cvxbook/">http://web.stanford.edu/~boyd/cvxbook/</a>. There is also an accompanying video course available online.</p>

<p>Subclasses of Convex programming may have solvers tuned to them. Important subclasses include:</p>

<ul>
  <li>Linear Programming - Linear objective, linear equality, and linear inequality constraints.</li>
  <li>Quadratic Programming - Linear Programming + quadratic objective</li>
  <li>Second Order Cone Programming</li>
  <li>Semidefinite Programming - Optimization allowing for the constraint of a SemiDefinite matrix. This means the matrix is constrained to have all nonnegative eigenvalues or equivalently the quadratic form it defines $latex q^T Xq$ is non-negative for all possible vectors $latex q$.</li>
  <li>Sum of Squares Programming - Optimization over polynomials with the constraint that the polynomial can be written as a sum of squares, a manifestly positive form.</li>
</ul>

<p>Many problems cannot be put into this form. If the inherent nature of the problem at hand requires it, you may choose to use a nonlinear programming solver or Mixed Integer Programming Solver.</p>

<p>The solvers Ipopt and Snopt are nonlinear programming solvers. Ipopt is an open source and Snopt is proprietary. These solvers use local convex approximations to the problem to heuristically drive the solution to a local minimum.</p>

<p>Mixed Integer Linear Programming is Linear Programming with additional ability to require variables to take on integer values. This additional constraint type takes the problem from polynomial time solvable to NP-complete. A surprisingly large number of discrete and continuous optimization problems can be encoded into this framework. Internally, these solvers use linear programming solvers to guide the discrete search.</p>

<p>Part of the art and fun of the subject comes from manipulating your problem into a form amenable to powerful available solvers and theory.</p>

<p>Hans Mittelmann at the University of Arizona maintains benchmarks for a variety of optimization tools. <a href="http://plato.asu.edu/bench.html">http://plato.asu.edu/bench.html</a> A rule of thumb is that commercial solvers perform better than open source solvers.</p>

<h3 id="available-solvers-in-drake">Available Solvers in Drake</h3>

<ul>
  <li>
    <p>Mosek - Mosek is a proprietary optimization solver package offering solvers for</p>

    <ul>
      <li>Linear.</li>
      <li>Conic quadratic.</li>
      <li>Semi-definite (Positive semi-definite matrix variables).</li>
      <li>Quadratic and quadratically constrained.</li>
      <li>General convex nonlinear.</li>
      <li>Mixed integer linear, conic and quadratic.</li>
    </ul>
  </li>
  <li>
    <p>Gurobi - Gurobi is a proprietary optimization solver package offering solvers for</p>

    <ul>
      <li>linear programming solver (LP)</li>
      <li>mixed-integer linear programming solver (MILP)</li>
      <li>mixed-integer quadratic programming solver (MIQP)</li>
      <li>quadratic programming solver (QP)</li>
      <li>quadratically constrained programming solver (QCP)</li>
      <li>mixed-integer quadratically constrained programming solver (MIQCP)</li>
    </ul>
  </li>
  <li>Snopt - Snopt is a nonlinear optimization solver using sequential convex optimization (SQP) <a href="http://www.sbsi-sol-optimize.com/asp/sol_product_snopt.htm">http://www.sbsi-sol-optimize.com/asp/sol_product_snopt.htm</a></li>
  <li>Ipopt - Ipopt is a open source nonlinear optimization solver using sequential convex optimization (SQP) <a href="https://projects.coin-or.org/Ipopt">https://projects.coin-or.org/Ipopt</a></li>
  <li>Operator Splitting Quadratic Program (OSQP) - Open source quadratic programming package <a href="https://osqp.org/">https://osqp.org/</a></li>
  <li>ik</li>
  <li>LCP</li>
  <li>dReal - An SMT solver for reals <a href="http://dreal.github.io/">http://dreal.github.io/</a></li>
</ul>

<h1 id="automatic-differentiation">Automatic Differentiation</h1>

<p>Automatic Differentiation is the capability to have derivatives computed alongside code that computes the values. It is largely based upon application of the chain rule. There are two modes, forward and reverse mode.</p>

<p>Forward mode is the simplest to describe. Functions can be overloaded so that they take a dual number, a value combined in a tuple with it‚Äôs derivative information. As the value of a function is computed, the Jacobian of that function is matrix multiplied on the derivative concurrently.</p>

<p>Drake exposes automatic differentiation capability for manual use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;from pydrake.all import *
import numpy as np

# second parameter initializes forward mode derivative information
x = AutoDiffXd(4.0, np.array([1,1]))
f = x * x * x
print(f.derivatives())&lt;/code&gt;
</code></pre></div></div>

<p>More importantly Drake uses automatic differentiation internally to marshal symbolic problems into forms acceptable to external solvers and to calculate the various Jacobians we‚Äôve already seen.</p>

<h2 id="trajectory-optimization">Trajectory Optimization</h2>

<p>Trajectory optimization is a framework in which one uses Mathematical programming to solve optimal trajectory problems. The input to the system</p>

<p>is considered to be a decision variable in a Mathematical programming problem.</p>

<p>The combination of dynamical system modeling, automatic differentiation, and bindings to mathematical programming solvers makes Drake an excellent platform for trajectory optimization.</p>

<p>In Direct Collocation, both the path and the input variables are discretized along time. The trajectories are described by cubics and force curves are described by piecewise linear. One way of performing direct collocation is to take the path position at a discrete number of time points and make a decision variable for each. The discretized equations of motion become constraints that neighboring time points have to obey. One may then inject any other desired requirements (staying inside some safe region for example) as additional constraints.</p>

<p>The Drake docs state:</p>

<p>‚Äù</p>

<p>DirectCollocation implements the approach to trajectory optimization as described in C. R. Hargraves and S. W. Paris. Direct trajectory optimization using nonlinear programming and collocation. J Guidance, 10(4):338-342, July-August 1987. It assumes a first-order hold on the input trajectory and a cubic spline representation of the state trajectory, and adds dynamic constraints (and running costs) to the midpoints as well as the knot points in order to achieve a 3rd order integration accuracy.</p>

<p>‚Äù</p>

<p>Drake provides a useful interface for talking about trajectories. For both describing the cost function and the constraint functions, you want them to apply at all time steps. You can ask drake for variables representing the position or forces at all time steps. Drake will then build the appropriate mathematical program applying the cost of constraint at all time steps.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;ctx = robot.CreateDefaultContext()
dircol = DirectCollocation(robot, ctx, 10, 0.01, 0.1) # timesteps, minimum time step, max timestep
dircol.AddEqualTimeIntervalsConstraints()

state = dircol.state
u = dircol.input
t = dircol.time

dircol.AddRunningCost(state[0]**2)
dircol.AddConstraintToAllKnotPoints(u[0] &gt;= 0)&lt;/code&gt;
</code></pre></div></div>

<p>You may want to select the initial and final state specifically to specify goals and initial conditions</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;init = dircol.initial_state
final = dircol.final_state&lt;/code&gt;
</code></pre></div></div>

<p>Refs:</p>

<p><a href="http://underactuated.mit.edu/underactuated.html?chapter=trajopt">http://underactuated.mit.edu/underactuated.html?chapter=trajopt</a></p>

<h2 id="example-trajectory-optimization-of-a-pendulum">Example: Trajectory Optimization of a Pendulum</h2>

<p>This example comes from the Underactuated Robotics textbook source</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;import math
import numpy as np
import matplotlib.pyplot as plt

from pydrake.examples.pendulum import (PendulumPlant, PendulumState)
from pydrake.all import (DirectCollocation, PiecewisePolynomial,
                                                 SolutionResult)
#from visualizer import PendulumVisualizer

plant = PendulumPlant()
context = plant.CreateDefaultContext()

dircol = DirectCollocation(plant, context, num_time_samples=21,
                            minimum_timestep=0.2, maximum_timestep=0.5)

dircol.AddEqualTimeIntervalsConstraints()

torque_limit = 3.0  # N*m.
u = dircol.input()
dircol.AddConstraintToAllKnotPoints(-torque_limit &lt;= u[0])
dircol.AddConstraintToAllKnotPoints(u[0] &lt;= torque_limit)

initial_state = PendulumState()
initial_state.set_theta(0.0)
initial_state.set_thetadot(0.0)
dircol.AddBoundingBoxConstraint(initial_state.get_value(),
                            initial_state.get_value(),
                            dircol.initial_state())
# More elegant version is blocked on drake #8315:
# dircol.AddLinearConstraint(dircol.initial_state()
#                               == initial_state.get_value())

final_state = PendulumState()
final_state.set_theta(math.pi)
final_state.set_thetadot(0.0)
dircol.AddBoundingBoxConstraint(final_state.get_value(),
                                final_state.get_value(),
                                dircol.final_state())
# dircol.AddLinearConstraint(dircol.final_state() == final_state.get_value())

R = 10  # Cost on input "effort".
dircol.AddRunningCost(R*u[0]**2)

initial_x_trajectory = \
        PiecewisePolynomial.FirstOrderHold([0., 4.],
                                 [initial_state.get_value(),
                                 final_state.get_value()])
dircol.SetInitialTrajectory(PiecewisePolynomial(), 
                            initial_x_trajectory) 
result = dircol.Solve() 
assert(result == SolutionResult.kSolutionFound) 
x_trajectory = dircol.ReconstructStateTrajectory() 
#vis = PendulumVisualizer() 
#ani = vis.animate(x_trajectory, repeat=True) 
x_knots = np.hstack([x_trajectory.value(t) for t in                                          
                      np.linspace(x_trajectory.start_time(),                                          
                      x_trajectory.end_time(), 100)]) 
plt.figure() 
plt.plot(x_knots[0, :], x_knots[1, :]) 
plt.show() 
                                        &lt;/code&gt;
</code></pre></div></div>

<ul>
  <li><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/06/pendulum_phase.png" alt="" /></li>
</ul>

<hr />

<h2 id="example-application-estimating-end-effector-force-from-jaco-motor-torques">Example Application: Estimating end-effector force from Jaco motor torques</h2>

<p>End effector forces become part of the equations of motion.</p>

<p>The geometric Jacobian transforms the extrinsic force into intrinsic coordinates. It is in general a rectangular matrix, since the number of extrinsic coordinates does not need to match the number of intrinsic coordinates.</p>

<p>A force $latex f$ applied to the end effector appears linearly in the manipulator equations as $latex J^Tf$. This will be canceled by the torques of the motors during static or quasi-static movement. Hence, we can can determinethe external force from the motor torques if we assume it is the only external force at play.</p>

<p>The pseudo-inverse is the best possible solution to an overdetermined set of linear equations, in the least squares sense. We use this operation due to the non square nature of the Jacobian.</p>

<p>$latex \min (Jx - X)^2 \rightarrow J^T Jx = J^T X$</p>

<p>The following script prints both the end effector force as supplied by the Jaco SDK and the force as computed by Drake from the internal motor torques.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;import rospy
from pydrake.all import *
import numpy as np
from sensor_msgs.msg import JointState
from geometry_msgs.msg import WrenchStamped
urdf_tree = FindResourceOrThrow("drake/manipulation/models/jaco_description/urdf/j2n6s300.urdf")
tree = RigidBodyTree( urdf_tree,
                                         FloatingBaseType.kFixed)
bodies = [tree.get_body(j) for j in range(tree.get_num_bodies())]
no_wrench = { body : np.zeros(6)  for body in bodies}

body_n = 9 #end_effector body number
print(bodies[body_n].get_name())

def end_effector_force(q, v, u):
        cache = tree.doKinematics(q,v)
        # returns the external torque term for only gravity and no other external wrenches
        Cgrav = tree.dynamicsBiasTerm(cache, no_wrench )
        C = u - Cgrav # subtract off gravity of robot itself
        print(u - Cgrav)
        j = tree.geometricJacobian(cache, 0 , body_n, 0) # returns a tuple of 6 by n matrix in j[0] and the indices to which it applied in j[1]
        jjt = np.dot(j[0] ,j[0].T) # 
        Wext = np.linalg.solve(jjt,  np.dot(j[0],  C[j[1]])) # C[j[1]] is cryptic numpy sub indexing for densifying the Jacobian
        return Wext[3:]


q = None
v = None
f = None
fext = np.zeros(3)

def callback(data):
        global q, v, f, initu, start
        q = np.array(data.position)
        v = np.array(data.velocity)
        q[1] = np.pi + q[1] #The drake conventions and the kinova conventions for angles are off
        q[2] = np.pi + q[2]
        f = np.array(data.effort)

def wrenchcallback(data):
        global fext
        fext[0] = data.wrench.force.x
        fext[1] = data.wrench.force.y
        fext[2] = data.wrench.force.z

rospy.init_node('listener', anonymous=True)
rospy.Subscriber("/j2n6s300_driver/out/joint_state", JointState, callback)
rospy.Subscriber("/j2n6s300_driver/out/tool_wrench", WrenchStamped, wrenchcallback)

rate = rospy.Rate(1)
rate.sleep()
while not rospy.is_shutdown():
        print(end_effector_force(q,v,f))
        print(fext)
        rate.sleep()&lt;/code&gt;
</code></pre></div></div>

:ET