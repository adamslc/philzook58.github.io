I"s<p><a href="https://en.wikipedia.org/wiki/Category_theory">Category theory</a> is a mathematical theory with reputation for being very abstract.</p>

<p>Category theory is an algebraic theory of functions. It has the flavor of connecting up little pipes and ports that is reminiscent of dataflow languages or circuits, but with some hearty mathematical underpinnings.</p>

<p>So is this really applicable to programming at all? Yes, I think so.</p>

<p>Here’s one argument. Libraries present an interface to their users. One of the measures of the goodness or badness of an interface is how often you are inclined to peek under the hood to get it to do the thing that you need. Designing these interfaces is hard. Category theory has taken off as a field because it has been found to be a useful and uniform interface to a surprising variety of very different mathematics. I submit that it is at least <em>plausible</em> that software interfaces designed with tasteful mimicry of category theory may achieve similar uniformity across disparate software domains. This is epitomized for me in Conal Elliott’s Compiling to Categories. <a href="http://conal.net/papers/compiling-to-categories/">http://conal.net/papers/compiling-to-categories/</a></p>

<p>I think it is easy to have the miscomprehension that a fancy language like Haskell or Agda is necessary to even begin writing software that encapsulates category theory based ideas, but this is simply not the case. I’ve been under this misapprehension before.</p>

<p>It just so happens that category theory is <em>especially useful</em> in those languages for explaining some programming patterns especially those concerning polymorphism. See Bartosz Milewski’s <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category theory for Programmers</a>.</p>

<p>But this is not the only way to use category theory.</p>

<p>There’s a really delightful book by Rydeheard and Burstall called <a href="http://www.cs.man.ac.uk/~david/categories/book/book.pdf">Computational Category Theory</a>. The first time I looked at it, I couldn’t make heads or tails of it, going on the double uphill battle of category theory and Standard ML. But looking at it now, it seems extremely straightforward and well presented. It’s a cookbook of how to build category theoretic interfaces for software.</p>

<p>So I think it is interesting to perform some translation of its concepts and style into python, the lingua franca of computing today.</p>

<p>In particular, there is a dual opportunity to both build a unified interface between some of the most commonly used powerful libraries in the python ecosystem and also use these implementations to help explain categorical concepts in concrete detail. I hope to have the attention span to do this following:</p>

<ul>
  <li>Numpy - Let’s compute a pullback in FinVect!</li>
  <li>Pandas - There are couple different options here. <a href="http://www.philipzucker.com/a-short-skinny-on-relations-towards-the-algebra-of-programming/">Relation Algebra</a> or The Spivak <a href="http://www.appliedcategorytheory.org/wp-content/uploads/2018/03/Ryan-Wisnesky-Categorical-Databases.pdf">Categorical Databases crew </a></li>
  <li>Sympy - The category of substition into terms as mentioned in R&amp;B. Also in this <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3615">very excellent paper</a>.  Also <a href="https://en.wikipedia.org/wiki/Module_(mathematics)">modules</a></li>
  <li><a href="https://github.com/philzook58/z3_tutorial_2020/blob/master/Z3%20Tutorial.ipynb">Z3py</a> - Categorical Logic</li>
  <li>Networkx - Graph stuff. Surely got some categories there</li>
  <li><a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis</a> - Property based testing of universal properties</li>
</ul>

<p>A very simple category is that of <a href="https://en.wikipedia.org/wiki/FinSet">finite sets</a>. The objects in the category can be represented by python sets. The morphisms can be represented by python dictionaries. Nothing abstract here. We can rip and tear these things apart any which way we please.</p>

<p>The manipulations are made even more pleasant by the python features of set and dictionary comprehension which will mimic the definitions you’ll find on the wikipedia page for these constructions quite nicely.</p>

<p>Composition is defined as making a new dictionary by feeding the output of the first dictionary into the second. The identity dictionary over a set is one that has the same values as keys. The definition of products and coproducts (disjoint union) are probably not too surprising.</p>

<p>One really interesting thing about the Rydeheard and Burstall presentation is noticing what are the inputs to these constructions and what are the outputs. Do you need to hand it objects? morphisms? How many? How can we represent the universal property? We do so by outputting functions that <em>construct</em> the required universal morphisms. They describe this is a kind of <a href="https://en.wikipedia.org/wiki/Skolem_normal_form">skolemization </a>. The constructive programmatic presentation of the things is incredibly helpful to my understanding, and I hope it is to yours as well.</p>

<p>Here is a python class for FinSet. I’ve implemented a couple of interesting constructions, such as pullbacks and detecting monomorphisms and epimorphisms.</p>

<p>I’m launching you into the a deep end here if you have never seen category theory before (although goddamn does it get deeper). Do not be surprised if this doesn’t make that much sense. Try reading Rydeheard and Burstall chapter 3 and 4 first or other resources.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="k">class</span> <span class="nc">FinSet</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dom</span> <span class="p">,</span><span class="n">cod</span> <span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="s">'''  In order to specify a morphism, we need to give a python set that is the domain, a python set 
        that is the codomain, and a dictionary f that encodes a function between these two sets.
        We could by assumption just use f.keys() implicitly as the domain, however the codomain is not inferable from just f.
        In other categories that domain might not be either, so we chose to require both symmettrically.
        '''</span>
        <span class="k">assert</span><span class="p">(</span> <span class="n">dom</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">keys</span><span class="p">()))</span> <span class="c1"># f has value for everything in domain
</span>        <span class="k">assert</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="p">[</span><span class="n">y</span> <span class="ow">in</span> <span class="n">cod</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">f</span><span class="p">.</span><span class="n">value</span><span class="p">()]</span> <span class="p">))</span> <span class="c1"># f has only values in codomain
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">cod</span> <span class="o">=</span> <span class="n">cod</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dom</span> <span class="o">=</span> <span class="n">dom</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="c1"># a convenient overloading.
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
        <span class="s">''' Composition is function composition. Dictionary comprehension syntax for the win! '''</span>
        <span class="k">return</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">dom</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">cod</span><span class="p">,</span>  <span class="p">{</span> <span class="n">x</span> <span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="p">.</span><span class="n">dom</span> <span class="p">})</span>
    <span class="k">def</span> <span class="nf">idd</span><span class="p">(</span><span class="n">dom</span><span class="p">):</span>
        <span class="s">'''  The identity morphism on an object dom. A function mapping every x to itself'''</span>
        <span class="k">return</span> <span class="n">FinSet</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="p">{</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">__equal__</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">dom</span> <span class="o">==</span> <span class="n">g</span><span class="p">.</span><span class="n">dom</span><span class="p">)</span> <span class="c1"># I choose to say the question of equality only makes sense if the arrows are parallel.
</span>        <span class="k">assert</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">cod</span> <span class="o">==</span> <span class="n">g</span><span class="p">.</span><span class="n">cod</span><span class="p">)</span> <span class="c1"># ie. they have the same object at head and tail
</span>        <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">f</span> <span class="o">==</span> <span class="n">g</span><span class="p">.</span><span class="n">f</span>
    <span class="k">def</span> <span class="nf">terminal</span><span class="p">(</span><span class="n">dom</span><span class="p">):</span>
        <span class="s">''' The terminal object is an object such that for any other object, there is a unique morphism 
        to the terminal object
        This function returns the object itself {()}  and the universal morphism from dom to that object'''</span>
        <span class="k">return</span> <span class="p">{()}</span> <span class="p">,</span> <span class="n">FinSet</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="p">{()}</span> <span class="p">,</span>  <span class="p">{</span><span class="n">x</span> <span class="p">:</span> <span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">}</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">initial</span><span class="p">(</span><span class="n">cod</span><span class="p">):</span>
        <span class="s">''' The initial object is an object such that for any other object, there is a unique morphsm 
        from the initial object to that object.
        It is the dual of the terminal object.
        In FinSet, the initial object is the empty set set({}). The mapping is then an empty dictionary dict({})'''</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">({})</span> <span class="p">,</span> <span class="n">FinSet</span><span class="p">(</span><span class="nb">set</span><span class="p">({}),</span> <span class="n">cod</span><span class="p">,</span> <span class="nb">dict</span><span class="p">({}))</span>
    <span class="k">def</span> <span class="nf">monic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">''' Returns bool of whether mapping is injective. 
            In other words, maps every incoming element to unique outgoing element.
            In other words, does `self @ g == self @ f`  imply  `g == f` forall g,f 
            https://en.wikipedia.org/wiki/Monomorphism
            Counter class counters occurences'''</span>
        <span class="n">codomain_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">codomain_vals</span><span class="p">).</span><span class="n">values</span><span class="p">()</span> <span class="c1"># https://docs.python.org/3/library/collections.html#collections.Counter
</span>        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">])</span> <span class="c1"># no elements map to same element
</span>    <span class="k">def</span> <span class="nf">epic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">''' is mapping surjective? In other words does the image of the map f cover the entire codomain '''</span>
        <span class="n">codomain_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span> 
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">codomain_vals</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">cod</span> <span class="c1"># cover the codomain
</span>    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span> <span class="c1"># takes a sepcific product
</span>        <span class="n">ab</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">b</span> <span class="p">}</span> 
        <span class="n">p1</span> <span class="o">=</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">ab</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ab</span> <span class="p">}</span> <span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">ab</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">:</span> <span class="n">y</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ab</span> <span class="p">}</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">ab</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="p">,</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">:</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">f</span><span class="p">.</span><span class="n">dom</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="p">{</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">.</span><span class="n">dom</span>  <span class="p">}</span> <span class="p">)</span> <span class="c1"># assert f.dom == g.dom, f.cod == a, g.cod == b
</span>    <span class="k">def</span> <span class="nf">coproduct</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span>  <span class="p">}.</span><span class="n">union</span><span class="p">({</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">b</span>  <span class="p">})</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="p">{</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="p">}</span> <span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="p">{</span> <span class="n">y</span> <span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>  <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">b</span> <span class="p">}</span> <span class="p">)</span>
        <span class="k">def</span> <span class="nf">fanin</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ab</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">ab</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">fanin</span>
    <span class="k">def</span> <span class="nf">equalizer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
        <span class="s">''' The equalizer is a construction that allows one to talk about the solution to an equation in a categorical manner
        An equation is f(x) = g(x). It has two mappings f and g that we want to somehow be the same. The solution to this equation
        should be a subset of the shared domain of f and g. Subsets are described from within FinSet by maps that map into the
        subset. 
        '''</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">dom</span> <span class="o">==</span> <span class="n">g</span><span class="p">.</span><span class="n">dom</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">cod</span> <span class="o">==</span> <span class="n">g</span><span class="p">.</span><span class="n">cod</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">.</span><span class="n">dom</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">FinSet</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">dom</span><span class="p">,</span> <span class="p">{</span><span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">e</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">pullback</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">):</span> <span class="c1"># solutions to f(x) = g(y)
</span>        <span class="k">assert</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">cod</span> <span class="o">==</span> <span class="n">g</span><span class="p">.</span><span class="n">cod</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">.</span><span class="n">dom</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span><span class="p">.</span><span class="n">dom</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">g</span><span class="p">[</span><span class="n">y</span><span class="p">]}</span> <span class="c1"># subset of (f.dom, g.dom) that solves equation
</span>        <span class="n">p1</span> <span class="o">=</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">dom</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">e</span> <span class="p">}</span> <span class="p">)</span> <span class="c1"># projection 1
</span>        <span class="n">p2</span> <span class="o">=</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">e</span><span class="p">,</span> <span class="n">g</span><span class="p">.</span><span class="n">dom</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">:</span> <span class="n">y</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">e</span> <span class="p">}</span> <span class="p">)</span> <span class="c1"># projection 2
</span>        
        <span class="k">def</span> <span class="nf">univ</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">):</span>
            <span class="s">''' Universal property: Given any other commuting square of f @ q1 == g @ q2, there is a unique morphism
            that injects into e such that certain triangles commute. It's best to look at the diagram'''</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">q1</span><span class="p">.</span><span class="n">cod</span> <span class="o">==</span> <span class="n">p1</span><span class="p">.</span><span class="n">cod</span><span class="p">)</span> <span class="c1"># q1 points to the head of p1
</span>            <span class="k">assert</span><span class="p">(</span><span class="n">q2</span><span class="p">.</span><span class="n">cod</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">cod</span><span class="p">)</span> <span class="c1"># q2 points to the head of p2
</span>            <span class="k">assert</span><span class="p">(</span><span class="n">q1</span><span class="p">.</span><span class="n">dom</span> <span class="o">==</span> <span class="n">q2</span><span class="p">.</span><span class="n">dom</span><span class="p">)</span> <span class="c1"># tails of q1 and q2 are the same
</span>            <span class="k">assert</span><span class="p">(</span><span class="n">f</span> <span class="o">@</span> <span class="n">q1</span> <span class="o">==</span> <span class="n">g</span> <span class="o">@</span> <span class="n">q2</span><span class="p">)</span> <span class="c1"># commuting square condition
</span>            <span class="k">return</span> <span class="n">FinSet</span><span class="p">(</span> <span class="n">q1</span><span class="p">.</span><span class="n">dom</span><span class="p">,</span> <span class="n">e</span> <span class="p">,</span>  <span class="p">{</span> <span class="n">z</span> <span class="p">:</span> <span class="p">(</span> <span class="n">q1</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="p">,</span> <span class="n">q2</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="p">)</span>    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">q1</span><span class="p">.</span><span class="n">dom</span>  <span class="p">}</span>  <span class="p">)</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">univ</span>  
</code></pre></div></div>

<p>Here’s some fun exercises (Ok. Truth time. It’s because I got lazy). Try to implement <a href="https://en.wikipedia.org/wiki/Exponential_object">exponential</a> and <a href="https://en.wikipedia.org/wiki/Pushout_(category_theory)">pushout</a> for this category.</p>

:ET