I"L*<p>I’ve been fiddling with z3py, figuring out some functionality and realizing some interesting things you could do with it. I think I’m at a point where it is nice to checkpoint myself with a blog post.</p>

<p>I’m a little surprised z3py doesn’t overload the &amp; and | operators and some kind of implies operator for BoolRef. You can insert them later using this.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c1"># useful non default operator definitions for z3 bools
</span><span class="n">BoolRef</span><span class="p">.</span><span class="n">__and__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">And</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rhs</span><span class="p">)</span>
<span class="n">BoolRef</span><span class="p">.</span><span class="n">__or__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rhs</span><span class="p">)</span>
<span class="n">BoolRef</span><span class="p">.</span><span class="n">__xor__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rhs</span><span class="p">)</span>
<span class="n">BoolRef</span><span class="p">.</span><span class="n">__invert__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="n">BoolRef</span><span class="p">.</span><span class="n">__rshift__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Implies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rhs</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="functional-programming">Functional Programming</h4>

<p>Python is not the best functional programming environment imo. And by functional programming I implicitly mean roughly ML-like FP a la Haskell or OCaml. I don’t venture much into lisp land.</p>

<p>The lack of good algebraic datatypes (the class syntax is so ungainly) and a type system hurts. The lack of pattern matching hurts. The <code class="language-plaintext highlighter-rouge">lambda</code> keyword is so long it makes me sad.</p>

<p>But you have full access to z3 from the python bindings. Z3 does have algebraic data types, and a type system. It has built in substitution mechanisms and evaluation. And it has insane search procedures and the ability to prove things. Pretty damn cool!</p>

<p>Unfortunately the type system is rather simplistic, being basically simply typed rather than polymorphic or something else. But using python a a schema/macro system for z3 seems a plausible way forward.</p>

<p>To build templated types, you can have constructor functions in python for the appropriate types.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">Tuple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="s">'Tuple(f{(a.name(),b.name())})'</span><span class="p">)</span>
    <span class="n">Type</span><span class="p">.</span><span class="n">declare</span><span class="p">(</span><span class="s">'pair'</span><span class="p">,</span> <span class="p">(</span><span class="s">'fst'</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="s">'snd'</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Type</span><span class="p">.</span><span class="n">create</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Type</span>
<span class="k">def</span> <span class="nf">Either</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="s">'Either(f{(a.name(),b.name())})'</span><span class="p">)</span>
    <span class="n">Type</span><span class="p">.</span><span class="n">declare</span><span class="p">(</span><span class="s">'left'</span><span class="p">,</span> <span class="p">(</span><span class="s">'getLeft'</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">Type</span><span class="p">.</span><span class="n">declare</span><span class="p">(</span><span class="s">'right'</span><span class="p">,</span> <span class="p">(</span><span class="s">'getRight'</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Type</span><span class="p">.</span><span class="n">create</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Type</span> 
<span class="k">def</span> <span class="nf">Maybe</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="s">'Maybe(f{(a.name())})'</span><span class="p">)</span>
    <span class="n">Type</span><span class="p">.</span><span class="n">declare</span><span class="p">(</span><span class="s">'Just'</span><span class="p">,</span> <span class="p">(</span><span class="s">'fromJust'</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">Type</span><span class="p">.</span><span class="n">declare</span><span class="p">(</span><span class="s">"Nothing"</span><span class="p">)</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Type</span><span class="p">.</span><span class="n">create</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Type</span>
<span class="k">def</span> <span class="nf">List</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="s">'List(f{(a.name())})'</span><span class="p">)</span>
    <span class="n">Type</span><span class="p">.</span><span class="n">declare</span><span class="p">(</span><span class="s">'Cons'</span><span class="p">,</span> <span class="p">(</span><span class="s">'car'</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="s">'cdr'</span><span class="p">,</span> <span class="n">Type</span><span class="p">))</span>
    <span class="n">Type</span><span class="p">.</span><span class="n">declare</span><span class="p">(</span><span class="s">"Nil"</span><span class="p">)</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">Type</span><span class="p">.</span><span class="n">create</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Type</span>
<span class="s">''' 
Note in regards to List. Z3 has a built in type Seq that I think it has built in smarts about. You might be better off using that rather than a custom List. YMMV
'''</span>
</code></pre></div></div>

<p>You can access the constructors from the returned types. Check this out. You get detector functions <code class="language-plaintext highlighter-rouge">is_Nothing</code> and <code class="language-plaintext highlighter-rouge">is_Just</code> , the extractor function <code class="language-plaintext highlighter-rouge">fromJust</code> and constructor functions <code class="language-plaintext highlighter-rouge">Nothing</code> and <code class="language-plaintext highlighter-rouge">Just</code>. I do a lot of <code class="language-plaintext highlighter-rouge">dir</code> exploration with z3py. It’s hard to know what’s available sometimes</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
# dir(Maybe(IntSort())) returns
[
'Just',
 'Nothing',
... underscore junk ... ,
 'accessor',
 'as_ast',
 'ast',
 'cast',
 'constructor',
 'ctx',
 'ctx_ref',
 'eq',
 'fromJust',
 'get_id',
 'hash',
 'is_Just',
 'is_Nothing',
 'kind',
 'name',
 'num_constructors',
 'recognizer',
 'sexpr',
 'subsort',
 'translate',
 'use_pp']
</code></pre></div></div>

<p>It’s possible to build a general purpose match combinator on these types since you can introspect the number of constructors of the ADT using <code class="language-plaintext highlighter-rouge">num_constructors</code>, <code class="language-plaintext highlighter-rouge">constructor</code>, <code class="language-plaintext highlighter-rouge">recognizer</code>, and <code class="language-plaintext highlighter-rouge">accessor</code>. There might be a match inside z3py somewhere? I think it’s part of the SMTLIB standard now.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">num_constructors</span><span class="p">()</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">"_"</span><span class="p">]</span> <span class="c1"># default argument
</span>    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">constructor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">recognizer</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">nfields</span> <span class="o">=</span> <span class="n">con</span><span class="p">.</span><span class="n">arity</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nfields</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">con</span><span class="p">.</span><span class="n">name</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">con</span><span class="p">.</span><span class="n">name</span><span class="p">()](</span>  <span class="o">*</span><span class="p">[</span><span class="n">t</span><span class="p">.</span><span class="n">accessor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">a</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfields</span><span class="p">)]</span> <span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">If</span><span class="p">(</span><span class="n">rec</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">res</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<p>Example usage:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">match</span><span class="p">(</span><span class="n">Const</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="n">Maybe</span><span class="p">(</span><span class="n">IntSort</span><span class="p">())),</span> <span class="n">Just</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span> <span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nothing</span> <span class="o">=</span> <span class="n">IntVal</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">_</span><span class="o">=</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="c1"># returns If(is(Nothing, x), 3, If(is(Just, x), fromJust(x) + 1, 10))
</span></code></pre></div></div>

<p>Z3 has a substitution mechanism built in.  This is useful for instantiating <code class="language-plaintext highlighter-rouge">ForAll</code> and for evaluating <code class="language-plaintext highlighter-rouge">Lambda</code>. The <code class="language-plaintext highlighter-rouge">substitute_vars</code> function is what you want like so <code class="language-plaintext highlighter-rouge">substitute_vars(f.body(), x, y, z)</code></p>

<p>It is possible to reflect the syntax in a fairly straightforward way back into python via a lambdify function, mimicking the equivalent very useful <a href="https://docs.sympy.org/latest/modules/utilities/lambdify.html">function from sympy</a>. Lambdify is basically an <code class="language-plaintext highlighter-rouge">interp</code> function. Here is a start for such a function. I by no means have implemented interpretation of the entirety of z3. Also I feel like this implementation is very clunky. Some kind of CPS?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">lift1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="n">l</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

<span class="c1"># interp is useful for transferring expressions into numpy, sympy
# but also for program extraction
</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="n">op</span>
<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_true</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">is_false</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="n">is_int_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">a</span><span class="p">.</span><span class="n">as_long</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">is_rational_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">numerator_as_long</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">denominator_as_long</span><span class="p">()</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
    <span class="c1">#elif is_algebraic_value(a):
</span>    <span class="c1">#    pass
</span>    <span class="k">elif</span> <span class="n">is_const</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="c1"># is free variable
</span>        <span class="n">loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args2</span><span class="p">:</span> <span class="n">args2</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>   
    <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">interp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a</span><span class="p">.</span><span class="n">children</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">is_and</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">and_</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">is_or</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">or_</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_XOR</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">xor</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">is_add</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">add</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">is_mul</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">mul</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
        <span class="k">if</span> <span class="n">is_not</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift1</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">invert</span> <span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="c1"># lambda *args: ~n
</span>    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">l</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">is_eq</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">eq</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1">#lambda *args: l == r
</span>        <span class="k">elif</span> <span class="n">is_distinct</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="c1"># This can be multi_argument
</span>            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">ne</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># lambda *args: l != r
</span>        <span class="k">elif</span> <span class="n">is_sub</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># lambda *args: l - r
</span>        <span class="k">elif</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_POWER</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="nb">pow</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1">#lambda *args: l ** r
</span>        <span class="k">elif</span> <span class="n">is_div</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span>  <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="c1"># lambda *args: l / r
</span>        <span class="k">elif</span> <span class="n">is_idiv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">floordiv</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># lambda *args: l // r
</span>        <span class="k">elif</span> <span class="n">is_mod</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># lambda *args: l % r
</span>        <span class="k">elif</span> <span class="n">is_le</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">le</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># lambda *args: l &lt;= r
</span>        <span class="k">elif</span> <span class="n">is_lt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">lt</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># lambda *args: l &lt; r
</span>        <span class="k">elif</span> <span class="n">is_ge</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">ge</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1">#lambda *args: l &gt; r
</span>        <span class="k">elif</span> <span class="n">is_gt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lift2</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="c1"># lambda *args: l &gt;= r
</span>        <span class="k">elif</span> <span class="n">is_implies</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="p">(</span><span class="o">~</span> <span class="n">l</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">r</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> 
    <span class="k">print</span><span class="p">(</span><span class="s">"unrecognized constructor: "</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">assert</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">#example usage
</span><span class="n">a</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
<span class="n">interp</span><span class="p">(</span><span class="n">Xor</span><span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">a</span> <span class="o">|</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Reals</span><span class="p">(</span><span class="s">'x y'</span><span class="p">)</span>
<span class="n">interp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="p">,</span><span class="n">y</span><span class="p">)(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>There is the ability to define recursive functions in z3. It is also plausible to define them via. In this way you can get a reversible functional programming language, maybe some subset of mercury / curry’s power.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">fac</span> <span class="o">=</span> <span class="n">RecFunction</span><span class="p">(</span><span class="s">'fac'</span><span class="p">,</span> <span class="n">IntSort</span><span class="p">(),</span> <span class="n">IntSort</span><span class="p">())</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="s">'n'</span><span class="p">)</span>
<span class="n">RecAddDefinition</span><span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">If</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">()</span>
<span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
<span class="c1">#  returns [n = 3, fac = [0 → 1, else → fac(-1 + ν0)·ν0]]
</span></code></pre></div></div>

<h3 id="interactive-theorem-proving">Interactive Theorem Proving</h3>

<p>Z3 is awesome at thoerem proving. But somethings it just doesn’t handle right and needs human guidance.</p>

<p>Through searching, there are a couple interesting python interactive theorem prover projects. Cody pointed me to a project he worked on a while back, Boole <a href="https://github.com/avigad/boole">https://github.com/avigad/boole</a> . It has a dependently typed lambda calculus in it with the purpose of gluing together many systems, I think. He implemented a lot of stuff from scratch. I think I want to try to get less and do less. There is also holpy <a href="https://arxiv.org/abs/1905.05970">https://arxiv.org/abs/1905.05970</a> which appears to be being actively developed. It’s roughly a translation of hol to python I think. It’s available from a strange chinese github on the author’s website if you go looking for it.</p>

<p>This suggests an interesting approach. Most interactive theorem provers start unautomated and add it later. Instead we can iteratively build an interface to de-automate z3.</p>

<p>Altogether, this approach is more HOL flavored than Coq/Agda flavored. z3 terms are our logic and python is our manipulation metal language. Ideally, one would want to verify that every.</p>

<p>Python is so unprincipled that I can’t imagine that you could ever build a system up to the trustworthiness of the other theorem provers. But this is freeing in many ways. Since that is off the table, we can just do the best we can.</p>

<p>Using the z3 syntax tree and the z3 proof automation and z3 substitution mechanisms gives us a HUGE step up from implementing them from scratch. Ideally, we’d want to write as little python as possible, and especially as little python as possible that has to be trusted to be implemented correctly.</p>

<p>One big concern is accidental mutation of the proof under our feet by python. Perhaps using hashes and checking them might be a way to at least detect this. I need to have a good think about how to factor out a trusted core from all possible tactics.</p>

<p>I think it helps a little that z3 often will be able to verify the equivalence of small steps in proofs even if it can’t do the entire proof itself.</p>

<p>I think induction principles will need to be injected by hand. Z3 doesn’t really have that built in. There are definitely situations that after you introduce the induction, z3 can slam all the cases no problem. For example, check this out.</p>

<p>Another thing that might be nice is integration/translation to sympy. Sympy has a ton of useful functionality, at the very least differentiation.</p>

<p>Translation and integration with cvxpy for sum of squares proofs would also be quite neat. I already did something with this using sympy. I’m not super sure how you extract exact proofs from the floating point solutions SCS returns? I think there is a thing. I’ve heard the LLL algorithm can be used for this somehow (finding likely algebraic number matches to floating point numbers)?</p>

<p>So here are some sketched out ideas for tactics.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Proof</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="c1"># Taken a name for the theorem?
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">goals</span> <span class="o">=</span> <span class="p">[([],</span><span class="n">goal</span><span class="p">)]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">proven</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="c1">#def intros(self): #intro_all        
</span>    <span class="c1">#    self.goals.append( (ctx, goal.intros())  )
</span>    <span class="c1">#    return self
</span>    <span class="k">def</span> <span class="nf">equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">goal2</span><span class="p">):</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">prove2</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">),</span> <span class="n">goal1</span> <span class="o">==</span> <span class="n">goal2</span><span class="p">)):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">goal2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">goal1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rhs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">equiv</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
    <span class="c1">#def assert(): #put new goal in stack with current context. Put into context of 1 below top
</span>    <span class="c1">#def assume(): #just put crap in the context.
</span>    <span class="k">def</span> <span class="nf">intro_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#name = hint maybe later
</span>        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">goal</span><span class="p">.</span><span class="n">is_forall</span><span class="p">())</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">FreshConst</span><span class="p">(</span><span class="n">goal</span><span class="p">.</span><span class="n">var_sort</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">goal</span><span class="p">.</span><span class="n">var_name</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">goal</span><span class="p">.</span><span class="n">num_vars</span><span class="p">())]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">instantiate</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span><span class="o">*</span><span class="n">vs</span><span class="p">)</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">+</span> <span class="n">vs</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span> <span class="c1"># wait. I should keep propositions and variables seperate
</span>        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">intro_imp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#intro_impl
</span>        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_implies</span><span class="p">(</span><span class="n">goal</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">goal</span><span class="p">.</span><span class="n">children</span><span class="p">()</span>
            <span class="n">ctx</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx</span><span class="p">,</span><span class="n">goal</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#z3 tactic split-clauses?
</span>        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_and</span><span class="p">(</span><span class="n">goal</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">goal</span><span class="p">.</span><span class="n">children</span><span class="p">():</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx</span><span class="p">,</span><span class="n">c</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx</span><span class="p">,</span><span class="n">goal</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">z3_tactic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1">#g = t(Implies(And(*ctx), goal)).as_expr()
</span>        <span class="n">g</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">goal</span><span class="p">).</span><span class="n">as_expr</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">(([],</span><span class="n">g</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">simpl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">z3_tactic</span><span class="p">(</span><span class="s">"simplify"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">congruence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#maybe search for equalities. And put them in the goal
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">z3_tactic</span><span class="p">(</span><span class="s">"solve-eqs"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">smt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
        <span class="c1">#s.set(**keywords)
</span>        <span class="n">claim</span> <span class="o">=</span> <span class="n">Implies</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">),</span> <span class="n">goal</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">claim</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span>  <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Countermodel : "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()))</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">destruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_bool</span><span class="p">(</span><span class="n">goal</span><span class="p">):</span>
            <span class="n">ctx1</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ctx2</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ctx1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">goal</span> <span class="o">==</span> <span class="bp">True</span><span class="p">)</span>
            <span class="n">ctx2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">goal</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx2</span><span class="p">,</span> <span class="n">BoolVal</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span> <span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx1</span><span class="p">,</span> <span class="n">BoolVal</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span> <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span><span class="p">))</span>    
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">forget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">ctx</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span><span class="p">))</span>  
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">qed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">proven</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># add self to global proof context if self.name is not None
</span>    <span class="k">def</span> <span class="nf">get_ctx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ctx</span><span class="p">,</span> <span class="n">goal</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">goals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">f"[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">] </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="si">}</span><span class="s"> : </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">sort</span><span class="p">())</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ctx</span><span class="p">)])</span> <span class="o">+</span> <span class="s">"----------------</span><span class="se">\n</span><span class="s">"</span> <span class="o">+</span> <span class="s">f"</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span><span class="si">}</span><span class="s"> : </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">goal</span><span class="p">.</span><span class="n">sort</span><span class="p">())</span><span class="si">}</span><span class="s">"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"No Goals Left"</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">x</span> <span class="o">=</span> <span class="n">Real</span><span class="p">(</span><span class="s">"x"</span><span class="p">)</span>
<span class="n">Proof</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">).</span><span class="n">equiv</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">).</span><span class="n">equiv</span><span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Bools</span><span class="p">(</span><span class="s">'a b'</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Proof</span><span class="p">((</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">intro_imp</span><span class="p">().</span><span class="n">destruct</span><span class="p">()</span> 
   <span class="p">.</span><span class="n">smt</span><span class="p">()</span> \
   <span class="p">.</span><span class="n">smt</span><span class="p">()</span> \
<span class="p">.</span><span class="n">qed</span><span class="p">()</span>
</code></pre></div></div>

<p>Another question is how to implement an apply tactic gracefully. Fully deconstructing syntax trees and unifying ourselves is not utilizing z3 well. If you have a good idea how to get unification out of z3, I’d be interested to hear from you here.  <a href="https://stackoverflow.com/questions/59398955/getting-z3-instantiations-of-quantified-variables/59400838#59400838">https://stackoverflow.com/questions/59398955/getting-z3-instantiations-of-quantified-variables/59400838#59400838</a></p>

<p>Here’s an idea though. In the cold light of day, I am still not sure this reasoning makes much sense. Suppose we’re trying to apply forall x. a(x) -&gt; b(x) to a c(y). If forall x. b(x) -&gt; c(y) we’re good and by assumption that is obvious for some reason, like the syntactic instantiation of b gives c. We can ask z3 to prove that and it will hopefully easy. If we can prove forall x. a(x) in the current context, that would be sufficient, but not true typically. It is an overly difficult request. We really only need to prove a(x) for values pertinent to the proof of c(y). Here’s a suspicious strategem. Any a -&gt; b can be weakened to (q -&gt; a) -&gt; (q -&gt; b). In particular we can choose to weaken forall x. a(x) -&gt; b(x) to forall x. ((c(y) -&gt; b(x)) -&gt; a(x)) -&gt; ((c(y) -&gt; b(x)) -&gt; b(x)). Then we can replace the goal with forall x. ((c(y) -&gt; b(x)) -&gt; a(x)) after we prove that (forall x. (c(y) -&gt; b(x)) -&gt; b(x)) -&gt; c(y).  Maybe c(y) -&gt; b(x) is sufficient to restrict the values of x? Not sure.</p>

<p>Another rough sketch of induction on Nat. Not right yet.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">inductionNat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_vars</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">var_sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">IntSort</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">is_forall</span><span class="p">())</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">FreshInt</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">instantiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">ForAll</span><span class="p">([</span><span class="n">n</span><span class="p">],</span><span class="n">instantiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">instantiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p>We could also make a simple induction for ADTs based on the similar introspection we used for <code class="language-plaintext highlighter-rouge">match</code> above. It’s ugly but I think it works.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">induction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">is_quantifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">is_forall</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_vars</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">#we can eventually relax vars = 1
</span>    <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">var_sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">num_constructors</span><span class="p">()</span>
    <span class="n">th</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">constructor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">nfields</span> <span class="o">=</span> <span class="n">con</span><span class="p">.</span><span class="n">arity</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nfields</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">th</span> <span class="o">+=</span> <span class="p">[</span><span class="n">substitute_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">body</span><span class="p">(),</span> <span class="n">con</span><span class="p">())]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hyp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfields</span><span class="p">):</span>
                <span class="n">td</span> <span class="o">=</span> <span class="n">con</span><span class="p">.</span><span class="n">domain</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">FreshConst</span><span class="p">(</span><span class="n">td</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">td</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">hyp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">substitute_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">body</span><span class="p">(),</span> <span class="n">x</span><span class="p">)]</span>
                <span class="n">args</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="n">th</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ForAll</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">Implies</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">hyp</span><span class="p">),</span> <span class="n">substitute_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">body</span><span class="p">(),</span> <span class="n">con</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))))]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">)</span>
</code></pre></div></div>

<p>I haven’t really though much about tacticals yet.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
# describe_tactics() gives a list of all z3 tactics
ackermannize_bv : A tactic for performing full Ackermannization on bv instances.
subpaving : tactic for testing subpaving module.
horn : apply tactic for horn clauses.
horn-simplify : simplify horn clauses.
nlsat : (try to) solve goal using a nonlinear arithmetic solver.
qfnra-nlsat : builtin strategy for solving QF_NRA problems using only nlsat.
nlqsat : apply a NL-QSAT solver.
qe-light : apply light-weight quantifier elimination.
qe-sat : check satisfiability of quantified formulas using quantifier elimination.
qe : apply quantifier elimination.
qsat : apply a QSAT solver.
qe2 : apply a QSAT based quantifier elimination.
qe_rec : apply a QSAT based quantifier elimination recursively.
psat : (try to) solve goal using a parallel SAT solver.
sat : (try to) solve goal using a SAT solver.
sat-preprocess : Apply SAT solver preprocessing procedures (bounded resolution, Boolean constant propagation, 2-SAT, subsumption, subsumption resolution).
ctx-solver-simplify : apply solver-based contextual simplification rules.
smt : apply a SAT based SMT solver.
psmt : builtin strategy for SMT tactic in parallel.
unit-subsume-simplify : unit subsumption simplification.
aig : simplify Boolean structure using AIGs.
add-bounds : add bounds to unbounded variables (under approximation).
card2bv : convert pseudo-boolean constraints to bit-vectors.
degree-shift : try to reduce degree of polynomials (remark: :mul2power simplification is automatically applied).
diff-neq : specialized solver for integer arithmetic problems that contain only atoms of the form (&lt;= k x) (&lt;= x k) and (not (= (- x y) k)), where x and y are constants and k is a numeral, and all constants are bounded.
eq2bv : convert integer variables used as finite domain elements to bit-vectors.
factor : polynomial factorization.
fix-dl-var : if goal is in the difference logic fragment, then fix the variable with the most number of occurrences at 0.
fm : eliminate variables using fourier-motzkin elimination.
lia2card : introduce cardinality constraints from 0-1 integer.
lia2pb : convert bounded integer variables into a sequence of 0-1 variables.
nla2bv : convert a nonlinear arithmetic problem into a bit-vector problem, in most cases the resultant goal is an under approximation and is useul for finding models.
normalize-bounds : replace a variable x with lower bound k &lt;= x with x' = x - k.
pb2bv : convert pseudo-boolean constraints to bit-vectors.
propagate-ineqs : propagate ineqs/bounds, remove subsumed inequalities.
purify-arith : eliminate unnecessary operators: -, /, div, mod, rem, is-int, to-int, ^, root-objects.
recover-01 : recover 0-1 variables hidden as Boolean variables.
bit-blast : reduce bit-vector expressions into SAT.
bv1-blast : reduce bit-vector expressions into bit-vectors of size 1 (notes: only equality, extract and concat are supported).
bv_bound_chk : attempts to detect inconsistencies of bounds on bv expressions.
propagate-bv-bounds : propagate bit-vector bounds by simplifying implied or contradictory bounds.
propagate-bv-bounds-new : propagate bit-vector bounds by simplifying implied or contradictory bounds.
reduce-bv-size : try to reduce bit-vector sizes using inequalities.
bvarray2uf : Rewrite bit-vector arrays into bit-vector (uninterpreted) functions.
dt2bv : eliminate finite domain data-types. Replace by bit-vectors.
elim-small-bv : eliminate small, quantified bit-vectors by expansion.
max-bv-sharing : use heuristics to maximize the sharing of bit-vector expressions such as adders and multipliers.
blast-term-ite : blast term if-then-else by hoisting them.
cofactor-term-ite : eliminate term if-the-else using cofactors.
collect-statistics : Collects various statistics.
ctx-simplify : apply contextual simplification rules.
der : destructive equality resolution.
distribute-forall : distribute forall over conjunctions.
dom-simplify : apply dominator simplification rules.
elim-term-ite : eliminate term if-then-else by adding fresh auxiliary declarations.
elim-uncnstr : eliminate application containing unconstrained variables.
injectivity : Identifies and applies injectivity axioms.
snf : put goal in skolem normal form.
nnf : put goal in negation normal form.
occf : put goal in one constraint per clause normal form (notes: fails if proof generation is enabled; only clauses are considered).
pb-preprocess : pre-process pseudo-Boolean constraints a la Davis Putnam.
propagate-values : propagate constants.
reduce-args : reduce the number of arguments of function applications, when for all occurrences of a function f the i-th is a value.
reduce-invertible : reduce invertible variable occurrences.
simplify : apply simplification rules.
elim-and : convert (and a b) into (not (or (not a) (not b))).
solve-eqs : eliminate variables by solving equations.
special-relations : detect and replace by special relations.
split-clause : split a clause in many subgoals.
symmetry-reduce : apply symmetry reduction.
tseitin-cnf : convert goal into CNF using tseitin-like encoding (note: quantifiers are ignored).
tseitin-cnf-core : convert goal into CNF using tseitin-like encoding (note: quantifiers are ignored). This tactic does not apply required simplifications to the input goal like the tseitin-cnf tactic.
qffd : builtin strategy for solving QF_FD problems.
pqffd : builtin strategy for solving QF_FD problems in parallel.
smtfd : builtin strategy for solving SMT problems by reduction to FD.
fpa2bv : convert floating point numbers to bit-vectors.
qffp : (try to) solve goal using the tactic for QF_FP.
qffpbv : (try to) solve goal using the tactic for QF_FPBV (floats+bit-vectors).
qffplra : (try to) solve goal using the tactic for QF_FPLRA.
default : default strategy used when no logic is specified.
sine-filter : eliminate premises using Sine Qua Non
qfbv-sls : (try to) solve using stochastic local search for QF_BV.
nra : builtin strategy for solving NRA problems.
qfaufbv : builtin strategy for solving QF_AUFBV problems.
qfauflia : builtin strategy for solving QF_AUFLIA problems.
qfbv : builtin strategy for solving QF_BV problems.
qfidl : builtin strategy for solving QF_IDL problems.
qflia : builtin strategy for solving QF_LIA problems.
qflra : builtin strategy for solving QF_LRA problems.
qfnia : builtin strategy for solving QF_NIA problems.
qfnra : builtin strategy for solving QF_NRA problems.
qfuf : builtin strategy for solving QF_UF problems.
qfufbv : builtin strategy for solving QF_UFBV problems.
qfufbv_ackr : A tactic for solving QF_UFBV based on Ackermannization.
ufnia : builtin strategy for solving UFNIA problems.
uflra : builtin strategy for solving UFLRA problems.
auflia : builtin strategy for solving AUFLIA problems.
auflira : builtin strategy for solving AUFLIRA problems.
aufnira : builtin strategy for solving AUFNIRA problems.
lra : builtin strategy for solving LRA problems.
lia : builtin strategy for solving LIA problems.
lira : builtin strategy for solving LIRA problems.
skip : do nothing tactic.
fail : always fail tactic.
fail-if-undecided : fail if goal is undecided.
macro-finder : Identifies and applies macros.
quasi-macros : Identifies and applies quasi-macros.
ufbv-rewriter : Applies UFBV-specific rewriting rules, mainly demodulation.
bv : builtin strategy for solving BV problems (with quantifiers).
ufbv : builtin strategy for solving UFBV problems (with quantifiers).
</code></pre></div></div>

:ET