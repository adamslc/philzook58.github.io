I"<p>Neural networks are all the rage these days. One mundane way of looking at neural networks is that they are a particular class of parametrized functions . What makes them useful is:</p>

<ol>
  <li>They can be used at insane scale due to their simplicity and excellent available implementations and tooling</li>
  <li>There are intuitive ways to input abstract structure and symmetry expected of a problem, for example translation symmetry, or a hierarchy of small scale pattern recognition combining into large scale structures. How this all works is very peculiar.</li>
  <li>Inspirational analogies can be drawn from nature.</li>
</ol>

<p>Neural networks made out of just <a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)">relus</a> (rectified linear units, relu(x) = max(0,x) ) and linear layers are particularly amenable to formal analysis. Regarding the weights as fixed (once a network has be trained), the complete neural network is a piecewise linear function. The regions where it is piecewise define are polyhedra (They are defined by the hyperplanes of the relu transitions as inequality constraints). Such functions are among those the most amenable to automated rigorous analysis.</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/12/relu.png" alt="" />A relu</p>

<p>Most machine learning tasks donâ€™t have a mathematically precise specification. What is the mathematically precise definition of a picture of a horse? We could try to come up with something (this is sort of what good old fashioned AI tried to do), but in my opinion it would be rather suspect.</p>

<p>Tasks that do have a precise spec are questionable areas for machine learning techniques, because how can you know that the network meets the spec? Also, one would suspect such a problem would have structure that you might be better off with a more traditional algorithmic approach.</p>

<p>However, there a a couple areas where one does have reasonable formal questions one might want to ask about a neural network:</p>

<ul>
  <li>Robustness around training and validation data. Finding <a href="https://openai.com/blog/adversarial-example-research/">Adversarial examples</a> or proving there are none.</li>
  <li>Games like Go. Alpha Go is a marriage of more traditional algorithmic approaches and machine learning. There is a core of traditional game tree search to it.</li>
  <li>Control Systems - There are many control systems which we do have a reasonable formal spec one could write, such as walking robots. These systems are so high dimensional that it is difficult to derive a good controller from the spec, and hence reinforcement learning may be a reasonable option. But we would like to confirm the controller is good and not dangerous</li>
  <li>Neural networks as computational accelerators. There are problems which we know how to solve, but are too slow. Neural networks can be evaluated very quickly and easily thanks to modern frameworks.  It may be useful to presolve a large number of examples offline using the slow algorithm and train a neural network to give good estimates.   We may be able to replace the slow thing entirely if we can verify the neural network always is good enough.</li>
</ul>

<p>Weâ€™re going to use a neural network to fit a chebyshev polynomial. Here weâ€™re picking a Chebyshev polynomial as our base truth because Chebyshev polynomials have some pleasant waviness to them. Why not. I like â€˜em.  Also polynomials are easily understood by z3 as a base spec.</p>

<p>This example of course is a complete toy. How often do you see 1-D input space neural networks? Not often I bet.<br />
But itâ€™s nice for a couple reasons:</p>

<ol>
  <li>Because we can visualize it.</li>
  <li>It drives home the point about neural nets being a space of piecewise linear function approximators, and how similar training is to curve fitting.</li>
  <li>Itâ€™s simple enough that z3 can crush it. There is a big question if z3 or other methods can scale to realistic neural nets. Modern top of the line neural nets are insanely huge. As weâ€™ve done it here, I highly doubt it. There are special purpose SMT solvers being built for this task. Also the slightly different technology of mixed integer programming can be used and seems very promising.  So this is an area of research. See links at the bottom for more.</li>
</ol>

<p>Generally speaking, the combination of the capabilities of sympy and z3 give us access to some very intriguing possibilities. Iâ€™m not going to investigate this in detail in this post, but I are showing how you can convert a sympy derived polynomial into a python expression using <code class="language-plaintext highlighter-rouge">lambdify</code>, which can then be in turn used on z3 variables.</p>

<p>[gist https://gist.github.com/philzook58/5aab67b65b476bb55e6b9c403ccabed2#file-cheb-py]</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/12/cheb.png" alt="" />Our actual chebyshev polynomial</p>

<p>Here we build a very small 3 layers network using Keras. We use a least squares error and an adam optimizer. Whatever. I actually had difficulty getting nice results out for higher order chebyshev polynomials. Neural networks are so fiddly.</p>

<p>[gist https://gist.github.com/philzook58/5aab67b65b476bb55e6b9c403ccabed2#file-train-py]</p>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/12/neural_fit.png" alt="" />Our neural fit of the polynomial</p>

<p>And here we extract the weights and reinterpret them into z3. We could also have used z3 floating point capabilities rather than reals if youâ€™re concerned about numerical issues.  It was convenient to have my layers be different sizes, so that size mismatch would throw a python error. Thatâ€™s how I found out the weights are transposed by default. The code at the end extracts a found countermodel and evaluates it. If you want to feel fancier, you can also use the prove function rather than an explicit <code class="language-plaintext highlighter-rouge">Solver()</code> instance. Saying you proved the neural network matches the polynomial to a certain tolerance feels really good. If you look at the graphs, the edges at 1 and -1 actually have pretty bad absolute error, around 0.5.</p>

<p>[gist https://gist.github.com/philzook58/5aab67b65b476bb55e6b9c403ccabed2#file-verify-py]</p>

<h4 id="links">Links</h4>

<p><a href="https://github.com/sisl/NeuralVerification.jl">https://github.com/sisl/NeuralVerification.jl</a></p>

<p><a href="https://arxiv.org/abs/1711.07356">https://arxiv.org/abs/1711.07356</a> - Evaluating Robustness of Neural Networks with Mixed Integer Programming</p>

<p><a href="https://github.com/vtjeng/MIPVerify.jl">https://github.com/vtjeng/MIPVerify.jl</a></p>

<p><a href="https://arxiv.org/abs/1702.01135">https://arxiv.org/abs/1702.01135</a> - reluplex, SMT specifically for neural networks</p>

:ET