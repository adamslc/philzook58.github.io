I"h°<p>Minikanren is a relation and logic programming language similar in many respects to prolog. Itâ€™s designed to be lightweight and embeddable in other host languages.</p>

<p>There is a paper about a minimal implementation call MicroKanren that has spawned many derivatives. Itâ€™s impressively short. <a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf">http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf</a> .</p>

<p>Iâ€™m intrigued about such things and have my reasons for building a version of this in Julia (perhaps as an inference engine for Catlab stuff? More on that another day). There are already some implementations, but Iâ€™m opinionated and I really wanted to be sure I know how the guts work. Best way is to DIY.</p>

<p>There are at least 3 already existing implementations in Julia alone.</p>

<ul>
  <li><a href="https://github.com/latticetower/MuKanren.jl">https://github.com/latticetower/MuKanren.jl</a></li>
  <li><a href="https://github.com/habemus-papadum/LilKanren.jl">https://github.com/habemus-papadum/LilKanren.jl</a></li>
  <li><a href="https://github.com/RAbraham/MiniKanren">https://github.com/RAbraham/MiniKanren</a></li>
</ul>

<p>Logic programming consists of basically two pieces, search and unification. The search shows up as a stream. MiniKanren does a kind of clever search by interleaving looking at different branches. This stops it from getting stuck in a bad infinite branch in principle. The interleaving is kind of like a riffled list append.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">interleave</span> <span class="x">[]</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span>
<span class="n">interleave</span> <span class="x">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="x">)</span>  <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">interleave</span> <span class="n">ys</span> <span class="n">xs</span> 
</code></pre></div></div>

<p>But then the actual streams used in Kanren have thunks lying around in them that also need to get forced. These thunk positions are where it chooses to switch over to another branch of the search.</p>

<p>Unification is comparing two syntax trees with variables in them. As you scan down them, you can identify which variables correspond to which subtrees in the other structure. You may find a contradictory assignment, or only a partial assignment. I talked more about unification <a href="https://www.philipzucker.com/unification-in-julia/">here</a>. Kanren uses triangular substitutions to record the variable assignments. These subsitutions are very convenient to make, but when you want to access a variable, you have to walk through the substitution. Itâ€™s a tradeoff.</p>

<p>Here we start describing my Julia implementation. Buyer beware. Iâ€™ve been finding very bad bugs very recently.</p>

<p>I diverged from microKanren in a couple ways. I wanted to not use a list based structure for unification. I feel like the most Julian thing to do is to use the Expr data structure that is built by Julia quotation <code class="language-plaintext highlighter-rouge">:</code>.  You can see here that I tried to use a more imperative style where I could figure out how to, which I think is more idiomatic Julia.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">struct</span><span class="nc"> Var</span> 
    <span class="n">x</span><span class="o">::</span><span class="kt">Symbol</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> walk</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">u</span><span class="x">)</span> 
    <span class="k">while</span> <span class="k">isa</span><span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">Var</span><span class="x">)</span> <span class="o">&amp;&amp;</span> <span class="n">haskey</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">u</span><span class="x">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">get</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">u</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">u</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> unify</span><span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">v</span><span class="x">,</span><span class="n">s</span><span class="x">)</span> <span class="c"># basically transcribed from the microkanren paper</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">walk</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">u</span><span class="x">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">walk</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">v</span><span class="x">)</span>
    <span class="k">if</span> <span class="k">isa</span><span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">Var</span><span class="x">)</span> <span class="o">&amp;&amp;</span> <span class="k">isa</span><span class="x">(</span><span class="n">v</span><span class="x">,</span><span class="n">Var</span><span class="x">)</span> <span class="o">&amp;&amp;</span> <span class="n">u</span> <span class="o">===</span> <span class="n">v</span> <span class="c"># do nothing if same</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="k">elseif</span> <span class="k">isa</span><span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">Var</span><span class="x">)</span>
        <span class="k">return</span> <span class="n">assoc</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">u</span><span class="x">,</span><span class="n">v</span><span class="x">)</span>
    <span class="k">elseif</span> <span class="k">isa</span><span class="x">(</span><span class="n">v</span><span class="x">,</span><span class="n">Var</span><span class="x">)</span>
        <span class="k">return</span> <span class="n">assoc</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">v</span><span class="x">,</span><span class="n">u</span><span class="x">)</span>
    <span class="k">elseif</span> <span class="k">isa</span><span class="x">(</span><span class="n">u</span><span class="x">,</span> <span class="kt">Expr</span><span class="x">)</span> <span class="o">&amp;&amp;</span> <span class="k">isa</span><span class="x">(</span><span class="n">v</span><span class="x">,</span><span class="kt">Expr</span><span class="x">)</span>
        <span class="c"># Only function call expressions are implemented at the moment </span>
        <span class="nd">@assert</span> <span class="n">u</span><span class="o">.</span><span class="n">head</span> <span class="o">===</span> <span class="o">:</span><span class="n">call</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">.</span><span class="n">head</span> <span class="o">===</span> <span class="o">:</span><span class="n">call</span> 
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">===</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span> <span class="o">&amp;&amp;</span> <span class="n">length</span><span class="x">(</span><span class="n">u</span><span class="o">.</span><span class="n">args</span><span class="x">)</span> <span class="o">==</span> <span class="n">length</span><span class="x">(</span><span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="x">)</span> <span class="c">#heads match</span>
            <span class="k">for</span> <span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">v</span><span class="x">)</span> <span class="k">in</span> <span class="n">zip</span><span class="x">(</span> <span class="n">u</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="x">]</span> <span class="x">,</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="x">]</span> <span class="x">)</span>  <span class="c"># unify subpieces</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">unify</span><span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">v</span><span class="x">,</span><span class="n">s</span><span class="x">)</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">===</span> <span class="nb">nothing</span>
                    <span class="k">return</span> <span class="nb">nothing</span>
                <span class="k">end</span>
            <span class="k">end</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span> <span class="c"># heads don't match or different arity</span>
            <span class="k">return</span> <span class="nb">nothing</span> 
        <span class="k">end</span>
    <span class="k">else</span> <span class="c"># catchall for Symbols, Integers, etc</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">===</span> <span class="n">v</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nb">nothing</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>I decided to use the <code class="language-plaintext highlighter-rouge">gensym</code> facility of Julia to produce new variables. That way I donâ€™t have to thread around a variable counter like microkanren does (Julia is already doing this somewhere under the hood). Makes things a touch simpler. I made a couple <code class="language-plaintext highlighter-rouge">fresh</code> combinators for convenience. Basically you pass them an anonymous function and you get fresh logic variables to use.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="n">fresh</span><span class="x">(</span><span class="n">f</span><span class="x">)</span> <span class="o">=</span> <span class="n">f</span><span class="x">(</span><span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">()))</span>
<span class="n">fresh2</span><span class="x">(</span><span class="n">f</span><span class="x">)</span> <span class="o">=</span> <span class="n">f</span><span class="x">(</span><span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">()),</span> <span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">()))</span>
<span class="n">fresh3</span><span class="x">(</span><span class="n">f</span><span class="x">)</span> <span class="o">=</span> <span class="n">f</span><span class="x">(</span><span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">()),</span> <span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">()),</span> <span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">()))</span>
<span class="n">freshn</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">f</span><span class="x">)</span> <span class="o">=</span> <span class="n">f</span><span class="x">([</span><span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">())</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span> <span class="x">]</span><span class="o">...</span><span class="x">)</span> <span class="c"># fishy lookin, but works. Not so obvious the evaluation order here.</span>

</code></pre></div></div>

<p>Kanren is based around composing goals with disjunction and conjunction. A goal is a function that accepts a current substitution dictionary <code class="language-plaintext highlighter-rouge">s</code> and outputs a stream of possible new substitution dictionaries. If the goal fails, it outputs an empty stream. If the goal succeeds only one way, it outputs a singleton stream. I decided to attempt to use iterators to encode my streams. Iâ€™m not sure I succeeded. I also decided to forego separating out <code class="language-plaintext highlighter-rouge">mplus</code> and <code class="language-plaintext highlighter-rouge">unit</code> to match the microkanren notation and inlined their definition here. The simplest implementation of conjunction and disjunction look like this.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># unification goal</span>
<span class="n">eqwal</span><span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">v</span><span class="x">)</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="k">begin</span>   
                     <span class="n">s</span> <span class="o">=</span> <span class="n">unify</span><span class="x">(</span><span class="n">u</span><span class="x">,</span><span class="n">v</span><span class="x">,</span><span class="n">s</span><span class="x">)</span>
                     <span class="x">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">nothing</span><span class="x">)</span> <span class="o">?</span> <span class="x">()</span> <span class="o">:</span> <span class="x">(</span><span class="n">s</span><span class="x">,)</span>
                  <span class="k">end</span>

<span class="c"># concatenate them</span>
<span class="n">disj</span><span class="x">(</span><span class="n">g1</span><span class="x">,</span><span class="n">g2</span><span class="x">)</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Iterators</span><span class="o">.</span><span class="n">flatten</span><span class="x">(</span>  <span class="x">(</span><span class="n">g1</span><span class="x">(</span><span class="n">s</span><span class="x">)</span>  <span class="x">,</span> <span class="n">g2</span><span class="x">(</span><span class="n">s</span><span class="x">))</span> <span class="x">)</span> 
<span class="c"># bind = "flatmap". flatten ~ join</span>
<span class="n">conj</span><span class="x">(</span><span class="n">g1</span><span class="x">,</span><span class="n">g2</span><span class="x">)</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Iterators</span><span class="o">.</span><span class="n">flatten</span><span class="x">(</span> <span class="n">map</span><span class="x">(</span> <span class="n">g2</span> <span class="x">,</span>  <span class="n">g1</span><span class="x">(</span><span class="n">s</span><span class="x">)</span> <span class="x">))</span>
</code></pre></div></div>

<p>However, the next level throws thunks in the mix. I think I got it to work with a special thunk Iterator type. It mutates the iterator to unthunkify it upon first forcing. I have no idea what the performance characteristics of this are.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Where do these get forced. Not obvious. Do they get forced when flattened? </span>
<span class="k">mutable struct</span><span class="nc"> Thunk</span> <span class="c">#{I}</span>
   <span class="n">it</span> <span class="c"># Union{I,Function}</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> pull</span><span class="x">(</span><span class="n">x</span><span class="x">)</span> <span class="c"># Runs the trampoline</span>
    <span class="k">while</span> <span class="k">isa</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="kt">Function</span><span class="x">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="x">()</span>
    <span class="k">end</span>
    <span class="n">x</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> Base.length</span><span class="x">(</span><span class="n">x</span><span class="o">::</span><span class="n">Thunk</span><span class="x">)</span> 
    <span class="n">x</span><span class="o">.</span><span class="n">it</span> <span class="o">=</span> <span class="n">pull</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">it</span><span class="x">)</span>
    <span class="n">Base</span><span class="o">.</span><span class="n">length</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">it</span><span class="x">)</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> Base.iterate</span><span class="x">(</span><span class="n">x</span><span class="o">::</span><span class="n">Thunk</span><span class="x">)</span> 
    <span class="n">x</span><span class="o">.</span><span class="n">it</span> <span class="o">=</span> <span class="n">pull</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">it</span><span class="x">)</span>
    <span class="n">Base</span><span class="o">.</span><span class="n">iterate</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">it</span><span class="x">)</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> Base.iterate</span><span class="x">(</span><span class="n">x</span><span class="o">::</span><span class="n">Thunk</span><span class="x">,</span> <span class="n">state</span><span class="x">)</span> 
    <span class="n">x</span><span class="o">.</span><span class="n">it</span> <span class="o">=</span> <span class="n">pull</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">it</span><span class="x">)</span> <span class="c"># Should we assume forced?</span>
    <span class="n">Base</span><span class="o">.</span><span class="n">iterate</span><span class="x">(</span><span class="n">x</span><span class="o">.</span><span class="n">it</span><span class="x">,</span> <span class="n">state</span><span class="x">)</span>
<span class="k">end</span>

<span class="c"># does this have to be a macro? Yes. For evaluation order. We want g </span>
<span class="c"># evaluating after Zzz is called, not before</span>
<span class="k">macro</span><span class="nf"> Zzz</span><span class="x">(</span><span class="n">g</span><span class="x">)</span> 
    <span class="k">return</span> <span class="o">:</span><span class="x">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Thunk</span><span class="x">(()</span> <span class="o">-&gt;</span> <span class="o">$</span><span class="x">(</span><span class="n">esc</span><span class="x">(</span><span class="n">g</span><span class="x">))(</span><span class="n">s</span><span class="x">)))</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then the fancier conjunction and disjunction are defined like so. I think conjunction does not need to be changed since <code class="language-plaintext highlighter-rouge">iterate</code> takes care of the trampoline. (Edit: No this is fundamentally busted insofar as it was intended to be a miniKanren style complete search. It is instead doing something closer to depth first. I might as well not even do the swapping. I suspect one cannot use flatten as is if one wants minikanren style search. )</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">disj</span><span class="x">(</span><span class="n">g1</span><span class="x">,</span><span class="n">g2</span><span class="x">)</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="k">begin</span>
     <span class="n">s1</span> <span class="o">=</span> <span class="n">g1</span><span class="x">(</span><span class="n">s</span><span class="x">)</span>
     <span class="n">s2</span> <span class="o">=</span> <span class="n">g2</span><span class="x">(</span><span class="n">s</span><span class="x">)</span>
     <span class="k">if</span> <span class="k">isa</span><span class="x">(</span><span class="n">s1</span><span class="x">,</span><span class="n">Thunk</span><span class="x">)</span>  <span class="o">&amp;&amp;</span> <span class="k">isa</span><span class="x">(</span><span class="n">s1</span><span class="o">.</span><span class="n">it</span><span class="x">,</span> <span class="kt">Function</span><span class="x">)</span> <span class="c">#s1.forced == false  </span>
        <span class="n">Iterators</span><span class="o">.</span><span class="n">flatten</span><span class="x">(</span>  <span class="x">(</span><span class="n">s2</span>  <span class="x">,</span> <span class="n">s1</span><span class="x">)</span> <span class="x">)</span>
     <span class="k">else</span>
        <span class="n">Iterators</span><span class="o">.</span><span class="n">flatten</span><span class="x">(</span>  <span class="x">(</span><span class="n">s1</span>  <span class="x">,</span> <span class="n">s2</span><span class="x">)</span> <span class="x">)</span>
     <span class="k">end</span>
<span class="k">end</span>

<span class="n">conj</span><span class="x">(</span><span class="n">g1</span><span class="x">,</span><span class="n">g2</span><span class="x">)</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Iterators</span><span class="o">.</span><span class="n">flatten</span><span class="x">(</span> <span class="n">map</span><span class="x">(</span> <span class="n">g2</span> <span class="x">,</span>  <span class="n">g1</span><span class="x">(</span><span class="n">s</span><span class="x">)</span> <span class="x">))</span> <span class="c"># eta expansion</span>
</code></pre></div></div>

<p>Nice operator forms of these expressions. Itâ€™s a bummer that operator precedence is not use definable. â‰… binds more weakly than âˆ§ and âˆ¨, which is not what you want.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="n">âˆ§</span> <span class="o">=</span> <span class="n">conj</span> <span class="c"># \wedge</span>
<span class="n">âˆ¨</span> <span class="o">=</span> <span class="n">disj</span> <span class="c"># \vee</span>
<span class="n">â‰…</span> <span class="o">=</span> <span class="n">eqwal</span> <span class="c">#\cong</span>
</code></pre></div></div>

<p>I skipped using the association list representation of substitutions (Although Assoc Lists are in Base). Iâ€™ve seen recommendations one just use persistent dictionaries and itâ€™s just as easy to drop that it. Iâ€™m just using a stock persistent dictionary from FunctionalCollections.jl <a href="https://github.com/JuliaCollections/FunctionalCollections.jl">https://github.com/JuliaCollections/FunctionalCollections.jl</a> .</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="k">using</span> <span class="n">FunctionalCollections</span>
<span class="k">function</span><span class="nf"> call_empty</span><span class="x">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int64</span><span class="x">,</span> <span class="n">c</span><span class="x">)</span> <span class="c"># gets back the iterator</span>
    <span class="n">collect</span><span class="x">(</span><span class="n">Iterators</span><span class="o">.</span><span class="n">take</span><span class="x">(</span><span class="n">c</span><span class="x">(</span> <span class="nd">@Persistent</span> <span class="kt">Dict</span><span class="x">()</span> <span class="x">),</span> <span class="n">n</span><span class="x">))</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> run</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">f</span><span class="x">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Var</span><span class="x">(</span><span class="n">gensym</span><span class="x">())</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">call_empty</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">f</span><span class="x">(</span><span class="n">q</span><span class="x">))</span>
    <span class="k">return</span> <span class="n">map</span><span class="x">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">walk_star</span><span class="x">(</span><span class="n">q</span><span class="x">,</span><span class="n">s</span><span class="x">),</span> <span class="n">res</span><span class="x">)</span>    
<span class="k">end</span>

<span class="c"># walk_star uses the substition to normalize an expression</span>
<span class="k">function</span><span class="nf"> walk_star</span><span class="x">(</span><span class="n">v</span><span class="x">,</span><span class="n">s</span><span class="x">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">walk</span><span class="x">(</span><span class="n">s</span><span class="x">,</span><span class="n">v</span><span class="x">)</span>
        <span class="k">if</span> <span class="k">isa</span><span class="x">(</span><span class="n">v</span><span class="x">,</span><span class="n">Var</span><span class="x">)</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="k">elseif</span> <span class="k">isa</span><span class="x">(</span><span class="n">v</span><span class="x">,</span><span class="kt">Expr</span><span class="x">)</span>
            <span class="nd">@assert</span> <span class="n">v</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="o">:</span><span class="n">call</span>
            <span class="k">return</span> <span class="kt">Expr</span><span class="x">(</span><span class="n">v</span><span class="o">.</span><span class="n">head</span> <span class="x">,</span><span class="n">vcat</span><span class="x">(</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">1</span><span class="x">],</span> 
                        <span class="n">map</span><span class="x">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">walk_star</span><span class="x">(</span><span class="n">v</span><span class="x">,</span><span class="n">s</span><span class="x">),</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="x">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="x">]))</span><span class="o">...</span><span class="x">)</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Hereâ€™s we define an append relation and an addition relation. They can be used in reverse and all sorts of funny ways!</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">function</span><span class="nf"> nat</span><span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="c"># helper to build peano numbers</span>
    <span class="n">s</span> <span class="o">=</span> <span class="o">:</span><span class="n">zero</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
        <span class="n">s</span> <span class="o">=</span> <span class="o">:</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="o">$</span><span class="n">s</span><span class="x">))</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">s</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> pluso</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="x">,</span><span class="n">z</span><span class="x">)</span>
      <span class="x">((</span> <span class="n">x</span> <span class="n">â‰…</span> <span class="o">:</span><span class="n">zero</span> <span class="x">)</span> <span class="n">âˆ§</span> <span class="x">(</span><span class="n">y</span> <span class="n">â‰…</span> <span class="n">z</span><span class="x">)</span> <span class="x">)</span> <span class="n">âˆ¨</span>
      <span class="n">fresh2</span><span class="x">(</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span><span class="n">m</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="x">(</span><span class="n">x</span> <span class="n">â‰…</span> <span class="o">:</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="o">$</span><span class="n">n</span><span class="x">)))</span> <span class="n">âˆ§</span> <span class="x">(</span><span class="n">z</span> <span class="n">â‰…</span> <span class="o">:</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="o">$</span><span class="n">m</span><span class="x">)))</span> <span class="n">âˆ§</span> <span class="nd">@Zzz</span><span class="x">(</span><span class="n">pluso</span><span class="x">(</span> <span class="n">n</span><span class="x">,</span> <span class="n">y</span><span class="x">,</span> <span class="n">m</span><span class="x">)))</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> appendo</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="x">,</span><span class="n">z</span><span class="x">)</span>
    <span class="x">(</span><span class="n">x</span> <span class="n">â‰…</span> <span class="o">:</span><span class="n">nil</span><span class="x">)</span> <span class="n">âˆ§</span> <span class="x">(</span><span class="n">y</span> <span class="n">â‰…</span> <span class="n">z</span><span class="x">)</span> <span class="n">âˆ¨</span>
    <span class="n">fresh3</span><span class="x">(</span> <span class="x">(</span><span class="n">hd</span><span class="x">,</span> <span class="n">xs</span> <span class="x">,</span><span class="n">zs</span><span class="x">)</span> <span class="o">-&gt;</span>  <span class="x">(</span><span class="n">x</span> <span class="n">â‰…</span> <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="o">$</span><span class="n">hd</span><span class="x">,</span><span class="o">$</span><span class="n">xs</span><span class="x">))</span> <span class="x">)</span>  <span class="n">âˆ§</span> <span class="x">(</span><span class="n">z</span> <span class="n">â‰…</span> <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="o">$</span><span class="n">hd</span><span class="x">,</span> <span class="o">$</span><span class="n">zs</span><span class="x">)))</span>  <span class="n">âˆ§</span> <span class="nd">@Zzz</span><span class="x">(</span> <span class="n">appendo</span><span class="x">(</span> <span class="n">xs</span><span class="x">,</span><span class="n">y</span><span class="x">,</span><span class="n">zs</span> <span class="x">)))</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here we actually run them and see results to queries.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># add 2 and 2. Only one answer</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">run</span><span class="x">(</span><span class="mi">5</span><span class="x">,</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">pluso</span><span class="x">(</span><span class="n">nat</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="n">nat</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="n">z</span><span class="x">))</span>
<span class="mi">1</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="x">{</span><span class="kt">Expr</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span><span class="o">:</span>
 <span class="o">:</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">)))))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">run</span><span class="x">(</span><span class="mi">5</span><span class="x">,</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">fresh2</span><span class="x">(</span> <span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="x">(</span><span class="n">z</span> <span class="n">â‰…</span> <span class="o">:</span><span class="x">(</span> <span class="n">tup</span><span class="x">(</span><span class="o">$</span><span class="n">x</span> <span class="x">,</span> <span class="o">$</span><span class="n">y</span><span class="x">)))</span> <span class="n">âˆ§</span> <span class="n">pluso</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="o">:</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">)),</span> <span class="n">y</span><span class="x">)))</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="x">{</span><span class="kt">Expr</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span><span class="o">:</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">zero</span><span class="x">,</span> <span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">)))</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">),</span> <span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">))))</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">)),</span> <span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">)))))</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">))),</span> <span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">))))))</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">)))),</span> <span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">succ</span><span class="x">(</span><span class="n">zero</span><span class="x">)))))))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">run</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">q</span> <span class="o">-&gt;</span>  <span class="n">appendo</span><span class="x">(</span>   <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span><span class="n">nil</span><span class="x">)),</span> <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span><span class="n">nil</span><span class="x">)),</span> <span class="n">q</span> <span class="x">)</span>  <span class="x">)</span>
<span class="mi">1</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="x">{</span><span class="kt">Expr</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span><span class="o">:</span>
 <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span> <span class="n">nil</span><span class="x">)))</span>

<span class="c"># subtractive append</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">run</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">q</span> <span class="o">-&gt;</span>  <span class="n">appendo</span><span class="x">(</span>   <span class="n">q</span><span class="x">,</span> <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span><span class="n">nil</span><span class="x">)),</span> <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span> <span class="n">nil</span><span class="x">)))</span> <span class="x">)</span>  <span class="x">)</span>
<span class="mi">1</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="x">{</span><span class="kt">Expr</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span><span class="o">:</span>
 <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">nil</span><span class="x">))</span>

<span class="c"># generate partitions</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">run</span><span class="x">(</span><span class="mi">10</span><span class="x">,</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">fresh2</span><span class="x">(</span> <span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="x">)</span> <span class="o">-&gt;</span>  <span class="x">(</span><span class="n">q</span> <span class="n">â‰…</span> <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="o">$</span><span class="n">x</span><span class="x">,</span><span class="o">$</span><span class="n">y</span><span class="x">)))</span> <span class="n">âˆ§</span> <span class="n">appendo</span><span class="x">(</span> <span class="n">x</span><span class="x">,</span> <span class="n">y</span><span class="x">,</span> <span class="o">:</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span><span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span><span class="n">nil</span><span class="x">)))</span>  <span class="x">)))</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="x">{</span><span class="kt">Expr</span><span class="x">,</span><span class="mi">1</span><span class="x">}</span><span class="o">:</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">nil</span><span class="x">,</span> <span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span> <span class="n">nil</span><span class="x">))))</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">nil</span><span class="x">),</span> <span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span> <span class="n">nil</span><span class="x">)))</span>
 <span class="o">:</span><span class="x">(</span><span class="n">tup</span><span class="x">(</span><span class="n">cons</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">cons</span><span class="x">(</span><span class="mi">4</span><span class="x">,</span> <span class="n">nil</span><span class="x">)),</span> <span class="n">nil</span><span class="x">))</span>

</code></pre></div></div>

<h3 id="thoughts--links">Thoughts &amp; Links</h3>

<p>I really should implement the occurs check</p>

<p>Other things that might be interesting: Using Async somehow for the streams. Store the substitutions with mutation or do union find unification. Constraint logic programming. How hard would it be get get JuMP to tag along for the ride?</p>

<p>It would probably be nice to accept Expr for tuples and arrays in addition to function calls.</p>

<p><a href="http://minikanren.org/">http://minikanren.org/</a> You may also want to check out the book The Reasoned Schemer.</p>

<p><a href="http://io.livecode.ch/">http://io.livecode.ch/</a> online interactive minikanren examples</p>

<p><a href="http://tca.github.io/veneer/examples/editor.html">http://tca.github.io/veneer/examples/editor.html</a> more minikanren examples.</p>

<p>Microkanren implementation tutorial <a href="https://www.youtube.com/watch?v=0FwIwewHC3o">https://www.youtube.com/watch?v=0FwIwewHC3o</a> . Also checkout the Kanren online meetup recordings <a href="https://www.youtube.com/user/WilliamEByrd/playlists">https://www.youtube.com/user/WilliamEByrd/playlists</a></p>

<p>Efficient representations for triangular substitutions - <a href="https://users.soe.ucsc.edu/~lkuper/papers/walk.pdf">https://users.soe.ucsc.edu/~lkuper/papers/walk.pdf</a></p>

<p><a href="https://github.com/ekmett/guanxi">https://github.com/ekmett/guanxi</a> <a href="https://www.youtube.com/watch?v=D7rlJWc3474&amp;ab_channel=MonadicWarsaw">https://www.youtube.com/watch?v=D7rlJWc3474&amp;ab_channel=MonadicWarsaw</a></p>

<p>Could it be fruitful to work natively with Catlabâ€™s GATExpr? Synquid makes it seem like extra typing information can help the search sometimes.</p>

<p>LogicT <a href="http://okmij.org/ftp/Computation/LogicT.pdf">http://okmij.org/ftp/Computation/LogicT.pdf</a></p>

<p>Seres Spivey <a href="http://www.jucs.org/jucs_6_4/functional_reading_of_logic">http://www.jucs.org/jucs_6_4/functional_reading_of_logic</a></p>

<p>Hinze backtracking <a href="https://dl.acm.org/doi/abs/10.1145/357766.351258">https://dl.acm.org/doi/abs/10.1145/357766.351258</a></p>

:ET