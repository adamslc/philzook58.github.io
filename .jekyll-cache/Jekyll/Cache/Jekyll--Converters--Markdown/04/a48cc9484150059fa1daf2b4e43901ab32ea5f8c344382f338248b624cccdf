I"ž-<p>Thatâ€™s a mouthful.</p>

<p>Lens are described as<a href="http://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html"> functional getters and setters</a>. The simple lens type is ``</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;type Lens a b = a -&gt; (b, b -&gt; a)&lt;/code&gt;
</code></pre></div></div>

<p>. The setter is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;a-&gt;b&lt;/code&gt;
</code></pre></div></div>

<p>and the getter is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;a -&gt; b -&gt; a&lt;/code&gt;
</code></pre></div></div>

<p>This type does not constrain lenses to obey the usual laws of getters and setters. So we can use/abuse lens structures for nontrivial computations that have forward and backwards passes that share information. <a href="https://julesh.com/">Jules Hedges</a> is particular seems to be a proponent for this idea.</p>

<p>Iâ€™ve described before how to <a href="http://www.philipzucker.com/reverse-mode-differentiation-is-kind-of-like-a-lens-ii/">encode reverse mode automatic differentiation</a> in this style. I have suspicions that you can make iterative LQR and guass-seidel iteration have this flavor too, but Iâ€™m not super sure. My attempts ended somewhat <a href="https://github.com/philzook58/ConvexCat/blob/master/src/Lib.hs">unsatisfactorily</a> a whiles back but I think itâ€™s not hopeless. The trouble was that you usually want the whole vector back, not just its ends.</p>

<p>Iâ€™ve got another example in imperative program analysis that kind of makes sense and might be useful though. Toy repo here: <a href="https://github.com/philzook58/wp-lens">https://github.com/philzook58/wp-lens</a></p>

<p>In program analysis it sometimes helps to run a program both concretely and symbolically. <a href="https://en.wikipedia.org/wiki/Concolic_testing">Concolic</a> = CONCrete / symbOLIC. Symbolic stuff can slowly find hard things and concrete execution just sprays super fast and can find the dumb things really quick.</p>

<p>We can use a lens structure to organize a DSL for describing a simple imperative language</p>

<p>The forward pass is for the concrete execution. The backward pass is for transforming the post condition to a pre condition in a <a href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics">weakest precondition analysis</a>. Weakest precondition semantics is a way of specifying what is occurring in an imperative language. It tells how each statement transforms post conditions (predicates about the state after the execution) into pre conditions (predicates about before the execution). The concrete execution helps unroll loops and avoid branching if-then-else behavior that would make the symbolic stuff harder to process. Iâ€™ve been flipping through <a href="https://seriouscomputerist.atariverse.com/media/pdf/book/Discipline%20of%20Programming.pdf">Djikstraâ€™s book </a>on this. Interesting stuff, interesting man.</p>

<p>I often think of a state machine as a function taking s -&gt; s. However, this is kind of restrictive. It is possible to have heterogenous transformations s -&gt; sâ€™. Why not? I think I am often thinking about finite state machines, which we really donâ€™t intend to have a changing state size. Perhaps we allocated new memory or something or brought something into or out of scope. We could model this by assuming the memory was always there, but it seems wasteful and perhaps confusing. We need to a priori know everything we will need, which seems like it might break compositionally.</p>

<p>We could <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Imp.html">model our language</a> making some data type like<br />
<code class="language-plaintext highlighter-rouge">data Imp = Skip | Print String | Assign String Expr | Seq Imp Imp | ...</code><br />
and then build an interpreter</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;interp :: Imp -&gt; s -&gt; s'&lt;/code&gt;
</code></pre></div></div>

<p><img src="http://philzucker2.nfshost.com/wp-content/uploads/2019/10/Imp-01.jpg" alt="" />Imp.</p>

<p>But we can also cut out the middle man and directly define our language using combinators.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;type Stmt s s' = s -&gt;s'&lt;/code&gt;
</code></pre></div></div>

<p>To me this has some flavor of a finally tagless style.</p>

<p>Likewise for expressions. Expressions evaluate to something in the context of the state (they can lookup variables), so letâ€™s just use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;type Expr s a = s -&gt; a&lt;/code&gt;
</code></pre></div></div>

<p>And, confusingly (sorry), I think it makes sense to use Lens in their original getter/setter intent for variables. So Lens structure is playing double duty.</p>

<p><code class="language-plaintext highlighter-rouge">type Var s a = Lens' s a</code></p>

<p>With that said, here we go.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;
type Stmt s s' = s -&gt; s' 
type Lens' a b = a -&gt; (b, b -&gt; a)
set l s a = let (_, f) = l s in f a

type Expr s a = s -&gt; a
type Var s a = Lens' s a

skip :: Stmt s s
skip = id

sequence :: Stmt s s' -&gt; Stmt s' s'' -&gt; Stmt s s''
sequence = flip (.)

assign :: Var s a -&gt; Expr s a -&gt; Stmt s s
assign v e = \s -&gt; set v s (e s)

(===) :: Var s a -&gt; Expr s a -&gt; Stmt s s
v === e = assign v e

ite :: Expr s Bool -&gt; Stmt s s' -&gt; Stmt s s' -&gt; Stmt s s'
ite e stmt1 stmt2 = \s -&gt; if (e s) then stmt1 s else stmt2 s

while :: Expr s Bool -&gt; Stmt s s -&gt; Stmt s s
while e stmt = \s -&gt; if (e s) then ((while e stmt) (stmt s)) else s

assert :: Expr s Bool -&gt; Stmt s s  
assert e = \s -&gt; if (e s) then s else undefined 

abort :: Stmt s s'  
abort = const undefined
&lt;/code&gt;
</code></pre></div></div>

<p>Weakest precondition can be done similarly, instead we start from the end and work backwards</p>

<p>Predicates are roughly sets. A simple type for sets is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;type Pred s = s -&gt; Bool&lt;/code&gt; 
</code></pre></div></div>

<p>Now, this doesnâ€™t have much deductive power, but I think it demonstrates the principles simply. We could replace <code class="language-plaintext highlighter-rouge">Pred</code> with perhaps an SMT solver expression, or some data type for predicates, for which weâ€™ll need to implement things like substitution. Letâ€™s not today.</p>

<p>A function</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;a -&gt; b&lt;/code&gt; 
</code></pre></div></div>

<p>is equivalent to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;forall c. (b -&gt; c) -&gt; (a -&gt; c)&lt;/code&gt;
</code></pre></div></div>

<p>. This is some kind of CPS / Yoneda transformation thing. A state transformer</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;s -&gt; s'&lt;/code&gt;
</code></pre></div></div>

<p>to predicate transformer</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;(s' -&gt; Bool) -&gt; (s -&gt; Bool)&lt;/code&gt;
</code></pre></div></div>

<p>is somewhat evocative of that. Iâ€™m not being very precise here at all.</p>

<p>Without further ado, hereâ€™s how I think a weakest precondition looks roughly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;
type Lens' a b = a -&gt; (b, b -&gt; a)
set l s a = let (_, f) = l s in f a

type Expr s a = s -&gt; a
type Var s a = Lens' s a
type Pred s = s -&gt; Bool
type Stmt s s' = Pred s' -&gt; Pred s 

skip :: Stmt s s
skip = \post -&gt; let pre = post in pre -- if

sequence :: Stmt s s' -&gt; Stmt s' s'' -&gt; Stmt s s''
sequence = (.)

assign :: Var s a -&gt; Expr s a -&gt; Stmt s s
assign v e = \post -&gt; let pre s = post (set v s (e s)) in pre

(===) :: Var s a -&gt; Expr s a -&gt; Stmt s s
v === e = assign v e

ite :: Expr s Bool -&gt; Stmt s s' -&gt; Stmt s s' -&gt; Stmt s s'
ite e stmt1 stmt2 = \post -&gt; let pre s = if (e s) then (stmt1 post) s else (stmt2 post) s in pre

abort :: Stmt s s'  
abort = \post -&gt; const False

assert :: Expr s Bool -&gt; Stmt s s  
assert e = \post -&gt; let pre s = (e s) &amp;&amp; (post s) in pre

{-
-- tougher. Needs loop invariant
while :: Expr s Bool -&gt; Stmt s s -&gt; Stmt s s
while e stmt = \post -&gt; let pre s = if (e s) then ((while e stmt) (stmt post)) s else  in pre
-}

&lt;/code&gt;
</code></pre></div></div>

<p>Finally here is a combination of the two above that uses the branching structure of the concrete execution to aid construction of the precondition. Although I havenâ€™t expanded it out, we are using the full <code class="language-plaintext highlighter-rouge">s t a b</code> parametrization of lens in the sense that states go forward and predicates come back.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;code&gt;
type Lens' a b = a -&gt; (b, b -&gt; a)
set l s a = let (_, f) = l s in f a


type Expr s a = s -&gt; a
type Var s a = Lens' s a
type Pred a = a -&gt; Bool
type Stmt s s' = s -&gt; (s', Pred s' -&gt; Pred s) -- eh. Screw the newtype

skip :: Stmt s s
skip = \x -&gt; (x, id)


sequence :: Stmt s s' -&gt; Stmt s' s'' -&gt; Stmt s s''
sequence f g =   \s -&gt; let (s', j) = f s in
                       let (s'', j') = g s' in
                           (s'', j . j')
assign :: Var s a -&gt; Expr s a -&gt; Stmt s s
assign v e = \s -&gt; (set v s (e s), \p -&gt; \s -&gt; p (set v s (e s)))

--if then else
ite :: Expr s Bool -&gt; Stmt s s' -&gt; Stmt s s' -&gt; Stmt s s'
ite e stmt1 stmt2 = \s -&gt; 
                    if (e s) 
                    then let (s', wp) = stmt1 s in
                         (s', \post -&gt; \s -&gt; (e s) &amp;&amp; (wp post s))
                    else let (s', wp) = stmt2 s in
                            (s', \post -&gt; \s -&gt; (not (e s)) &amp;&amp; (wp post s))

assert :: Pred s -&gt; Stmt s s
assert p = \s -&gt; (s, \post -&gt; let pre s = (post s) &amp;&amp; (p s) in pre)

while :: Expr s Bool -&gt; Stmt s s -&gt; Stmt s s
while e stmt = \s -&gt; if e s then let (s' , wp) = (while e stmt) s in
                                 (s', \post -&gt; let pre s'' = (post s'') &amp;&amp; (wp post s'') in pre)   
                            else (s, \p -&gt; p)

{-

-- declare and forget can change the size and shape of the state space.
-- These are heterogenous state commpands
declare :: Iso (s,Int) s' -&gt; Int -&gt; Stmt s s'   
declare iso defalt = (\s -&gt; to iso (s, defalt), \p -&gt; \s -&gt; p $ to iso (s, defalt)) 

forget :: Lens' s s' -&gt; Stmt s s' -- forgets a chunk of state

declare_bracket :: Iso (s,Int) s' -&gt; Int -&gt;  Stmt s' s' -&gt; Stmt s s
declare_bracket iso defalt stmt = (declare iso default) . stmt . (forget (_1 . iso))
&lt;/code&gt;
</code></pre></div></div>

<p>Neat. Useful? Me dunno.</p>

:ET