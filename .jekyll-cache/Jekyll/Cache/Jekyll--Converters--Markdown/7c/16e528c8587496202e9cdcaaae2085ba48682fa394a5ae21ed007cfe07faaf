I"‘R<p>Me and my close friends have been interested in starting a project together and I suggested we use Haskell. I do not think the suggestion was received well or perhaps in seriousness. I have a tendency to joke about almost everything and have put forward that we use many interesting but not practical languages in the same tone that I suggest Haskell. This was a tactical mistake. I find myself in despair at the idea I can‚Äôt convince my personal friends, who are curious and intellectual people, to use Haskell on a fresh start web project we have complete control over. What hope do I have in the world at large? This brain dump post is meant for them. My suggestion to use Haskell is not _just _me being an asshole, although that does make it more fun for me. I will now try to explain in all seriousness and in all the honesty that I can muster what my opinions on languages are and why I have them.</p>

<p>Pragmatically can you start a new project using a language you don‚Äôt know? This is a problem. A project always has some intrinsic difficulty. Not all projects will survive an extra layer of unnecessary speedbump. But when and how are you supposed to learn new languages? Never is one answer. I disagree with this answer. In this case we have the leg up that I do know Haskell. Perhaps this is a downside in that it will be extra frustrating? It is also easy for me to ask, as using Haskell is not a burden for me, I have already sunk the cost, but a massive learning burden for others.</p>

<p>Is Haskell actually practical for a web application? Short answer: yes. Expect pain though. If your web application is so simple you could rip it out in 100 lines of python, this is such a simple project that it is a good opportunity to learn something new. If it will become large and complex, then I believe Haskell does shine, keeping complexity under control. I base this upon the professional experience making a web application using a Haskell-Purescript stack. For honesty, it wasn‚Äôt all good. I recall ripping my hair out threading shit through monad stacks to where it need to go. Yet on the whole, it kept the project sane. I also believe this based on the word of mouth that I believe but could be just cultish ramblings.</p>

<p>I believe that truly dominating properties of Haskell appear in large complex projects. This is difficult to prove in any other way except empirically and the experiments will be so wildly uncontrolled in terms of the project and people involved that no conclusions can truly be drawn. And yet I have faith, and think that personal experience validates this opinion to myself at least. We have to live this life even though truth does not exist. Choices and opinions must be made.</p>

<p>For programs that are going to be a single manageable file and written in one night, it doesn‚Äôt matter much what you use in terms of being choked on your own code. At this scale, I still think Haskell is enjoyable and interesting though. Haskell was my doorway into the world of computer science as I now understand it. I hope there are more doorways.</p>

<p>Things about me that may be different from you. Decide for yourself if these aspects of me make our opinions fundamentally incompatible.</p>

<ul>
  <li>I do have a talent and a like for practically oriented mathematical topics (computational methods, linear algebra, formal methods, calculus, geometric algebra, projective geometry, optimization, etc.). I actually have very little taste at all for mathematical topics that I see no purpose to.</li>
  <li>I do have some desire and taste for esoterica for its own purpose. I cannot exactly characterize what makes some topics acceptable to me and others not.</li>
  <li>A hard learning curve is not necessarily a downside for me. I enjoy the challenge if it is overcomable and worth it on the other side.</li>
  <li>I like weird and different. That is a positive for me, but a negative for many. I might just be a millennial hipster idiot.</li>
  <li>I would LOVE to find a language I think is better than Haskell. I would LOVE to abandon Haskell. Perhaps this already makes me odd. Perhaps  I think many people don‚Äôt consider the differences between languages to be worth making the switch and the wasted knowledge. The people with this opinion may or may not have tried enough languages.</li>
  <li>I have ‚Äúdrank the koolaid‚Äù. I do read what comes out of the Haskell and functional programming community and have a tendency to believe things without strong empirical backing.</li>
  <li>I have been more deeply entwined with Haskell than any other language. Perhaps if I had reached a level of familiarity in another language I‚Äôd be as fervent about that one? I don‚Äôt believe this is the case.</li>
  <li>While I desire performance, I consciously curb this desire. I am strongly in favor of cleanly written, clear, principled code. This is of course a weighted judgement. I will probably use a 100x performance gain for a 2x decrease in clarity or reusability. This is a result of the problem domains and scale that have interested me in the past and that I anticipate in the future. I STRONGLY believe the world at large over values performance at the expense of other good qualities of code. Or at least over optimizes early.</li>
</ul>

<h3 id="a-biased-list-of-pros-and-cons">A Biased List of Pros and Cons</h3>

<p>What do I find bad about C++.</p>

<ul>
  <li>The feature set is huge and difficult to understand</li>
  <li>Extreme amounts of legacy features that will be even recommended if you read legacy documentation. Kitchen sink.</li>
  <li>The language appears to be almost entirely built out of footguns.</li>
  <li>The syntax is too verbose.</li>
  <li>I have a distaste for mutation.</li>
  <li>I have a distaste for object oriented programming</li>
</ul>

<p>What do I find good about C++</p>

<ul>
  <li>It is commonly used. Large community.</li>
  <li>It is possible for it to be very fast</li>
  <li>Kitchen Sink. You can find almost any feature you want here.</li>
  <li>The high level goals of the mind-leaders sound good.</li>
  <li>Very interesting projects are written in C++. HPC things. Scientific computation.</li>
  <li>Template metaprogramming seems very powerful, but arcane.</li>
</ul>

<p>What I find bad about Java</p>

<ul>
  <li>The syntax puts me off as being incredibly verbose</li>
  <li>Extreme object oriented focus</li>
  <li>Corporate/Enterprise feel. I am an iconoclast and see myself as a reasonable but slightly rebellious character. Java in my mind brings images of cubicles and white walls. Perhaps this is not fair.</li>
</ul>

<p>What do I find good about Java</p>

<ul>
  <li>?</li>
</ul>

<p>I‚Äôm joking. Sorry Java. But I also kind of mean it. Yes, there are positive aspects to Java.</p>

<p>What I like about python</p>

<ul>
  <li>Very commonly used and understood. Perhaps the lingua franca</li>
  <li>Incredible library ecosystem</li>
  <li>Numpy and scipy in particular are marvels of the modern age.</li>
  <li>Syntax is basically imperative pseudo-code</li>
  <li>I am personally very familiar with it</li>
  <li>python is the easiest to use language I know.</li>
</ul>

<p>What I dislike about python</p>

<ul>
  <li>Python has no natural tendency for correctness due to the free wheeling dynamically typed character. This is patched up with testing, opt-in type systems.</li>
  <li>I don‚Äôt know how to grow as a pythonista. The skill curve flattens out. For some this may be a positive.</li>
  <li>The main way of building new data types is the class system. I think this is ungainly, overly verbose, and not always a good conceptual fit.</li>
  <li>Despite being among the most succinct of common imperative languages, I still think it ends up being too verbose.</li>
  <li>It is slow. This is a negative, although not high on my priorities.</li>
</ul>

<p>What is bad about Haskell</p>

<ul>
  <li>Very difficult learning curve. Let‚Äôs get real. Haskell is a very confusing programming language to get started in for common programming tasks.</li>
  <li>functional programming is weirder than imperative programming.</li>
  <li>The monad paradigm, even once learned is ungainly. Tracking multiple effects is a pain that does not exist in most languages.</li>
  <li>The pain is up front. It is easy to get a sketch of what you want ripped out in python faster than in Haskell (for me). If you want a web server, command line tool, optimization problem, curve fitter, I can rip all of these out faster in python than I can in Haskell.  As a psychological thing, this feels awful. For a small scale project, unless toying with Haskell itself or one of its domain expertises like implementing DSLs, python is the easier and correct choice. Python is a scripting language. I‚Äôd make the switch at two screens worth of code.</li>
  <li>I think laziness is confusing and easy to shoot yourself with.</li>
  <li>Haskell is not the fastest language, although faster than python.</li>
  <li>Concern for there not being jobs and interestingly on the converse side, no people to hire. There is a catch-22 there. There is a set of people that would KILL for a Haskell job.</li>
  <li>There are vocal smug assholes who use Haskell and push it. I am smug, I hope only mildly an asshole.</li>
</ul>

<p>What I find good about Haskell</p>

<ul>
  <li>The number one reason is that there is something ephemeral that I just like. I am not naturally inclined to analyze such things. When I like a movie or don‚Äôt like it, it just happens, and if forced to explain why, I‚Äôll bullshit.</li>
  <li>Errors and bugs are to a shocking degree caught at compile time. More than any other language I have experience with does Haskell code run correctly without hidden bugs if it compiles. I am not claiming this is absolute but it is all the more incredible the degree to which it is true since it didn‚Äôt literally have to be this way. I have done major rewiring of a data structure in a project. The compiler guided my hand to exactly the positions that needed to be adjusted. Could C++ do this? Yes, to some degree. I believe that the tendencies of C++ programming make it less satisfactory on this point.</li>
  <li>Types are an incredible design tool. I find designing the types of my program to be an extremely enjoyable and helpful activity. Much more so than box and wire class and interface diagrams. A good function name and a type signature basically entirely constrains the behavior of a function. Types can be quickly and completely be given to the compiler and machine enforced.</li>
  <li>The pain that Monads cause are pains you should be feeling. They are the pain of explicitness which I 70% choose over the pain of not knowing what the fuck a function might do, and not enabling the compiler to enforce that. If something is capable of mutating state, it should say so in goddamn huge purple letters.</li>
  <li>Haskell is more than fast enough. It isn‚Äôt that even people don‚Äôt care. The Haskell community at large cares a lot more for performance than I do, and I reap the dividends. The people in charge of the compiler and the main libraries are goddamn wizards who‚Äôs work I get to benefit from. This is true of all languages perhaps.</li>
  <li>Laziness is very cool. At the beginning I thought it was INCREDIBLY awesome and inconceivable that I could manipulate an infinite list.</li>
  <li>The way of specifying new data types is so succinct and so incredible. Pattern matching is SO GODDAMN good for some tasks.</li>
  <li>Haskell has a paradigm of small combinators. It is common to build a sequence of very small natural functions for the domain and then build larger and larger things out of them. This is good for reusability and conceptual clearness.</li>
  <li>Extreme preference for Immutability. As part of keeping what you must keep in your head or remember small while programming, immutability is an insane win. You think you know what you want now. You know you could just tweak this variable here, make a special variable over here. You can reason about how to make this all work and be correct now. You will not in a month. Your coworkers will mess it all up too.</li>
  <li>Haskell code is generic by default. This allows the same code to be reused in many situations</li>
  <li>The standard typeclass hierarchy is extremely well thought out and powerful. To some degree it is unnecessary in other languages. The difference between Functor, Applicative, Monad, and Traversable makes little sense in languages with unconstrained mutations and effects.</li>
  <li>Haskell paradigms are inspired by mathematics, and I have great faith in mathematics. The concepts behind Haskell feel closer to discoveries rather than inventions. Imperative programming speaks in a language formed for the accidental nature of the machines we have. Functional programming is a language closer to mathematics, which I believe is closer to how the human mind works, and closer to what the problem at hand actually is.</li>
  <li>Complexity scales. It is my belief, perhaps unverified, that as a project grows larger, the insane miserable churn and mental overhead grows slower in a Haskell project than in other languages. I do not have strong empirical evidence to this assertion. Word of mouth (of Haskellers).</li>
  <li>The ceiling on Haskell is extremely high. You can continue to learn and get better, gaining more and more power. I do not currently see the end of this.</li>
  <li>When I do reach for some new library, I am very often impressed by how thoughtfully built it is. Haskell itself is INCREDIBLY thoughtfully built.</li>
  <li>The haskell community is very excited and they have many things to teach. There are many Haskellers out there who are very welcoming, kind, and intelligent.</li>
  <li>Haskell does have some cache. I am not immune to wanting to seem smart. If the world thought that only idiots use Haskell, that would offput me some. That the world things that only impractical ivory tower smug weenies use Haskell does offput me, although I perhaps embrace it belligerently.</li>
  <li>The Haskell library ecosystem is strong. Less strong than python, but much better than some of the other languages that intrigue my eye. There is functionality somewhere for most common tasks.</li>
  <li>Haskell is used industrially. I live in an echo chamber, but by and large the industrial users of Haskell sing its praises.</li>
</ul>

<p>For context, this is my programming journey:</p>

<p>I first learned BASIC in middle school. I wrote a computer game in Visual Basic. I toyed with the TI-83. I went to a summer camp in high school where I learned the extreme rudiments of C++. Did a small web business with some friends. Did really bad work with big dreams. I took a fairly poor Java course in high school. I learned MATLAB in college.  I doinked around with Arduino level C projects. I learned python in grad school I think. I think I got far more proficient at python than any other language before. At this point, I was on board for object oriented programming, albeit not at a deep level (design patterns or ilk), just as light organizational principle. Did some Android projects, really didn‚Äôt like Java there.  Did a small business with my friend and got deep in Javascript. As our web application got bigger, this really start to hurt. Errors all over the place. Unknown junk in objects. Who has access to what? We tried our darndest to read and follow best practices as we could find them, but it felt like we sinking in quicksand. More and more effort for more and more bugs and less and less progress. It was around this era that I first even heard of Haskell. I was intrigued immediately for some reason, maybe for just how weird it was. It took probably 2 years of forgetting about it and going back to tutorials every 6 months. I didn‚Äôt necessarily KNOW that this was a thing that I wanted, I just found it interesting. Currently I am fairly proficient at some things in Haskell (unfortunately I am more proficient at esoterica than more practical things). I have had a professional job writing Haskell, and it seems like my like of Haskell is working out very well for me professionally. Passion in all forms is powerful.</p>

<p>My history may not be as convincing as someone who spent 20 years as a professional C++ dev and then switched, but I have at least experienced different paradigms and languages and found Haskell the most to my liking.</p>

<h3 id="random-thoughts">Random Thoughts</h3>

<p>I am now trying to push myself into comfort in Julia, Rust, Agda, Coq, OCaml, all languages I feel show promise for different reasons. To my knowledge Haskell is a better choice than these as a general purpose tool for pragmatic reasons. Haskell‚Äôs library ecosystem is strong and performance is good. These are points against agda and coq. Julia has a focus on scientific programming.</p>

<p>Rust might be a good compromise. I consider it a trojan horse for useful programming language features that I associate with functional languages. It claims to performance and being an acceptable systems level language, which appeals to some. The syntax does not scare anyone off. The library ecosystem seems good and the community strong. I did find myself missing Haskell features in Rust though, am personally much less familiar with it. I think the design of Rust weights more to performance than is warranted in most applications and has less descriptive and abstraction power than Haskell, qualities that I prioritize. This opinion is not strongly held.</p>

<p>What makes Haskells types any better or worse than C? At the beginning many of the features of Haskell seem like magic. But as time has worn on, I can see how the features can be emulated with just some slight syntactic and conceptual overhead in other languages. This slight overhead is enough though.  A language is more than just it‚Äôs syntax. It is also its idioms. It is also they way it makes people think. Language is almost a prerequisite for thought. You cannot even conceive of the ways there are to express yourself before learning.</p>

<p>What exactly makes a language ‚Äúgood‚Äù? This is a question poorly phrased enough to have no answer. Excel can be an excellent language for many tasks. Easy to learn. Very powerful. Yet, it is not considered a good general purpose programming language. Library ecosystem is extremely important. Specialized languages are often the best choice for special problem domains, at the expense of learning them, or eventually finding incompatibility of what you want from what they designed for.</p>

<p>What makes abstractions ‚Äúgood‚Äù. Why do I have queasiness about object oriented-programmming. Java, I think basically. I, overeagerly have gone down the road of trying to design deep subclass hierarchies, which is not OO at it‚Äôs best. Zebra is a Quadruped is an Animal is Alive kind of stuff. I believe object oriented in an interesting principle. I hear about SmallTalk and Common Lisp doing object oriented right and I am duly intrigued. There has been some recent work in Haskell about how to do objects in a way aesthetically compatible with Haskell. I think object oriented has been over used and abused. I think it is a poor conceptual fit for many situations. I think it tends to make non reusable code. I think the form that it takes in C++ and Java development is arcane horseshit.</p>

<p>I deserve almost no opinion about Java or C++, having not done sufficient that much in them. Yet, I must state my opinions, take them as you will, for I do in fact hold them strongly. I have worked on a network simulator and a robotics framework in C++, but begrudgingly. I have done a very small amount of Java development for a personal project and some Processing sketches. My coworker was a 10 year professional Java dev before switching to Scala then Haskell. He despises Java now. Highly anecdotal, and he is a similar iconoclastic character like me. Nevertheless, this also informs my opinion. I have been reading Bjarne Stroustrup‚Äôs book (his stated goals and what he claims C++ achieves are admirable and one can‚Äôt argue he hasn‚Äôt changed the world) and actually find C++ rather interesting, especially in the sense that many projects that I find interesting are written in C++, I just don‚Äôt want to myself work in the language.</p>

<p>Haskell love:</p>

<p>https://www.reddit.com/r/haskell/comments/6snhth/what_is_great_about_haskell/</p>

<p>https://www.reddit.com/r/haskell/comments/6segl8/why_should_anyone_use_haskell/</p>

<p>Haskell Criticism (perhaps warranted)</p>

<p><a href="https://news.ycombinator.com/item?id=17114308">https://news.ycombinator.com/item?id=17114308</a> Ah Hacker News. Always a sunny worldview.</p>

<p><a href="https://medium.com/@snoyjerk/least-favorite-thing-about-haskal-ef8f80f30733">https://medium.com/@snoyjerk/least-favorite-thing-about-haskal-ef8f80f30733</a></p>

<p>Hacker news discussion of this post:</p>

<p><a href="https://news.ycombinator.com/item?id=20258218#20271511">https://news.ycombinator.com/item?id=20258218#20271511</a></p>

:ET