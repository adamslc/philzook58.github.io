I"’A<p>Yesterday morning, I was struck with awe at how amazingly cool the dependently typed approach (Agda, Idris, Coq) to proving programs is. It is great that I can still feel that after tinkering around with it for a couple years. It could feel old hat.</p>

<p>In celebration of that emotion, I decided to write a little introductory blog post about how to do some proving like that in Haskell. Haskell can replicate this ability to prove with varying amounts of pain. For the record, there isn‚Äôt anything novel in what follows.</p>

<p>One methodology for replicating the feel of dependent types is to use the singletons pattern. The singleton pattern is a way of building a data type so that there is an exact copy of the value of a variable in its type.</p>

<p>For future reference, I have on the following extensions, some of which I‚Äôll mention when they come up.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
{-# LANGUAGE GADTs, DataKinds, TypeFamilies, RankNTypes, UndecidableInstances, PolyKinds #-}
</code></pre></div></div>

<p>Here‚Äôs how the pattern goes.</p>

<p>Step 1: define your ordinary data type. <code class="language-plaintext highlighter-rouge">Bool</code> is already defined in the Prelude, but here is what it looks like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
data Bool = True | False
</code></pre></div></div>

<p>Step 2: turn on the DataKinds extension. This automatically promotes any data type constructor like <code class="language-plaintext highlighter-rouge">True</code> or <code class="language-plaintext highlighter-rouge">False</code> or <code class="language-plaintext highlighter-rouge">Just</code> into types that have apostrophes in front of them <code class="language-plaintext highlighter-rouge">'True</code>, <code class="language-plaintext highlighter-rouge">'False</code>, <code class="language-plaintext highlighter-rouge">'Just</code>. This is mostly a convenience. You could have manually defined something similar like so</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
data True
data False
data Just a
</code></pre></div></div>

<p>Step 3: Define your singleton datatype. The singleton datatype is a GADT (generalized abstract data type). GADT declarations take on a new syntax. It helps to realize that ordinary type constructors like <code class="language-plaintext highlighter-rouge">Just</code> are just functions. You can use them anywhere you can use functions.  <code class="language-plaintext highlighter-rouge">Just</code> has the type <code class="language-plaintext highlighter-rouge">a -&gt; Maybe a</code>. It might help to show that you can define a lower case synonym.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
just :: a -&gt; Maybe a
just = Just
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">just</code> is clearly just a regular function. What makes constructors a special thing (not quite ‚Äújust functions‚Äù) is that you can also pattern match on them. Data constructors are functions that ‚Äúdo nothing‚Äù. They hold the data until eventually you get it back again via pattern matching.</p>

<p>So why don‚Äôt you write the type signature of the constructors when you define them? Why does using a data statement look so different than a function definition? The GADT syntax brings the two concepts visually closer.</p>

<p>Letting you define the type signature for the constructor let‚Äôs you define a constrained type signature, rather than the inferred most general one. It‚Äôs similar to the following situation. If you define an identity function <code class="language-plaintext highlighter-rouge">id</code>, it has the polymorphic type <code class="language-plaintext highlighter-rouge">a -&gt; a</code>. However, you can explicitly constrain the function with an identical implementation. If you try to use <code class="language-plaintext highlighter-rouge">boolid</code> on an <code class="language-plaintext highlighter-rouge">Int</code> it is a type error.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
id x = x

boolid :: Bool -&gt; Bool
boolid x = x
</code></pre></div></div>

<p>The GADT syntax let‚Äôs you constrain what the type signature of the constructor is, but also very interestingly, let‚Äôs the type checker infer information when you pattern match into the GADT.</p>

<p>With all that spiel, here is the singleton type for <code class="language-plaintext highlighter-rouge">Bool</code> as a  GADT.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
data SBool s where
   STrue :: SBool 'True
   SFalse :: SBool 'False
</code></pre></div></div>

<p>You have made an exact copy of the value at the type level. When you pattern match into a variable <code class="language-plaintext highlighter-rouge">x</code> of type <code class="language-plaintext highlighter-rouge">SBool s</code> in the <code class="language-plaintext highlighter-rouge">STrue</code> branch, it knows that <code class="language-plaintext highlighter-rouge">s ~ 'True</code> and in the <code class="language-plaintext highlighter-rouge">SFalse</code> branch it knows that <code class="language-plaintext highlighter-rouge">s ~ 'False</code>.</p>

<p>Here‚Äôs the analogous construction for a Peano natural number</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
data Nat = Zero | Succ Nat

data SNat s where
    SZero :: SNat 'Zero
    SSucc :: SNat n -&gt; SNat ('Succ n)
</code></pre></div></div>

<p>Now let‚Äôs talk about programming.</p>

<p>Addition is straightforward to define for our <code class="language-plaintext highlighter-rouge">Nat</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
nplus :: Nat -&gt; Nat -&gt; Nat
nplus Zero x = x
nplus (Succ x) y = Succ (nplus x y)
</code></pre></div></div>

<p>Let‚Äôs replicate this definition at the type level. The extension we‚Äôll want is <code class="language-plaintext highlighter-rouge">TypeFamilies</code>. Type families enables a syntax and feature for defining functions on types very similarly to how you define regular functions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
type family NPlus x y where
    NPlus 'Zero x = x
    NPlus ('Succ x) y = 'Succ (NPlus x y)
</code></pre></div></div>

<p>Now finally, we can exactly mirror this definition on singletons</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
snplus :: SNat n -&gt; SNat n' -&gt; SNat (NPlus n n')
snplus SZero x = x
snplus (SSucc x) y = SSucc (snplus x y) 
</code></pre></div></div>

<p>In the type signature <code class="language-plaintext highlighter-rouge">SNat</code> is kind of like a weirdo <code class="language-plaintext highlighter-rouge">forall</code>. It is a binding form that generates a new type variable you need to express the typelevel connections you want. The type variable <code class="language-plaintext highlighter-rouge">n</code> is a typelevel thing that represents the value.</p>

<p>Now let‚Äôs talk about proving. Basically, if you‚Äôre intent is proving things, I think it is simplest if you forget that the original data type ever existed. It is just a vestigial appendix that makes the DataKinds you need. Only work with singletons. You will then need to make a safe layer translating into and out of the singletons if you want to interface with non-singleton code.</p>

<p>We‚Äôre going to want to prove something about equality. The standard definition of equality is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
data Eq1 a b where
    Refl :: Eq1 a a
</code></pre></div></div>

<p>I put the 1 there just so I wouldn‚Äôt clash with the Eq typeclass. It‚Äôs  ugly, sorry. You can find an identical definition in base <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html">http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html</a> that uses the extension TypeOperators for a much cleaner syntax.</p>

<p>Why is this a reasonable equality?  You can construct using <code class="language-plaintext highlighter-rouge">Refl</code> only when you are just showing that <code class="language-plaintext highlighter-rouge">a</code> equals itself. When you pattern match on <code class="language-plaintext highlighter-rouge">Refl</code>, the type checker is learning that <code class="language-plaintext highlighter-rouge">a ~ b</code>. It‚Äôs confusing. Let‚Äôs just try using it.</p>

<p>We can prove a couple facts about equality. First off that it is a symmetric relation. If $ a = b$ then $ b = a$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
symm :: Eq1 a b -&gt; Eq1 b a
symm Refl = _
</code></pre></div></div>

<p>When we pattern match and expose the incoming <code class="language-plaintext highlighter-rouge">Refl</code>, the type checker learns that <code class="language-plaintext highlighter-rouge">a ~ b</code> in this branch of the pattern match. Now we need to return an <code class="language-plaintext highlighter-rouge">Eq1 b a</code>. But we know that <code class="language-plaintext highlighter-rouge">a ~ b</code> so this is the same as an <code class="language-plaintext highlighter-rouge">Eq1 a a</code>. Well, we can easily do that with a <code class="language-plaintext highlighter-rouge">Refl</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
symm :: Eq1 a b -&gt; Eq1 b a
symm Refl = Refl
</code></pre></div></div>

<p>Similarly we can prove the transitivity of equality.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
trans :: Eq1 a b -&gt; Eq1 b c -&gt; Eq1 a c 
trans Refl Refl = Refl
</code></pre></div></div>

<p>Pattern matching on the first equality tells the type checker that <code class="language-plaintext highlighter-rouge">a ~ b</code>, the second that <code class="language-plaintext highlighter-rouge">b ~ c</code>. Now we need to return a <code class="language-plaintext highlighter-rouge">Eq1 a c</code> but this is the same as <code class="language-plaintext highlighter-rouge">Eq1 a a</code> because of the <code class="language-plaintext highlighter-rouge">~</code> we have, so <code class="language-plaintext highlighter-rouge">Refl</code> suffices.</p>

<p>It‚Äôs all damn clever. I wouldn‚Äôt have come up with it.</p>

<p>Now let‚Äôs start proving things about our addition operator. Can we prove that</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
proof1 :: Eq1 'Zero 'Zero
proof1 = Refl
</code></pre></div></div>

<p>This one is straightforward since obviously <code class="language-plaintext highlighter-rouge">'Zero</code> is <code class="language-plaintext highlighter-rouge">'Zero</code>. How about something slightly more complicated $ 1 + 0 = 1$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
proof1' :: Eq1 (NPlus ('Succ 'Zero) 'Zero) ('Succ 'Zero)
proof1' = Refl
</code></pre></div></div>

<p>The typechecker can evaluate addition on concrete numbers to confirm this all works out.</p>

<p>Here‚Äôs a much more interesting property $ \forall x. 0 + x = x$</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
proof2 :: SNat x -&gt; Eq1 (NPlus 'Zero x) x
proof2 x = Refl
</code></pre></div></div>

<p>This one is also straightforward to prove. Looking at the definition of <code class="language-plaintext highlighter-rouge">NPlus</code> knowing that the first argument is <code class="language-plaintext highlighter-rouge">'Zero</code> is enough to evaluate forward.</p>

<p>Here‚Äôs our first toughy. $ \forall x. x + 0 = x$ This may seem silly, but our definition of <code class="language-plaintext highlighter-rouge">NPlus</code> did not treat the two arguments symmetrically. it only pattern match on the first. Until we know more about x, we can‚Äôt continue. So how do we learn more? By pattern matching and looking at the possible cases of <code class="language-plaintext highlighter-rouge">x</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
proof3 :: SNat x -&gt; (Eq1 (NPlus x 'Zero) x)
proof3 SZero = Refl
proof3 (SSucc x) | Refl &lt;- proof3 x = Refl
</code></pre></div></div>

<p>The first case is very concrete and easy to prove. The second case is more subtle. We learn that <code class="language-plaintext highlighter-rouge">x ~ 'Succ x1</code> for some <code class="language-plaintext highlighter-rouge">x1</code> when we exposed the <code class="language-plaintext highlighter-rouge">SSucc</code> constructor. Hence we now need to prove <code class="language-plaintext highlighter-rouge">Eq1 (NPlus ('Succ x1) 'Zero) ('Succ x1)</code>. The system now has enough information to evaluate <code class="language-plaintext highlighter-rouge">NPlus</code> a bit, so actually we need <code class="language-plaintext highlighter-rouge">Eq1 ('Succ (NPlus x1 'Zero)) ('Succ x1)</code>. The term <code class="language-plaintext highlighter-rouge">(NPlus x1 'Zero)</code> looks very similar to what we were trying to prove in the first case. We can use a recursive call to get an equality proof that we pattern match to a <code class="language-plaintext highlighter-rouge">Refl</code> to learn that<code class="language-plaintext highlighter-rouge">(NPlus x1 'Zero) ~ x1</code> which will then make the required result <code class="language-plaintext highlighter-rouge">Eq1 ('Succ x1) ('Succ x1)</code> which is obviously true via <code class="language-plaintext highlighter-rouge">Refl</code>. I learned a neat-o syntax for this second pattern match, called pattern guards. Another way of writing the same thing is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
proof3 (SSucc x) = case (proof3 x) of Refl -&gt; Refl
</code></pre></div></div>

<p>Follow all that? Haskell is not as friendly a place to do this as Idris or Agda is.</p>

<p>Now finally, the piece de resistance, the commutativity of addition, which works in a similar but more complicated way.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
natcomm :: SNat x -&gt; SNat y -&gt; Eq1 (NPlus x y) (NPlus y x)
natcomm SZero y | Refl &lt;- proof3 y = Refl 
natcomm x@(SSucc x') SZero | Refl &lt;- proof3 x = Refl
natcomm (SSucc x) (SSucc y) | Refl &lt;- natcomm x (SSucc y), Refl &lt;- natcomm (SSucc x) y, Refl &lt;- natcomm x y = Refl
</code></pre></div></div>

<p>A question: to what degree does this prove that <code class="language-plaintext highlighter-rouge">nplus</code> or <code class="language-plaintext highlighter-rouge">snplus</code> are commutative? The linkage is not perfect. <code class="language-plaintext highlighter-rouge">snplus</code> is type constrained to return the same result as <code class="language-plaintext highlighter-rouge">NPlus</code> which feels ok. <code class="language-plaintext highlighter-rouge">nplus</code> is syntactically identical to the implementation of the other two, but that is the only link, there is nothing compiler enforced.</p>

<p>The existence of non-termination in Haskell also makes everything done here much less fool-proof. It wouldn‚Äôt be all that hard to accidentally make a recursive call in one of our proofs that is non terminating and the compiler would accept it and say nothing.</p>

<p>I recommend you check out the links below for more.</p>

<p>Source available here <a href="https://github.com/philzook58/singleberg">https://github.com/philzook58/singleberg</a></p>

<p>Resources:</p>

<p><a href="https://github.com/RyanGlScott/ghc-software-foundations">https://github.com/RyanGlScott/ghc-software-foundations</a></p>

<p><a href="http://hackage.haskell.org/package/singletons">http://hackage.haskell.org/package/singletons</a></p>

<p><a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">https://blog.jle.im/entry/introduction-to-singletons-1.html</a></p>

<p><a href="http://hackage.haskell.org/package/singleton-nats">http://hackage.haskell.org/package/singleton-nats</a></p>

:ET